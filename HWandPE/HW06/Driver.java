package HW06;
import java.io.PrintStream;
import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystemException;
import java.nio.file.Files;
import java.util.List;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Scanner;
import java.lang.reflect.Field;
import java.util.function.Consumer;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
//AUTOGENERATED FROM ../src/IOHijacker.java

/**
 * A helper class used for redirecting System.out to check against
 */
class IOHijacker {
    private static IOHijacker INSTANCE;

    private String log = "";
    private PrintStream originalStream;
    private PrintStream redirectedStream;
    private boolean recording = false;

    private IOHijacker() {
        this.originalStream = System.out;
    }

    /**
     * Starts recording all System.out messages to the console and stores them in
     * IOHijacker.log.
     * 
     * Until stopRecording is called, no System.out messages will appear.
     */
    public void startRecording() {
        log = "";

        if (redirectedStream == null)
            redirectedStream = getRedirectedStream();

        System.setOut(redirectedStream);

        recording = true;
    }

    /**
     * Stops the current recording, resetting System.out to its default behavior.
     * 
     * @return A list of all messages sent during the recording
     */
    public String stopRecording() {
        recording = false;

        System.setOut(originalStream);

        return log;
    }

    /**
     * Retrieves the current log of messages in a recording
     * 
     * @return The current log of messages
     */
    public String getCurrentLog() {
        return log;
    }

    /**
     * Retrieves a custom PrintStream that redirects print to instead logMessage
     * 
     * @return The custom PrintStream
     */
    private PrintStream getRedirectedStream() {
        return new PrintStream(System.out, true) {
            @Override
            public void print(String s) {
                IOHijacker.appendMessage(s);
            }

            @Override
            public PrintStream printf(String message, Object... args) {
                IOHijacker.appendMessage(String.format(message, args));
                return this;
            }

            @Override
            public void println(String s) {
                IOHijacker.appendMessage(s + "\n");
            }

        };
    }

    /**
     * Returns the Singleton's instance, creating one if it doesn't exist.
     * 
     * @return The IOHijacker instance
     */
    public static IOHijacker getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new IOHijacker();
        }

        return INSTANCE;
    }

    /**
     * Appends a string message to the log ONLY if recording.
     * 
     * @param message The message to be recorded
     */
    private static void appendMessage(String message) {
        IOHijacker instance = getInstance();

        if (!instance.recording)
            return;

        instance.log += message.replaceAll("\r","");
    }
}

//AUTOGENERATED FROM ../src/TestUtils.java

class TestUtils {

    /**
     * Returns either 1, 0, or -1 depending on the sign of the input.
     * 
     * @param input
     * @return -1 if input < 0, 0 if input = 0, 1 if input > 0
     */
    public static int signOf(int input) {
        if (input == 0) {
            return input;
        } else {
            return Math.abs(input) / input;
        }
    }

    public static String combinePrintStatements(List<String> printedMessages) {
        if (printedMessages == null || printedMessages.size() == 0) {
            return "";
        }

        StringBuilder builder = new StringBuilder(printedMessages.get(0));
        for (int i = 1; i < printedMessages.size(); i++) {
            builder.append("\n");
            builder.append(printedMessages.get(i));
        }
        return builder.toString();
    }

    /**
     * Enum that contains "invalid" Strings.
     */
    public enum StringInput {
        NULL(null),
        EMPTY(""),
        BLANK("   ");

        private final String stringValue;

        private StringInput(String stringValue) {
            this.stringValue = stringValue;
        }

        public String getStringValue() {
            return this.stringValue;
        }
    }

    /**
     * Interface to allow lambda function-like functionality with Strings
     */
    public interface StringFunction {
        String run(String str);
    }

    public static void deleteFile(String path) {
        File file = new File(path);

        try {
            Files.delete(file.toPath());
        } catch (FileSystemException e) {

            if (e.getMessage().contains("used by another process")) {
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_YELLOW_BACKGROUND,
                        AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " DELETE FILE ERROR: \u00BB ")
                        + " The program failed to delete " + file.getName() + ". Although this will not change the outcome of the tests, to solve this issue you must ensure ALL of your scanners have been properly closed, INCLUDING during an exception. This has only been recorded on Windows machines, but feel free to reach out if you encounter the issue!");

            }
        } catch (IOException e) {
        }
    }
}

//AUTOGENERATED FROM ../src/InjectData.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
@interface InjectData {
    /**
     * The name of the file data is injected from
     * 
     * @return The name of the TestCase
     */
    public String name();
}

//AUTOGENERATED FROM ../src/BeforeTest.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.FIELD })
@interface BeforeTest { }

//AUTOGENERATED FROM ../src/TestContainer.java

/**
 * Represents a Runnable that can be thrown into a ThreadPoolExecutor. The
 * TestContainer will latch onto a Class<?> and attempt to run any methods
 * labeled as test functions, e.g. @TestCase or @BeforeTest
 */
class TestContainer implements Runnable {
    /**
     * The class belonging to the TestContainer
     */
    private Class<?> clazz;

    /**
     * As the methods are non-static, there must be an instance all share when
     * executing the methods. At the start of the test a single instance is
     * initialized for all tests to use.
     */
    private Object instance = null;

    /**
     * Initializes a new TestContainer. A TestContainer is used to prevent certain
     * edge cases such as infinite loops.
     * 
     * If an infinite loop occurs, the test will timeout and notify the user
     * accordingly.
     * 
     * @param clazz The class containing the tests
     */
    public TestContainer(Class<?> clazz) {
        this.clazz = clazz;
    }

    /**
     * Executes a method belonging to this instance.
     * This is used when cycling over the methods marked with @BeforeTest
     * and @AfterTest, as both require the same invocation logic.
     * 
     * @param method The method to execute
     */
    private void executeFunction(Method method) {
        try {
            method.invoke(instance);
        } catch (Exception e) {
            System.out.println(ColorUtils.formatColorString(AsciiColorCode.WHITE_BACKGROUND,
                    AsciiColorCode.RED_FOREGROUND,
                    "\tThe executed code caused the following exception."));

            e.getCause().printStackTrace();
        }
    }

    /**
     * Attempts to execute a TestCase found within the TestContainer.
     * 
     * @param tuple A Tuple<Method, TestCase> containing the method to run, and the
     *              TestCase associated with it. These are wrapped into a Tuple to
     *              avoid having to call getAnnotation twice.
     * @return true if the test case was successful
     */
    private boolean executeTestCase(Tuple<Method, TestCase> tuple) {
        Method m = tuple.first;
        TestCase testCase = tuple.second;
        Tip tip = m.getAnnotation(Tip.class);

        try {

            m.invoke(instance);

            System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_GREEN_BACKGROUND,
                    AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " PASSED: \u00BB ") + " "
                    + testCase.name());

            TestManager.submitTest(0);
        } catch (InvocationTargetException e) {
            System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                    AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " FAILED: \u00BB ") + " "
                    + testCase.name());

            if (e.getCause() instanceof TestFailedException) {
                TestFailedException tfe = (TestFailedException) e.getCause();

                System.out.println("\t" + tfe.getMessage());

                if (tip != null)
                    System.out.printf("\t%s\n", ColorUtils.formatColorString(AsciiColorCode.BRIGHT_WHITE_BACKGROUND,
                            AsciiColorCode.BLACK_FOREGROUND, "HINT: " + tip.description()));
            } else {
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.WHITE_BACKGROUND,
                        AsciiColorCode.RED_FOREGROUND,
                        "\tThe executed code caused the following exception. This is NOT the fault of the driver."));

                e.getCause().printStackTrace();
            }

            return false;
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
        }

        return true;
    }

    @Override
    public void run() {
        try {
            TestManager.printTestCategory(clazz.getName());

            instance = clazz.getDeclaredConstructor().newInstance();

            int classTests = 0;
            int classTestsFailed = 0;

            // TODO: Likely move this to a more abstract system
            List<Tuple<Method, BeforeTest>> beforeTest = new ArrayList<>();
            List<Tuple<Method, AfterTest>> afterTest = new ArrayList<>();
            List<Tuple<Method, TestCase>> testMethods = new ArrayList<>();

            for (Method m : clazz.getMethods()) {
                TestCase testAnnotation = m.getAnnotation(TestCase.class);
                BeforeTest beforeTestAnnotation = m.getAnnotation(BeforeTest.class);
                AfterTest afterTestAnnotation = m.getAnnotation(AfterTest.class);

                if (testAnnotation != null) {
                    testMethods.add(new Tuple<Method, TestCase>(m, testAnnotation));
                } else if (beforeTestAnnotation != null) {
                    beforeTest.add(new Tuple<Method, BeforeTest>(m, beforeTestAnnotation));
                } else if (afterTestAnnotation != null) {
                    afterTest.add(new Tuple<Method, AfterTest>(m, afterTestAnnotation));
                }
            }

            for (Tuple<Method, BeforeTest> tuple : beforeTest) {
                executeFunction(tuple.first);
            }

            for (Tuple<Method, TestCase> tuple : testMethods) {
                boolean result = executeTestCase(tuple);

                classTests++;

                if (!result)
                    classTestsFailed++;
            }

            for (Tuple<Method, AfterTest> tuple : afterTest) {
                executeFunction(tuple.first);
            }

            TestManager.classTests.set(TestManager.classTests.get() + classTests);
            TestManager.classTestsFailed.set(TestManager.classTestsFailed.get() + classTestsFailed);

            System.out.println();
            StringUtils.printTextCentered(
                    String.format("TESTS PASSED: %d/%d", classTests - classTestsFailed, classTests));

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
//AUTOGENERATED FROM ../src/StringUtils.java

class StringUtils {
    /**
     * The ASCII character to use for horizontal lines
     */
    public static final String HORIZONTAL_LINE_CHARACTER = "\u2500";

    /**
     * The amount of HORIZONTAL_LINE_CHARACTER elements to use in a line
     */
    public static final int HORIZONTAL_LINE_LENGTH = 48;

    /**
     * Prints a horizontal line to the terminal.
     */
    public static void printHorizontalLine() {
        System.out
                .println(String.format("%0" + HORIZONTAL_LINE_LENGTH + "d", 0).replace("0", HORIZONTAL_LINE_CHARACTER));
    }

    /**
     * Prints centered text to the terminal.
     * 
     * @param text The text to be centered
     */
    public static void printTextCentered(String text) {
        // HORIZONTAL_LINE_LENGTH is maximum width
        // if line is
        // xxxxxxxxxxxx
        // We can pad the start of the string with half of the horizontal:
        // xxxxxhelloxx
        // The problem is that this doesn't account for the length of the string.
        // We can add half of the string length as well to correct it:
        // xxxxhelloxxxx = CENTERED! (or at least as close as it can get)

        System.out.printf("%" + (HORIZONTAL_LINE_LENGTH / 2 + text.length() / 2) + "s%n", text);
    }

    /**
     * Util that a stack trace into a printable string.
     * @param e Exception to print the stacktrace of
     * @return
     */
    public static String stackTraceToString(Throwable e) {
        StackTraceElement[] stackTrace = e.getStackTrace();
        
        if (stackTrace.length == 0) {
            return "No stack trace.";
        }

        StringBuilder sb = new StringBuilder(stackTrace[0].toString());
        for (int i = 1; i < stackTrace.length; i++) {
            sb.append("\n    ");
            sb.append(stackTrace[i].toString());
        }
        return sb.toString();
    }

    public static String arrayListToString(ArrayList<? extends Object> inputs) {
        if (inputs.size() == 0) {
            return "";
        }

        StringBuilder builder = new StringBuilder();

        for (int i = 0; i < inputs.size(); i++) {
            builder.append(inputs.get(i).toString() + "\n");
        }

        return builder.toString();
    }

    public static String fileToString(String path) throws FileNotFoundException {
        Scanner scanner = new Scanner(new File(path));

        String output = "";

        while (scanner.hasNextLine()) {
            String next = scanner.nextLine();

            output += next + "\n";
        }

        scanner.close();

        return output;
    }

    /**
     * Prints the given String to the file at the path.
     * THIS METHOD WILL OVERWRITE ANY DATA.
     * @param path Path to write at.
     * @param data Data to write to the file.
     * @throws FileNotFoundException
     */
    public static void stringToFile(String path, String data) throws FileNotFoundException {

        PrintWriter writer = new PrintWriter(path);

        writer.write(data);

        writer.close();

    }

    /**
     * Returns a modified version of 'actual', where the first character that differs from
     * 'expected' is highlighted RED.
     * @param actual The 'actual' String
     * @param expected The 'expected' String to compare against
     * @return
     */
    public static String getColorCodedDifference(String actual, String expected) {
        StringBuilder colored = new StringBuilder();
        for (int i = 0; i < actual.length(); i++) {
            char actualChar = actual.charAt(i);

            if (expected.length() <= i) {
                colored.append(actual.substring(i));
                break;
            }

            if (actualChar == expected.charAt(i)) {
                colored.append(actual.charAt(i));
            } else {
                colored.append(ColorUtils.formatColorString(AsciiColorCode.RED_BACKGROUND, AsciiColorCode.WHITE_FOREGROUND, actualChar + ""));
                colored.append(actual.substring(i + 1));
                break;
            }

        }

        return colored.toString();
        
    }
}

//AUTOGENERATED FROM ../src/Tip.java

@Retention(RetentionPolicy.RUNTIME)
@interface Tip {
    /**
     * Used to display a helpful tip when the user fails a test.
     * 
     * @return The main tip body message
     */
    public String description() default "";
}

//AUTOGENERATED FROM ../src/TicketsTests.java

class TicketsTests {

    @BeforeTest
    public void setupFiles() throws FileNotFoundException, IllegalArgumentException, IllegalAccessException {

        for (Field field : TxtTestData.class.getFields()) {
            if (field.getType() == String.class) {
                BeforeTest beforeAnnotation = field.getAnnotation(BeforeTest.class);

                if (beforeAnnotation != null) {
                    StringUtils.stringToFile("TEMP_" + field.getName() + ".txt", field.get(null).toString());
                }

            }
        }

    }

    @BeforeTest
    public void deleteOldFiles() {

        for (Field field : TxtTestData.class.getFields()) {
            if (field.getType() == String.class) {
                DeleteFileBefore deleteAnnotation = field.getAnnotation(DeleteFileBefore.class);

                if (deleteAnnotation != null) {
                    TestUtils.deleteFile("TEMP_" + field.getName() + ".txt");
                }

            }
        }

    }

    @AfterTest
    public void deleteTextFiles() throws FileNotFoundException, IllegalArgumentException, IllegalAccessException {

        for (Field field : TxtTestData.class.getFields()) {
            if (field.getType() == String.class) {
                DeleteFileAfter deleteAnnotation = field.getAnnotation(DeleteFileAfter.class);

                if (deleteAnnotation != null) {
                    TestUtils.deleteFile("TEMP_" + field.getName() + ".txt");
                }

            }
        }

    }
 
    @TestCase(name = "RetrieveGames: File contains valid FootballGames and BasketballGames")
    @Tip(description = "No tip. I think you can figure this one out.")
    public void retrieveGamesValidInputs() throws TestFailedException {
        
        try {
            ArrayList<SportsGame> games = Tickets.retrieveGames("TEMP_" + "retrieveGamesValidInputs.txt");
            TestFunction.assertEqual(StringUtils.arrayListToString(games), TxtTestData.retrieveGamesValidInputs);
        } catch (FileNotFoundException fnfe) {
            throw new TestFailedException("Generated FileNotFoundException when no exception should occur!");
        } catch (InvalidTicketException ite) {
            throw new TestFailedException("Generated InvalidTicketException when no exception should occur!");
        }

    }
 
    @TestCase(name = "RetrieveGames: Inputted path name is null")
    @Tip(description = "What error should be thrown when the given path is null?")
    public void retrieveGamesNullInput() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.retrieveGames(null);
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }
 
    @TestCase(name = "RetrieveGames: Inputted path name is blank")
    @Tip(description = "What error should be thrown when the given path is blank?")
    public void retrieveGamesBlankInput() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.retrieveGames("   ");
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }
 
    @TestCase(name = "RetrieveGames: Inputted path name is empty")
    @Tip(description = "What error should be thrown when the given path is empty?")
    public void retrieveGamesEmptyInput() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.retrieveGames("");
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }
 
    @TestCase(name = "RetrieveGames: Inputted path name is not found")
    @Tip(description = "What error should be thrown when no file exists at the given path?")
    public void retrieveGamesNotFoundInput() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.retrieveGames("filethatdoesnotexist.txt");
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }
 
    @TestCase(name = "RetrieveGames: One line in file has invalid gameType token (SoccerGame)")
    @Tip(description = "See the example on page 4 of the directions. What exception should be thrown?")
    public void retrieveGamesInvalidTicket() throws TestFailedException {

        Class<? extends Exception> exceptionType = InvalidTicketException.class;
        
        try {
            Tickets.retrieveGames("TEMP_" + "retrieveGamesInvalidInputs.txt");
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }

    @TestCase(name = "purchaseTickets: Inputs are valid, file does not yet exist")
    @Tip(description = "Make sure that you create the file if it does not yet exist. Is there a particular constructor for an object that prints to a file that you can use to automatically create a file?")
    public void purchaseTicketsWritingToEmptyFile() throws IOException, TestFailedException {
        ArrayList<SportsGame> gamesToAdd = new ArrayList<>();
        gamesToAdd.add(new FootballGame("Bobby Dodd", "17:00", "03-01-2020", 9, 9, 2, "Drake"));
        gamesToAdd.add(new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
        gamesToAdd.add(new FootballGame("Levi's Stadium", "17:00", "03-01-2020", 9, 9, 2, "Drake"));

        try {
            Tickets.purchaseTickets("TEMP_" + "purchaseTicketsWritingToEmptyFile.txt", gamesToAdd);
        } catch (InvalidTicketException ite) {
            throw new TestFailedException("Your code threw an InvalidTicketException when it should not have!");
        }

        String output = StringUtils.fileToString("TEMP_" + "purchaseTicketsWritingToEmptyFile.txt");

        TestFunction.assertEqual(output, TxtTestData.purchaseTicketsWritingToEmptyFile);
    }

    @TestCase(name = "purchaseTickets: Inputs are valid, file already exists")
    @Tip(description = "Make sure that you're just appending the new SportsGames to the end of the file!\nYou must read the values at that file before creating your writer, if your writer deletes the existing contents.\nRemember to follow read/modify/write protocol!")
    public void purchaseTicketsWritingToExistingFile() throws IOException, TestFailedException {
        ArrayList<SportsGame> gamesToAdd = new ArrayList<>();
        gamesToAdd.add(new FootballGame("Bobby Dodd", "17:00", "03-01-2020", 9, 9, 2, "Drake"));
        gamesToAdd.add(new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
        gamesToAdd.add(new FootballGame("Levi's Stadium", "17:00", "03-01-2020", 9, 9, 2, "Drake"));

        try {
            Tickets.purchaseTickets("TEMP_" + "purchaseTicketsAppend.txt", gamesToAdd);
        } catch (InvalidTicketException ite) {
            throw new TestFailedException("Your code threw an InvalidTicketException when it should not have!");
        }

        String output = StringUtils.fileToString("TEMP_" + "purchaseTicketsAppend.txt");

        TestFunction.assertEqual(output, TxtTestData.purchaseTicketsAppendOutput);
    }

    @TestCase(name = "purchaseTickets: Do not add if seatsLeft are 0")
    @Tip(description = "What should you do if there are 0 seats left?")
    public void purchaseTicketsZeroSeatsLeft() throws IOException, TestFailedException {
        ArrayList<SportsGame> gamesToAdd = new ArrayList<>();
        gamesToAdd.add(new FootballGame("Bobby Dodd", "17:00", "03-01-2020", 9, 9, 2, "Drake"));
        gamesToAdd.add(new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 0, "NCAA"));
        gamesToAdd.add(new FootballGame("Levi's Stadium", "17:00", "03-01-2020", 9, 9, 2, "Drake"));

        try {
            Tickets.purchaseTickets("TEMP_" + "purchaseTicketsZeroSeats.txt", gamesToAdd);
        } catch (InvalidTicketException ite) {
            throw new TestFailedException("Your code threw an InvalidTicketException when it should not have!");
        }

        String output = StringUtils.fileToString("TEMP_" + "purchaseTicketsZeroSeats.txt");

        TestFunction.assertEqual(output, TxtTestData.purchaseTicketsZeroSeatsOutput);
    }

    @TestCase(name = "purchaseTickets: Throws an InvalidTicketException if an existing game is invalid.")
    @Tip(description = "From HW06 Clarification Thread: https://edstem.org/us/courses/42939/discussion/3775943?comment=8757839\nMake sure you propagate this exception upwards!")
    public void purchaseTicketsInvalidGameExists() throws TestFailedException {
        ArrayList<SportsGame> gamesToAdd = new ArrayList<>();
        gamesToAdd.add(new FootballGame("Bobby Dodd", "17:00", "03-01-2020", 9, 9, 2, "Drake"));
        
        Class<? extends Exception> exceptionType = InvalidTicketException.class;

        try {
            Tickets.purchaseTickets("TEMP_" + "purchaseTicketsInvalidGame.txt", gamesToAdd);
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }
        
    }

    @TestCase(name = "findTickets: File is null")
    @Tip(description = "What exception should findTickets() throw if the given file is null?")
    public void findTicketsNull() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.findTickets(null, new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }
    
    @TestCase(name = "findTickets: Inputted path name is blank")
    @Tip(description = "What error should be thrown when the given path is blank?")
    public void findTicketsBlankInput() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.findTickets("   ", new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }
 
    @TestCase(name = "findTickets: Inputted path name is empty")
    @Tip(description = "What error should be thrown when the given path is empty?")
    public void findTicketsEmptyInput() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.findTickets("", new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }
 
    @TestCase(name = "findTickets: No file at the inputted path")
    @Tip(description = "What error should be thrown when the given path does not lead to a file?")
    public void findTicketsNotFoundInput() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.findTickets("willthisfileeverexist.txt", new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }

    @TestCase(name = "findTickets: One occurrence")
    @Tip(description = "What format of Integers should be returned? What index is the first line of the file?\nNOTE: The directions do not specify that you must list the indices in ascending order, but this Driver assumes you do.")
    public void findTicketsOneOccurrence() throws IOException, TestFailedException, InvalidTicketException {
        ArrayList<Integer> output = Tickets.findTickets("TEMP_" + "findTicketsOneOccurrence.txt", new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));

        TestFunction.assertEqual(output.toString(), "[1]");
    }

    @TestCase(name = "findTickets: Multiple occurrences")
    @Tip(description = "What format of Integers should be returned? What index is the first line of the file?\nNOTE: The directions do not specify that you must list the indices in ascending order, but this Driver assumes you do.")
    public void findTicketsSeveralOccurrences() throws IOException, TestFailedException, InvalidTicketException {
        ArrayList<Integer> output = Tickets.findTickets("TEMP_" + "findTicketsSeveralOccurrences.txt", new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));

        TestFunction.assertEqual(output.toString(), "[1, 3, 5]");
    }

    @TestCase(name = "findTickets: Adjacent occurrences")
    @Tip(description = "Make sure that you're reading every single occurrence!\nNOTE: The directions do not specify that you must list the indices in ascending order, but this Driver assumes you do.")
    public void findTicketsAdjacentOccurrences() throws IOException, TestFailedException, InvalidTicketException {
        ArrayList<Integer> output = Tickets.findTickets("TEMP_" + "findTicketsAdjacentOccurrences.txt", new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));

        TestFunction.assertEqual(output.toString(), "[1, 3, 4, 6]");
    }

    @TestCase(name = "findTickets: No occurrences of the given SportsGame")
    @Tip(description = "What exception should be thrown if there are no occurrences of the gievn SportsGame?")
    public void findTicketsNoOccurrences() throws IOException, TestFailedException, InvalidTicketException {

        Class<? extends Exception> exceptionType = InvalidTicketException.class;
        
        try {
            Tickets.findTickets("TEMP_" + "findTicketsSeveralOccurrences.txt", new BasketballGame("Mercedes-Benz", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }
    }

    @TestCase(name = "attendGame: File is null")
    @Tip(description = "What exception should findTickets() throw if the given file is null?")
    public void attendGameNull() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.findTickets(null, new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }
    
    @TestCase(name = "attendGame: Inputted path name is blank")
    @Tip(description = "What error should be thrown when the given path is blank?")
    public void attendGameBlankInput() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.findTickets("   ", new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }
 
    @TestCase(name = "attendGame: Inputted path name is empty")
    @Tip(description = "What error should be thrown when the given path is empty?")
    public void attendGameEmptyInput() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.findTickets("", new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }
 
    @TestCase(name = "attendGame: Inputted path name is not found")
    @Tip(description = "What error should be thrown when the given path does not exist?")
    public void attendGameNotFoundInput() throws TestFailedException {

        Class<? extends Exception> exceptionType = FileNotFoundException.class;
        
        try {
            Tickets.findTickets("thisfileshouldneverexist.txt", new BasketballGame("McCamish", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }

    }

    @TestCase(name = "attendGame: No occurrences of the given SportsGame")
    @Tip(description = "What exception should be thrown if there are no occurrences of the gievn SportsGame?")
    public void attendGameNoOccurrences() throws IOException, TestFailedException, InvalidTicketException {

        Class<? extends Exception> exceptionType = InvalidTicketException.class;
        
        try {
            Tickets.findTickets("TEMP_" + "attendGameNoOccurrences.txt", new BasketballGame("Mercedes-Benz", "17:00", "03-01-2020", 9, 9, 2, "NCAA"));
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }
    }

    @TestCase(name = "attendGame: Several non-adjacent occurrences of the given SportsGame")
    @Tip(description = "Make sure you remove ALL occurrences of the given SportsGame!")
    public void attendGameSeveralOccurrences() throws IOException, TestFailedException, InvalidTicketException {

        Tickets.attendGame("TEMP_" + "attendGameSeveralOccurrences.txt", new BasketballGame("McCamish", "0:00", "01-01-2020", 1, 1, 1, "NCAA"));
        String output = StringUtils.fileToString("TEMP_" + "attendGameSeveralOccurrences.txt");

        TestFunction.assertEqual(output.toString(), TxtTestData.attendGameSeveralOccurrencesOutput);

    }

    @TestCase(name = "attendGame: Several non-adjacent occurrences of the given SportsGame")
    @Tip(description = "Make sure you don't skip over the second of two adjacent SportsGames. What happens if you remove an item at an index, shift all subsequent items leftward, then increment your current index?")
    public void attendGameAdjacentOccurrences() throws IOException, TestFailedException, InvalidTicketException {

        Tickets.attendGame("TEMP_" + "attendGameAdjacentOccurrences.txt", new BasketballGame("McCamish", "0:00", "01-01-2020", 1, 1, 1, "NCAA"));
        String output = StringUtils.fileToString("TEMP_" + "attendGameAdjacentOccurrences.txt");

        TestFunction.assertEqual(output.toString(), TxtTestData.attendGameAdjacentOccurrencesOutput);

    }

}


//AUTOGENERATED FROM ../src/ColorUtils.java
class ColorUtils {
    /**
     * Formats a string to have an ASCII background in terminal.
     * 
     * @param background The ASCII representation of the background color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatBackgroundColorString(String background, String s) {
        return background + s + AsciiColorCode.RESET_COLOR;
    }

    /**
     * Formats a string to have an ASCII foreground (text color) in terminal.
     * 
     * @param foreground The ASCII representation of the foreground color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatForegroundColorString(String foreground, String s) {
        return foreground + s + AsciiColorCode.RESET_COLOR;

    }

    /**
     * Formats a string to have both an ASCII foreground and background in terminal
     * 
     * @param background The ASCII representation of the background color, pulled
     *                   from AsciiColorCode
     * @param foreground The ASCII representation of the foreground color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatColorString(String background, String foreground, String s) {
        return foreground + background + s + AsciiColorCode.RESET_COLOR;
    }
}

//AUTOGENERATED FROM ../src/DataClass.java
@interface DataClass { }

//AUTOGENERATED FROM ../src/TestFunction.java

class TestFunction {
    /**
     * Detects if the given Strings do not have the same content (case-sensitive)
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(String actual, String expected) throws TestFailedException {
        boolean failed = false;

        if (actual == null) {
            if (expected != null) {
                throw new TestFailedException("Test failed! Received null, but expected \"" + expected + "\"");
            }
        } else if (expected == null) {
            if (actual != null) {
                throw new TestFailedException("Test failed! Received \"" + actual + "\", but expected null");
            }
        } else {

            if (!actual.replaceAll("\n", System.lineSeparator()).equals(expected.replaceAll("\n", System.lineSeparator()))) {
                failed = true;
            }
        }

        if (failed) {
            
            
            String expectedString = (expected == null) ? "null" : "\"" + expected + "\"";
            String coloredActual = StringUtils.getColorCodedDifference("\"" + actual + "\"", expectedString);

            
            if (coloredActual.trim().contains("\n")) {
                coloredActual = "\n" + coloredActual + "\n";
            }
            if (expected.trim().contains("\n")) {
                expectedString = "\n\"" + expected + "\"\n";
            }

            throw new TestFailedException(
                    "Strings different! Received " + coloredActual + " but expected " + expectedString);
        }
    }

    public static void assertEqual(List<String> actual, List<String> expected) throws TestFailedException {
        boolean failed = false;

        if (actual == null || expected == null || actual.size() != expected.size()) {
            failed = actual == expected;
        } else {
            for (int i = 0; i < expected.size(); i++) {
                if (expected.get(i) == null) {
                    failed = actual.get(i) != null;

                } else {
                    failed = !actual.get(i).equals(expected.get(i));

                }
                if (failed) break;
            }
        }

        if (failed) {
            throw new TestFailedException(
                    "List Different! Received \"" + actual + "\", expected \"" + expected + "\"");
        }
    }

    /**
     * Detects if the given integers are not equal.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(int actual, int expected) throws TestFailedException {
        boolean failed = (actual != expected);
        if (failed) {
            throw new TestFailedException("Integer value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given doubles are not within 1.0e-6 of one another.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(double actual, double expected) throws TestFailedException {
        final double ALLOWABLE_ERROR = 0.000001;

        boolean failed = (Math.abs(actual - expected) > ALLOWABLE_ERROR);

        if (failed) {
            throw new TestFailedException("Double value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given booleans do not have equal values.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(boolean actual, boolean expected) throws TestFailedException {
        boolean failed = (actual != expected);

        if (failed) {
            throw new TestFailedException("Boolean value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given objects are equal by their .equals() methods. By default, this method will also test
     * for symmetry.
     *
     * @param expected Whether or not these two objects should be equal by their .equals() methods
     * @param obj1 The first object to compare.
     * @param obj2 The second object to compare.
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(boolean expected, Object obj1, Object obj2) throws TestFailedException {
        boolean actual = obj1.equals(obj2);
        if (actual != expected) {
            throw new TestFailedException("Boolean value difference with .equals() method. When comparing\n\"" + obj1.toString() + "\" with \"" + obj2.toString() + "\", Received " + actual + ", expected " + expected);
        }

        if (actual != obj2.equals(obj1)) {
            throw new TestFailedException("Asymmetry detected! When comparing \"" + obj1.toString() + "\" with \"" + obj2.toString() + "\", Received " + actual + ". But when calling .equals() the other way, received " + !actual);
        }
    }

    /**
     * Tests the given code for a particular type of Exception.
     * @param exceptionType The class of the expected Exception.
     * @param codeThatThrowsException Runnable code that is intended to throw an exceptino of type exceptionType. Must NOT throw a TestFailedException
     * @throws TestFailedException
     */
    public static void testForException(Class<? extends Exception> exceptionType, Runnable codeThatThrowsException) throws TestFailedException {
        try {
            codeThatThrowsException.run();
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }
    }

    /**
     * Tester for String inputs. Takes in a String -> String function, and compares the output with the desired output.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @param inputs The StringInput values to test.
     * @throws TestFailedException
     */
    public static void testStringInputs(String actual, TestUtils.StringFunction codeToRun, TestUtils.StringInput[] inputs) throws TestFailedException {

        for (TestUtils.StringInput stringInput : inputs) {
            try {
                assertEqual(actual, codeToRun.run(stringInput.getStringValue()));
            } catch (TestFailedException tfe) {
                throw new TestFailedException("When inputted string is " + stringInput.toString() + ": " + tfe.getMessage());
            }
        }

    }

    /**
     * Convenience method that calls testStringInputs(String, StringFunction, StringInput[]) for ALL
     * values of the StringFunction enum.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @throws TestFailedException
     */
    public static void testStringInputs(String actual, TestUtils.StringFunction codeToRun) throws TestFailedException {
        testStringInputs(actual, codeToRun, TestUtils.StringInput.values());
    }

    /**
     * Tester for String inputs. Takes in a String -> String function, and compares the output with the desired output.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @param inputs The StringInput values to test.
     * @throws TestFailedException
     */
    public static void testStringInputsForException(Class<? extends Exception> exceptionType, Consumer<String> codeToRun, TestUtils.StringInput... inputs) throws TestFailedException {

        for (TestUtils.StringInput stringInput : inputs) {
            try {
                testForException(exceptionType, () -> codeToRun.accept(stringInput.getStringValue()));
            } catch (TestFailedException tfe) {
                throw new TestFailedException("When inputted string is " + stringInput.toString() + ": " + tfe.getMessage());
            }
        }

    }

    /**
     * Convenience method that calls testStringInputs(String, StringFunction, StringInput[]) for ALL
     * values of the StringFunction enum.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @throws TestFailedException
     */
    public static void testStringInputsForException(Class<? extends Exception> exceptionType, Consumer<String> codeToRun) throws TestFailedException {
        testStringInputsForException(exceptionType, codeToRun, TestUtils.StringInput.values());
    }

    /**
     * Prints an error message
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException If the test fails
     */
    public static void failTest(String errorMessage) throws TestFailedException {
        throw new TestFailedException("An error occurred: " + errorMessage);
    }

}

//AUTOGENERATED FROM ../src/EqualsTests.java
class EqualsTests {
    
    private static final boolean[][] EQUALS_ANSWERS = new boolean[][] {
        {true, false, false},
        {false, true, false},
        {false, false, true}
    };

    @TestCase(name = "Check combinations of SportsGame, FootballGame, and BasketballGame for correctness")
    @Tip(description = "Make sure that you're checking all values!")
    public void correctnessTests() throws TestFailedException {
        SportsGame[] values = new SportsGame[] {
            new SportsGameTests.SportsGameSubclass("SAP Center", "19:00", "12-19-2004", 1, 2, 3),
            new FootballGame("SAP Center", "19:00", "12-19-2004", 1, 2, 3, "NFL"),
            new BasketballGame("SAP Center", "19:00", "12-19-2004", 1, 2, 3, "NFL"),
        };

        for (int i = 0; i < values.length; i++) {
            for (int j = 0; j < values.length; j++) {
                TestFunction.assertEqual(values[i].equals(values[j]), EQUALS_ANSWERS[i][j]);
            }
        }
    }

    @TestCase(name = "Check combinations of SportsGame, FootballGame, and BasketballGame for symmetry (not correctness)")
    @Tip(description = "Make sure you check for symmetry in the way we learned in class!")
    public void symmetryTests() throws TestFailedException {
        SportsGame[] values = new SportsGame[] {
            new SportsGameTests.SportsGameSubclass("SAP Center", "19:00", "12-19-2004", 1, 2, 3),
            new FootballGame("SAP Center", "19:00", "12-19-2004", 1, 2, 3, "NFL"),
            new BasketballGame("SAP Center", "19:00", "12-19-2004", 1, 2, 3, "NFL"),
        };

        for (int i = 0; i < values.length; i++) {
            for (int j = 0; j < values.length; j++) {
                try {
                    TestFunction.assertEqual(values[i].equals(values[j]), values[j].equals(values[i]));
                } catch (TestFailedException e) {
                    throw new TestFailedException(String.format("When a = \"%s\", b = \"%s\", testing a.equals(b): %s", values[i].toString(), values[j].toString(), e.getMessage()));
                }
            }
        }
    }

}

//AUTOGENERATED FROM ../src/TestCase.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
@interface TestCase {
    /**
     * The name of the TestCase, used for describing what a test might be doing
     * 
     * @return The name of the TestCase
     */
    public String name() default "UNNAMED_TEST";
}
//AUTOGENERATED FROM ../src/AfterTest.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
@interface AfterTest { }

//AUTOGENERATED FROM ../src/BasketballGameTests.java
class BasketballGameTests {
    
    @TestCase(name = "Constructor: Valid inputs")
    @Tip(description = "What order should the constructor arguments be?")
    public void constructorValidInputs() throws TestFailedException {
        
        BasketballGame game = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "NCAA");
        TestFunction.assertEqual(game.toString(), "BasketballGame,Mercedes-Benz,17:00,08-21-2023,6,70,1,NCAA");

    }

    @TestCase(name = "Constructor: Invalid league")
    @Tip(description = "What is a 'valid' league? What should happen when an invalid input is passed in?")
    public void constructorInvalidPerformer() throws TestFailedException {

        TestFunction.testStringInputsForException(IllegalArgumentException.class,
            (s) -> new BasketballGame(s, "00:00", "01-01-2000", 1, 1, 1, s));

    }

    @TestCase(name = "Constructor: League has leading/trailing whitespace")
    @Tip(description = "What method does the String class have to remove leading/trailing whitespace?")
    public void constructorLeagueSpaces() throws TestFailedException {

        BasketballGame game = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, " \n\tNCAA \n\t");
        TestFunction.assertEqual(game.toString(), "BasketballGame,Mercedes-Benz,17:00,08-21-2023,6,70,1,NCAA");

    }

    @TestCase(name = "Constructor: Non-default message in IllegalArgumentException (league)")
    @Tip(description = "Remember to provide a \"descriptive and specific\" message with ALL Exceptions thrown. What alternate constructor does IllegalArgumentException have that sets an error message?")
    public void constructorDescriptiveMessage6() throws TestFailedException {
        
        try {
            new BasketballGame("Bobby Dodd", "17:00", "01-01-2020", 6, 70, 1, "   ");
            throw new TestFailedException("Did not receive an IllegalArgumentException when giving an illegal value for performer");
        } catch (IllegalArgumentException iae) {
            if (iae.getMessage() == null) {
                throw new TestFailedException("Received error message \"" + iae.getMessage() + "\". Check Note 5 on Page 1 of the directions.");
            }
        }
        
    }

    @TestCase(name = "equals(): All values are equal")
    @Tip(description =  "What values must be equal for two SportsGames to be considered equal?")
    public void equalsEquals() throws TestFailedException {

        BasketballGame game1 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "NCAA");
        BasketballGame game2 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "NCAA");

        TestFunction.assertEqual(true, game1, game2);

    }

    @TestCase(name = "equals(): Different venue")
    @Tip(description =  "What values must be equal for two BasketballGames to be considered equal?")
    public void equalsVenue() throws TestFailedException {

        BasketballGame game1 = new BasketballGame("Mercedes-Bench", "17:00", "08-21-2023", 6, 70, 1, "NCAA");
        BasketballGame game2 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "NCAA");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different start time")
    @Tip(description =  "What values must be equal for two BasketballGames to be considered equal?")
    public void equalsTime() throws TestFailedException {

        BasketballGame game1 = new BasketballGame("Mercedes-Benz", "17:01", "08-21-2023", 6, 70, 1, "NCAA");
        BasketballGame game2 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "NCAA");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different start date")
    @Tip(description =  "What values must be equal for two BasketballGames to be considered equal?")
    public void equalsDate() throws TestFailedException {

        BasketballGame game1 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-1938", 6, 70, 1, "NCAA");
        BasketballGame game2 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "NCAA");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different score1")
    @Tip(description =  "What values must be equal for two BasketballGames to be considered equal?")
    public void equalsScore1() throws TestFailedException {

        BasketballGame game1 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 9, 70, 1, "NCAA");
        BasketballGame game2 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "NCAA");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different score2")
    @Tip(description =  "What values must be equal for two BasketballGames to be considered equal?")
    public void equalsScore2() throws TestFailedException {

        BasketballGame game1 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 56, 1, "NCAA");
        BasketballGame game2 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "NCAA");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different seatsLeft")
    @Tip(description =  "What values must be equal for two BasketballGames to be considered equal?")
    public void equalsSeats() throws TestFailedException {

        BasketballGame game1 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 2, "NCAA");
        BasketballGame game2 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "NCAA");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different league")
    @Tip(description =  "What values must be equal for two BasketballGames to be considered equal?")
    public void equalsLeauge() throws TestFailedException {

        BasketballGame game1 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 2, "NCAA");
        BasketballGame game2 = new BasketballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "NBA");

        TestFunction.assertEqual(false, game1, game2);

    }

}

//AUTOGENERATED FROM ../src/SportsGameTests.java
class SportsGameTests {
    
    @TestCase(name = "Constructor: Valid inputs")
    @Tip(description = "What order should the constructor arguments be?")
    public void constructorValidInputs() throws TestFailedException {
        
        SportsGame game = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1);
        TestFunction.assertEqual(game.toString(), "Mercedes-Benz,17:00,08-21-2023,6,70,1");

    }

    @TestCase(name = "Constructor: Invalid venue")
    @Tip(description = "What is a 'valid' venue? What should happen when an invalid input is passed in?")
    public void constructorInvalidVenue() throws TestFailedException {

        TestFunction.testStringInputsForException(IllegalArgumentException.class,
            (s) -> new SportsGameSubclass(s, "00:00", "01-01-2000", 1, 1, 1));

    }

    @TestCase(name = "Constructor: Invalid start time")
    @Tip(description = "What is a 'valid' start time? What should happen when an invalid input is passed in?")
    public void constructorInvalidStartTime() throws TestFailedException {

        TestFunction.testStringInputsForException(IllegalArgumentException.class,
            (s) -> new SportsGameSubclass("Bobby Dodd Stadium", s, "01-01-2000", 1, 1, 1));

    }

    @TestCase(name = "Constructor: Invalid start date")
    @Tip(description = "What is a 'valid' start date? What should happen when an invalid input is passed in?")
    public void constructorInvalidStartDate() throws TestFailedException {

        TestFunction.testStringInputsForException(IllegalArgumentException.class,
            (s) -> new SportsGameSubclass("Bobby Dodd Stadium", "00:00", s, 1, 1, 1));

    }

    @TestCase(name = "Constructor: Negative score1")
    @Tip(description = "What is a 'valid' score1? What should happen when an invalid input is passed in?")
    public void constructorInvalidScore1() throws TestFailedException {

        TestFunction.testForException(IllegalArgumentException.class,
            () -> new SportsGameSubclass("Bobby Dodd Stadium", "00:00", "01-01-2000", -1, 1, 1));

    }

    @TestCase(name = "Constructor: Negative score2")
    @Tip(description = "What is a 'valid' score2? What should happen when an invalid input is passed in?")
    public void constructorInvalidScore2() throws TestFailedException {

        TestFunction.testForException(IllegalArgumentException.class,
            () -> new SportsGameSubclass("Bobby Dodd Stadium", "00:00", "01-01-2000", 1, -1, 1));

    }

    @TestCase(name = "Constructor: Negative seatsLeft")
    @Tip(description = "What is a 'valid' value for seatsLeft? What should happen when an invalid input is passed in?")
    public void constructorInvalidSeatsLeft() throws TestFailedException {

        TestFunction.testForException(IllegalArgumentException.class,
            () -> new SportsGameSubclass("Bobby Dodd Stadium", "00:00", "01-01-2000", 1, 1, -1));

    }

    @TestCase(name = "Constructor: Zero score1")
    @Tip(description = "Is 0 a valid input to the constructor?")
    public void constructorZeroScore1() throws TestFailedException {

        SportsGame game = new SportsGameSubclass("Bobby Dodd Stadium", "00:00", "01-01-2000", 0, 1, 1);
        TestFunction.assertEqual(game.toString(), "Bobby Dodd Stadium,00:00,01-01-2000,0,1,1");

    }

    @TestCase(name = "Constructor: Zero score2")
    @Tip(description = "Is 0 a valid input to the constructor?")
    public void constructorZeroScore2() throws TestFailedException {
        SportsGame game = new SportsGameSubclass("Bobby Dodd Stadium", "00:00", "01-01-2000", 1, 0, 1);
        TestFunction.assertEqual(game.toString(), "Bobby Dodd Stadium,00:00,01-01-2000,1,0,1");

    }

    @TestCase(name = "Constructor: Zero seatsLeft")
    @Tip(description = "Is 0 a valid input to the constructor?")
    public void constructorZeroSeatsLeft() throws TestFailedException {
        SportsGame game = new SportsGameSubclass("Bobby Dodd Stadium", "00:00", "01-01-2000", 1, 1, 0);
        TestFunction.assertEqual(game.toString(), "Bobby Dodd Stadium,00:00,01-01-2000,1,1,0");

    }

    @TestCase(name = "Constructor: Leading/Trailing spaces around venue name")
    @Tip(description = "What method in the String class removes leading & trailing whitespace?")
    public void constructorSpacesVenue() throws TestFailedException {
        
        SportsGame game = new SportsGameSubclass(" Mercedes-Benz ", "17:00", "08-21-2023", 6, 70, 1);
        TestFunction.assertEqual(game.toString(), "Mercedes-Benz,17:00,08-21-2023,6,70,1");

    }

    @TestCase(name = "Constructor: Leading/Trailing newline characters around start time")
    @Tip(description = "What method in the String class removes leading & trailing whitespace?")
    public void constructorNewlinesVenue() throws TestFailedException {
        
        SportsGame game = new SportsGameSubclass("\nMercedes-Benz\n", "17:00", "08-21-2023", 6, 70, 1);
        TestFunction.assertEqual(game.toString(), "Mercedes-Benz,17:00,08-21-2023,6,70,1");

    }

    @TestCase(name = "Constructor: Leading/Trailing tab characters around start time")
    @Tip(description = "What method in the String class removes leading & trailing whitespace?")
    public void constructorTabsVenue() throws TestFailedException {
        
        SportsGame game = new SportsGameSubclass("\tMercedes-Benz\t", "17:00", "08-21-2023", 6, 70, 1);
        TestFunction.assertEqual(game.toString(), "Mercedes-Benz,17:00,08-21-2023,6,70,1");

    }

    @TestCase(name = "Constructor: Leading/Trailing spaces around start time")
    @Tip(description = "What method in the String class removes leading & trailing whitespace?")
    public void constructorSpacesTime() throws TestFailedException {
        
        SportsGame game = new SportsGameSubclass("Mercedes-Benz", " 17:00 ", "08-21-2023", 6, 70, 1);
        TestFunction.assertEqual(game.toString(), "Mercedes-Benz,17:00,08-21-2023,6,70,1");

    }

    @TestCase(name = "Constructor: Leading/Trailing newline characters around start time")
    @Tip(description = "What method in the String class removes leading & trailing whitespace?")
    public void constructorNewlinesTime() throws TestFailedException {
        
        SportsGame game = new SportsGameSubclass("Mercedes-Benz", "\n17:00\n", "08-21-2023", 6, 70, 1);
        TestFunction.assertEqual(game.toString(), "Mercedes-Benz,17:00,08-21-2023,6,70,1");

    }

    @TestCase(name = "Constructor: Leading/Trailing tab characters around start time")
    @Tip(description = "What method in the String class removes leading & trailing whitespace?")
    public void constructorTabsTime() throws TestFailedException {
        
        SportsGame game = new SportsGameSubclass("Mercedes-Benz", "\t17:00\t", "08-21-2023", 6, 70, 1);
        TestFunction.assertEqual(game.toString(), "Mercedes-Benz,17:00,08-21-2023,6,70,1");

    }

    @TestCase(name = "Constructor: Leading/Trailing spaces around start date")
    @Tip(description = "What method in the String class removes leading & trailing whitespace?")
    public void constructorSpacesDate() throws TestFailedException {
        
        SportsGame game = new SportsGameSubclass("Mercedes-Benz", "17:00", " 08-21-2023 ", 6, 70, 1);
        TestFunction.assertEqual(game.toString(), "Mercedes-Benz,17:00,08-21-2023,6,70,1");

    }

    @TestCase(name = "Constructor: Leading/Trailing newline characters around start date")
    @Tip(description = "What method in the String class removes leading & trailing whitespace?")
    public void constructorNewlinesDate() throws TestFailedException {
        
        SportsGame game = new SportsGameSubclass("Mercedes-Benz", "17:00", "\n08-21-2023\n", 6, 70, 1);
        TestFunction.assertEqual(game.toString(), "Mercedes-Benz,17:00,08-21-2023,6,70,1");

    }

    @TestCase(name = "Constructor: Leading/Trailing tab characters around start date")
    @Tip(description = "What method in the String class removes leading & trailing whitespace?")
    public void constructorTabsDate() throws TestFailedException {
        
        SportsGame game = new SportsGameSubclass("Mercedes-Benz", "17:00", "\t08-21-2023\t", 6, 70, 1);
        TestFunction.assertEqual(game.toString(), "Mercedes-Benz,17:00,08-21-2023,6,70,1");

    }

    @TestCase(name = "Constructor: Non-default message in IllegalArgumentException (venue)")
    @Tip(description = "Remember to provide a \"descriptive and specific\" message with ALL Exceptions thrown. What alternate constructor does IllegalArgumentException have that sets an error message?")
    public void constructorDescriptiveMessage1() throws TestFailedException {
        
        try {
            new SportsGameSubclass(null, "17:00", "08-21-2023", 6, 70, 1);
            throw new TestFailedException("Did not receive an IllegalArgumentException when giving an illegal argument");
        } catch (IllegalArgumentException iae) {
            if (iae.getMessage() == null) {
                throw new TestFailedException("Received error message \"" + iae.getMessage() + "\". Check Note 5 on Page 1 of the directions.");
            }
        }
        
    }

    @TestCase(name = "Constructor: Non-default message in IllegalArgumentException (start time)")
    @Tip(description = "Remember to provide a \"descriptive and specific\" message with ALL Exceptions thrown. What alternate constructor does IllegalArgumentException have that sets an error message?")
    public void constructorDescriptiveMessage2() throws TestFailedException {
        
        try {
            new SportsGameSubclass("Bobby Dodd", null, "08-21-2023", 6, 70, 1);
            throw new TestFailedException("Did not receive an IllegalArgumentException when giving an illegal argument");
        } catch (IllegalArgumentException iae) {
            if (iae.getMessage() == null) {
                throw new TestFailedException("Received error message \"" + iae.getMessage() + "\". Check Note 5 on Page 1 of the directions.");
            }
        }
        
    }

    @TestCase(name = "Constructor: Non-default message in IllegalArgumentException (start date)")
    @Tip(description = "Remember to provide a \"descriptive and specific\" message with ALL Exceptions thrown. What alternate constructor does IllegalArgumentException have that sets an error message?")
    public void constructorDescriptiveMessage3() throws TestFailedException {
        
        try {
            new SportsGameSubclass("Bobby Dodd", "17:00", null, 6, 70, 1);
            throw new TestFailedException("Did not receive an IllegalArgumentException when giving an illegal argument");
        } catch (IllegalArgumentException iae) {
            if (iae.getMessage() == null) {
                throw new TestFailedException("Received error message \"" + iae.getMessage() + "\". Check Note 5 on Page 1 of the directions.");
            }
        }
        
    }

    @TestCase(name = "Constructor: Non-default message in IllegalArgumentException (score1)")
    @Tip(description = "Remember to provide a \"descriptive and specific\" message with ALL Exceptions thrown. What alternate constructor does IllegalArgumentException have that sets an error message?")
    public void constructorDescriptiveMessage4() throws TestFailedException {
        
        try {
            new SportsGameSubclass("Bobby Dodd", "17:00", "01-01-2020", -1, 70, 1);
            throw new TestFailedException("Did not receive an IllegalArgumentException when giving an illegal argument");
        } catch (IllegalArgumentException iae) {
            if (iae.getMessage() == null) {
                throw new TestFailedException("Received error message \"" + iae.getMessage() + "\". Check Note 5 on Page 1 of the directions.");
            }
        }
        
    }

    @TestCase(name = "Constructor: Non-default message in IllegalArgumentException (score2)")
    @Tip(description = "Remember to provide a \"descriptive and specific\" message with ALL Exceptions thrown. What alternate constructor does IllegalArgumentException have that sets an error message?")
    public void constructorDescriptiveMessage5() throws TestFailedException {
        
        try {
            new SportsGameSubclass("Bobby Dodd", "17:00", "01-01-2020", 6, -1, 1);
            throw new TestFailedException("Did not receive an IllegalArgumentException when giving an illegal argument");
        } catch (IllegalArgumentException iae) {
            if (iae.getMessage() == null) {
                throw new TestFailedException("Received error message \"" + iae.getMessage() + "\". Check Note 5 on Page 1 of the directions.");
            }
        }
        
    }

    @TestCase(name = "Constructor: Non-default message in IllegalArgumentException (seatsLeft)")
    @Tip(description = "Remember to provide a \"descriptive and specific\" message with ALL Exceptions thrown. What alternate constructor does IllegalArgumentException have that sets an error message?")
    public void constructorDescriptiveMessage6() throws TestFailedException {
        
        try {
            new SportsGameSubclass("Bobby Dodd", "17:00", "01-01-2020", 6, 70, -1);
            throw new TestFailedException("Did not receive an IllegalArgumentException when giving an illegal argument");
        } catch (IllegalArgumentException iae) {
            if (iae.getMessage() == null) {
                throw new TestFailedException("Received error message \"" + iae.getMessage() + "\". Check Note 5 on Page 1 of the directions.");
            }
        }
        
    }

    @TestCase(name = "equals(): All values are equal")
    @Tip(description =  "What values must be equal for two SportsGames to be considered equal?")
    public void equalsEquals() throws TestFailedException {

        SportsGame game1 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1);
        SportsGame game2 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1);

        TestFunction.assertEqual(true, game1, game2);

    }

    @TestCase(name = "equals(): Venue is different")
    @Tip(description =  "What values must be equal for two SportsGames to be considered equal?")
    public void equalsDifferentVenue() throws TestFailedException {

        SportsGame game1 = new SportsGameSubclass("Mercedes-Bench", "17:00", "08-21-2023", 6, 70, 1);
        SportsGame game2 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1);

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Start time is different")
    @Tip(description =  "What values must be equal for two SportsGames to be considered equal?")
    public void equalsDifferentTime() throws TestFailedException {

        SportsGame game1 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1);
        SportsGame game2 = new SportsGameSubclass("Mercedes-Benz", "17:01", "08-21-2023", 6, 70, 1);

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Start date is different")
    @Tip(description =  "What values must be equal for two SportsGames to be considered equal?")
    public void equalsDifferentDate() throws TestFailedException {

        SportsGame game1 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1);
        SportsGame game2 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-1996", 6, 70, 1);

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Score1 is different")
    @Tip(description =  "What values must be equal for two SportsGames to be considered equal?")
    public void equalsDifferentScore1() throws TestFailedException {

        SportsGame game1 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1);
        SportsGame game2 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-1996", 7, 70, 1);

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Score2 is different")
    @Tip(description =  "What values must be equal for two SportsGames to be considered equal?")
    public void equalsDifferentScore2() throws TestFailedException {

        SportsGame game1 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1);
        SportsGame game2 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-1996", 6, 77, 1);

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): seatsLeft is different")
    @Tip(description =  "What values must be equal for two SportsGames to be considered equal?")
    public void equalsDifferentSeats() throws TestFailedException {

        SportsGame game1 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1);
        SportsGame game2 = new SportsGameSubclass("Mercedes-Benz", "17:00", "08-21-1996", 6, 70, 3);

        TestFunction.assertEqual(false, game1, game2);

    }

    /**
     * Subclass of SportsGame, ONLY for testing purposes.
     */
    public static class SportsGameSubclass extends SportsGame {

        public SportsGameSubclass(String venue, String startTime, String startDate, int score1, int score2,
                int seatsLeft) {
            super(venue, startTime, startDate, score1, score2, seatsLeft);
        }

    }

}

//AUTOGENERATED FROM ../src/TerminalOption.java

/**
 * Represents a potential option the terminal can accept as an input
 */
class TerminalOption {
    /**
     * The flag, denoted by '-<some sort of character>' the terminal will look for
     */
    private String flag;

    /**
     * The name of the flag
     */
    private String name;

    /**
     * An example of using the command, used in the help menu for the program
     */
    private String usage;

    /**
     * An internal boolean representing whether the test case has been successfully
     * added or not
     */
    private boolean received = false;

    /**
     * A list of all of the inputs received from the terminal. This is populated from the main parsing logic. 
     */
    private List<String> input;

    /**
     * Constructs a new TerminalOption given the following parameters
     * @param flag The flag of the option
     * @param name The name of the option, used in the help menu 
     * @param usage An example case of using the option, used in the help menu
     */
    public TerminalOption(String flag, String name, String usage) {
        this.flag = flag;
        this.name = name;
        this.usage = usage;

        this.input = new ArrayList<>();
    }

    /**
     * Retrieves the flag used for the TerminalOption
     * @return the flag
     */
    public String getFlag() {
        return flag;
    }

    /**
     * Adds a new received input to the TerminalOption
     * @param string The string to add to the input
     */
    public void addInput(String string) {
        this.input.add(string);
    }

    /**
     * Retrieves the list of inputs 
     * @return the inputs received of the TerminalOption
     */
    public List<String> getInput() {
        return input;
    }

    /**
     * Sets whether the TerminalOption has successfully received the flag or not
     * @param received true if the flag has been received
     */
    public void setReceived(boolean received) {
        this.received = received;
    }

    /**
     * Retrieves whether the TemrinalOption has been retrieved or not
     * @return true if the flag has been received
     */
    public boolean received() {
        return this.received;
    }

    /**
     * Retrieves the name of the terminal option
     * @return The name of the terminal option
     */
    public String getName() {
        return this.name;
    }

    /**
     * Retrieves the usage statement of the terminal option
     * @return An example usage statement of the terminal option
     */
    public String getUsage() {
        return this.usage;
    }

    public void process() {

    }
}

//AUTOGENERATED FROM ../src/AsciiColorCode.java
final class AsciiColorCode {

    public static final String RESET_COLOR = "\033[0m";

    public static final String BLACK_FOREGROUND = "\033[30m";
    public static final String BLACK_BACKGROUND = "\033[40m";

    public static final String RED_FOREGROUND = "\033[31m";
    public static final String RED_BACKGROUND = "\033[41m";

    public static final String GREEN_FOREGROUND = "\033[32m";
    public static final String GREEN_BACKGROUND = "\033[42m";

    public static final String YELLOW_FOREGROUND = "\033[33m";
    public static final String YELLOW_BACKGROUND = "\033[43m";

    public static final String BLUE_FOREGROUND = "\033[34m";
    public static final String BLUE_BACKGROUND = "\033[44m";

    public static final String MAGENTA_FOREGROUND = "\033[35m";
    public static final String MAGENTA_BACKGROUND = "\033[45m";

    public static final String CYAN_FOREGROUND = "\033[36m";
    public static final String CYAN_BACKGROUND = "\033[46m";

    public static final String WHITE_FOREGROUND = "\033[37m";
    public static final String WHITE_BACKGROUND = "\033[47m";

    public static final String BRIHGT_BLACK_FOREGROUND = "\033[90m";
    public static final String BRIGHT_BLACK_BACKGROUND = "\033[100m";

    public static final String BRIGHT_RED_FOREGROUND = "\033[91m";
    public static final String BRIGHT_RED_BACKGROUND = "\033[101m";

    public static final String BRIGHT_GREEN_FOREGROUND = "\033[92m";
    public static final String BRIGHT_GREEN_BACKGROUND = "\033[102m";

    public static final String BRIGHT_YELLOW_FOREGROUND = "\033[93m";
    public static final String BRIGHT_YELLOW_BACKGROUND = "\033[103m";

    public static final String BRIGHT_BLUE_FOREGROUND = "\033[94m";
    public static final String BRIGHT_BLUE_BACKGROUND = "\033[104m";

    public static final String BRIGHT_MAGENTA_FOREGROUND = "\033[95m";
    public static final String BRIGHT_MAGENTA_BACKGROUND = "\033[105m";

    public static final String BRIGHT_CYAN_FOREGROUND = "\033[96m";
    public static final String BRIGHT_CYAN_BACKGROUND = "\033[106m";

    public static final String BRIGHT_WHITE_FOREGROUND = "\033[97m";
    public static final String BRIGHT_WHITE_BACKGROUND = "\033[107m";
}

//AUTOGENERATED FROM ../src/SomeFileClass.java

class SomeFileClass {
    public static void scanData() throws FileNotFoundException {
        Scanner scanner = new Scanner(new File("test.txt"));

        while (scanner.hasNextLine()) {
            System.out.println(scanner.nextLine());
        }
    }
}

//AUTOGENERATED FROM ../src/Tuple.java
/**
 * A generic class used for holding two values that might be related
 */
class Tuple<X, Y> {
    /**
     * The first element
     */
    public final X first;

    /**
     * The second element
     */
    public final Y second;

    /**
     * Constructs a new Tuple.
     * @param first The first element
     * @param second The second element
     */
    public Tuple(X first, Y second) {
        this.first = first;
        this.second = second;
    }
}
//AUTOGENERATED FROM ../src/DeleteFileBefore.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
@interface DeleteFileBefore { }

//AUTOGENERATED FROM ../src/TestFailedException.java
/**
 * A custom exception used for detecting tests failed.
 */
class TestFailedException extends Exception {
    public TestFailedException() {
    }

    public TestFailedException(String message) {
        super(message);
    }
}

//AUTOGENERATED FROM ../src/TxtTestData.java
class TxtTestData {
    
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM retrieveGamesValidInputs.txt
    public static String retrieveGamesValidInputs = "FootballGame,Bobby Dodd,17:00,01-01-2020,6,70,3,Eminem\nFootballGame,Bobby Dodd,17:00,01-01-2020,6,70,4,Eminem\nBasketballGame,McCamish,17:00,01-01-2020,6,70,5,NCAA\nBasketballGame,McCamish,17:00,01-01-2020,6,70,6,NBA\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM retrieveGamesInvalidInputs.txt
    public static String retrieveGamesInvalidInputs = "FootballGame,Bobby Dodd,17:00,01-01-2020,6,70,3,Eminem\nFootballGame,Bobby Dodd,17:00,01-01-2020,6,70,4,Eminem\nSoccerGame,Levi's Stadium,19:00,01-01-2023,9,71,4,Messi\nBasketballGame,McCamish,17:00,01-01-2020,6,70,5,NCAA\nBasketballGame,McCamish,17:00,01-01-2020,6,70,6,NBA\n";
    @DeleteFileAfter
    @DeleteFileBefore
	//AUTOMATICALLY EXTRACTED FROM purchaseTicketsWritingToEmptyFile.txt
    public static String purchaseTicketsWritingToEmptyFile = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM purchaseTicketsAppend.txt
    public static String purchaseTicketsAppend = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM purchaseTicketsAppendOutput.txt
    public static String purchaseTicketsAppendOutput = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM purchaseTicketsZeroSeats.txt
    public static String purchaseTicketsZeroSeats = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM purchaseTicketsZeroSeatsOutput.txt
    public static String purchaseTicketsZeroSeatsOutput = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM purchaseTicketsInvalidGame.txt
    public static String purchaseTicketsInvalidGame = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nSoccerGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM findTicketsOneOccurrence.txt
    public static String findTicketsOneOccurrence = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM findTicketsSeveralOccurrences.txt
    public static String findTicketsSeveralOccurrences = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM findTicketsAdjacentOccurrences.txt
    public static String findTicketsAdjacentOccurrences = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM attendGameNoOccurrences.txt
    public static String attendGameNoOccurrences = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,17:00,03-01-2020,9,9,2,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM attendGameSeveralOccurrences.txt
    public static String attendGameSeveralOccurrences = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nBasketballGame,McCamish,0:00,01-01-2020,1,1,3,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM attendGameSeveralOccurrencesOutput.txt
    public static String attendGameSeveralOccurrencesOutput = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,0:00,01-01-2020,1,1,3,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM attendGameAdjacentOccurrences.txt
    public static String attendGameAdjacentOccurrences = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nFootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nBasketballGame,McCamish,0:00,01-01-2020,1,1,1,NCAA\nBasketballGame,McCamish,0:00,01-01-2020,1,1,3,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
    @DeleteFileAfter
    @BeforeTest
	//AUTOMATICALLY EXTRACTED FROM attendGameAdjacentOccurrencesOutput.txt
    public static String attendGameAdjacentOccurrencesOutput = "FootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\nFootballGame,Bobby Dodd,17:00,03-01-2020,9,9,2,Drake\nBasketballGame,McCamish,0:00,01-01-2020,1,1,3,NCAA\nFootballGame,Levi's Stadium,17:00,03-01-2020,9,9,2,Drake\n";
}
//AUTOGENERATED FROM ../src/InvalidTicketExceptionTests.java
class InvalidTicketExceptionTests {
    
    @TestCase(name = "Constructor: No arg constructor")
    @Tip(description = "What should the InvalidTicketException's message default to?")
    public void constructorNoArg() throws TestFailedException {
        
        InvalidTicketException ite = new InvalidTicketException();
        TestFunction.assertEqual(ite.getMessage(), "Invalid ticket");

    }

    @TestCase(name = "Constructor: One arg constructor")
    @Tip(description = "Make sure that you set the Exception's message. Does the superclass have a constructor you can chain?")
    public void constructorOneArg() throws TestFailedException {
        
        InvalidTicketException ite = new InvalidTicketException("Specific error message.");
        TestFunction.assertEqual(ite.getMessage(), "Specific error message.");

    }

    @TestCase(name = "Check for correct extension")
    @Tip(description = "What class should InvalidTicketException extend?")
    public void correctExtension() throws TestFailedException {
        
        Exception ite = new InvalidTicketException();
        TestFunction.assertEqual(ite instanceof RuntimeException, false);

    }

}

//AUTOGENERATED FROM ../src/HW06Driver.java

class Driver {
    public static void main(String[] args) {
        StringUtils.printHorizontalLine();

        System.out.println("\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255A\u2588\u2588\u2557 \u2588\u2588\u2554\u255D\u2588\u2588\u2554\u2550\u2550\u255D  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551 \u255A\u2588\u2588\u2588\u2588\u2554\u255D \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\n\u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u255D  \u255A\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u2550\u2550\u255D  \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D");

        TerminalOption helpOption = new TerminalOption("-h", "List all commands", "java <COMPILED_DRIVER_FILE> -h");
        TerminalOption runClassesOption = new TerminalOption("-c", "Run only specific test classes", "java <COMPILED_DRIVER_FILE> -c SomeClassWithTests AnotherClassWithTests");

        TerminalOption[] options = { helpOption, runClassesOption };

        TerminalOption currentOption = null;

        argloop: for (int i = 0; i < args.length; i++) {
            for (TerminalOption o : options) {
                if (o.getFlag().equals(args[i])) {
                    currentOption = o;
                    currentOption.setReceived(true);
                    continue argloop;
                }
            }

            if (currentOption != null) {
                currentOption.addInput(args[i]);
            }
        }

        // Reserved for later
        // for (TerminalOption o : options) {
        // o.process();
        // }

        List<String> filter = runClassesOption.getInput();

        if (helpOption.received()) {
            System.out.println("Commands:");
            for (TerminalOption o : options) {
                System.out.println(ColorUtils.formatForegroundColorString(AsciiColorCode.BRIGHT_YELLOW_FOREGROUND, o.getFlag()) + " " + o.getName());
                System.out.println("\tUsage: " + o.getUsage());
            }
        } else {
 // Add classes to test here
            TestManager.registerDataClasses(TxtTestData.class);
            TestManager.setTestFilter(filter);
            TestManager.runTestsOn(SportsGameTests.class, BasketballGameTests.class, FootballGameTests.class,
                    InvalidTicketExceptionTests.class, EqualsTests.class, TicketsTests.class);

        }

    }
}

//AUTOGENERATED FROM ../src/DeleteFileAfter.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
@interface DeleteFileAfter { }

//AUTOGENERATED FROM ../src/TestManager.java

class TestManager {
    protected volatile static AtomicInteger classTests = new AtomicInteger();
    protected volatile static AtomicInteger classTestsFailed = new AtomicInteger();

    private static List<String> filter;

    /**
     * A list of the currently registered classes to test
     */
    private static final List<Class<?>> testClazzes = new ArrayList<>();

    /**
     * A list of the currently registered data classes
     */
    private static final List<Class<?>> dataClazzes = new ArrayList<>();

    /**
     * When this method is called, the TestManager will run all tests in the given
     * classes.
     * 
     * @param classes The classes to test.
     */
    public static void runTestsOn(Class<?>... classes) {
        for (Class<?> currentClass : classes) {
            registerClass(currentClass);
        }

        executeTests();
    }

    public static void registerDataClasses(Class<?>... classes) {
        for (Class<?> clazz : classes) {
            registerDataClass(clazz);
        }
    }

    /**
     * Registers and marks test class to be scanned during test execution.
     * 
     * @param clazz The input class
     */
    public static void registerClass(Class<?> clazz) {
        if (filter.size() == 0 || filter.stream().anyMatch(s -> s.equals(clazz.getName()))) {
            testClazzes.add(clazz);
        }
    }

    public static void registerDataClass(Class<?> clazz) {
        dataClazzes.add(clazz);
    }

    /**
     * Executes all registered tests.
     */
    public static void executeTests() {
        injectData();

        ExecutorService executor = Executors.newFixedThreadPool(1);

        List<Runnable> runnables = new ArrayList<>();

        for (Class<?> testClass : testClazzes) {
            runnables.add(new TestContainer(testClass));
        }

        for (Runnable r : runnables) {
            Future<?> future = executor.submit(r);

            try {
                future.get(10, TimeUnit.SECONDS);
            } catch (InterruptedException e) {

            } catch (ExecutionException e) {
                e.getCause().printStackTrace();
            } catch (TimeoutException e) {
                future.cancel(true);

                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                        AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " FAILED: \u00BB ")
                        + " A test failed by exceeding the time limit. You likely have an infinite loop somewhere.");

                System.exit(-1);
            }

        }

        executor.shutdown();

        StringUtils.printHorizontalLine();

        StringUtils.printTextCentered("Test Results");
        System.out.println();
        StringUtils.printTextCentered(
                String.format("TOTAL TESTS PASSED: %d/%d", classTests.get() - classTestsFailed.get(),
                        classTests.get()));
        StringUtils.printHorizontalLine();

    }

    private static void injectData() {

        for (Class<?> dataClass : dataClazzes) {
            for (Field f : dataClass.getFields()) {
                InjectData injectAnnotation = f.getAnnotation(InjectData.class);

                if (injectAnnotation != null) {
                    Scanner scanner = null;

                    String output = "";

                    try {
                        scanner = new Scanner(new File(injectAnnotation.name()));

                        while (scanner.hasNextLine()) {
                            output += scanner.nextLine() + "\n";
                        }
                    } catch (FileNotFoundException e) {
                        System.out.println("COULDN'T FIND INJECT DATA FILE " + injectAnnotation.name());
                        System.exit(-1);
                    } finally {
                        if (scanner != null) {
                            scanner.close();
                        }
                    }

                    // Inject data into variable
                    f.setAccessible(true);

                    try {
                        // Set private static final
                        f.set(null, output);
                    } catch (Exception e) {
                        e.printStackTrace();
                        System.exit(-1);
                    }

                }
            }
            // getClass().getDeclaredField()
            // setAccessible

            // Field modifiers = getDeclaredField("modifiers")

            // modifiers.setInt(field, field.getModifiers() & ~Modifier.FINAL);

            // field.set(instance, newValue);
        }
    }

    /**
     * Prints a formatted test category section
     * 
     * @param category The name of the section (most likely the class name)
     */
    protected static void printTestCategory(String category) {
        StringUtils.printHorizontalLine();
        StringUtils.printTextCentered(category);
        System.out.println();
    }

    protected static void submitTest(int result) {
        // classTests++;
        // classTestsFailed += result;
    }

    public static void setTestFilter(List<String> filter) {
        TestManager.filter = filter;
    }
}

//AUTOGENERATED FROM ../src/FootballGameTests.java
class FootballGameTests {
    
    @TestCase(name = "Constructor: Valid inputs")
    @Tip(description = "What order should the constructor arguments be?")
    public void constructorValidInputs() throws TestFailedException {
        
        FootballGame game = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "Snoop Dog");
        TestFunction.assertEqual(game.toString(), "FootballGame,Mercedes-Benz,17:00,08-21-2023,6,70,1,Snoop Dog");

    }

    @TestCase(name = "Constructor: Invalid performer")
    @Tip(description = "What is a 'valid' performer? What should happen when an invalid input is passed in?")
    public void constructorInvalidPerformer() throws TestFailedException {

        TestFunction.testStringInputsForException(IllegalArgumentException.class,
            (s) -> new FootballGame(s, "00:00", "01-01-2000", 1, 1, 1, s));

    }

    @TestCase(name = "Constructor: Performer has leading/trailing whitespace")
    @Tip(description = "What method does the String class have to remove leading/trailing whitespace?")
    public void constructorPerformerSpaces() throws TestFailedException {

        FootballGame game = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, " \n\tEminem \n\t");
        TestFunction.assertEqual(game.toString(), "FootballGame,Mercedes-Benz,17:00,08-21-2023,6,70,1,Eminem");

    }

    @TestCase(name = "Constructor: Non-default message in IllegalArgumentException (performer)")
    @Tip(description = "Remember to provide a \"descriptive and specific\" message with ALL Exceptions thrown. What alternate constructor does IllegalArgumentException have that sets an error message?")
    public void constructorDescriptiveMessage6() throws TestFailedException {
        
        try {
            new FootballGame("Bobby Dodd", "17:00", "01-01-2020", 6, 70, 1, "   ");
            throw new TestFailedException("Did not receive an IllegalArgumentException when giving an illegal value for performer");
        } catch (IllegalArgumentException iae) {
            if (iae.getMessage() == null) {
                throw new TestFailedException("Received error message \"" + iae.getMessage() + "\". Check Note 5 on Page 1 of the directions.");
            }
        }
        
    }

    @TestCase(name = "equals(): All values are equal")
    @Tip(description =  "What values must be equal for two SportsGames to be considered equal?")
    public void equalsEquals() throws TestFailedException {

        FootballGame game1 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "Maroon 5");
        FootballGame game2 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "Maroon 5");

        TestFunction.assertEqual(true, game1, game2);

    }

    @TestCase(name = "equals(): Different venue")
    @Tip(description =  "What values must be equal for two FootballGames to be considered equal?")
    public void equalsVenue() throws TestFailedException {

        FootballGame game1 = new FootballGame("Mercedes-Bench", "17:00", "08-21-2023", 6, 70, 1, "Maroon 5");
        FootballGame game2 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "Maroon 5");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different start time")
    @Tip(description =  "What values must be equal for two FootballGames to be considered equal?")
    public void equalsTime() throws TestFailedException {

        FootballGame game1 = new FootballGame("Mercedes-Benz", "17:01", "08-21-2023", 6, 70, 1, "Maroon 5");
        FootballGame game2 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "Maroon 5");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different start date")
    @Tip(description =  "What values must be equal for two FootballGames to be considered equal?")
    public void equalsDate() throws TestFailedException {

        FootballGame game1 = new FootballGame("Mercedes-Benz", "17:00", "08-21-1938", 6, 70, 1, "J-Lo");
        FootballGame game2 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "J-Lo");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different score1")
    @Tip(description =  "What values must be equal for two FootballGames to be considered equal?")
    public void equalsScore1() throws TestFailedException {

        FootballGame game1 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 9, 70, 1, "Shakira");
        FootballGame game2 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "Shakira");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different score2")
    @Tip(description =  "What values must be equal for two FootballGames to be considered equal?")
    public void equalsScore2() throws TestFailedException {

        FootballGame game1 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 56, 1, "Spongebob");
        FootballGame game2 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "Spongebob");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different seatsLeft")
    @Tip(description =  "What values must be equal for two FootballGames to be considered equal?")
    public void equalsSeats() throws TestFailedException {

        FootballGame game1 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 2, "Pentatonix");
        FootballGame game2 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "Pentatonix");

        TestFunction.assertEqual(false, game1, game2);

    }

    @TestCase(name = "equals(): Different league")
    @Tip(description =  "What values must be equal for two FootballGames to be considered equal?")
    public void equalsLeauge() throws TestFailedException {

        FootballGame game1 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 2, "Lyn Lapid");
        FootballGame game2 = new FootballGame("Mercedes-Benz", "17:00", "08-21-2023", 6, 70, 1, "Jacob Collier");

        TestFunction.assertEqual(false, game1, game2);

    }

}
