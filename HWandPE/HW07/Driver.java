
/*                  
                                                                   ▄▄                             
  ▄▄█▀▀▀█▄█▄█▀▀▀█▄█                           ▀███▀▀▀██▄           ██                             
▄██▀     ▀███    ▀█▄▄▄                    ▄▄▄   ██    ▀██▄                                        
██▀       ▀███▄   ▀███   ██▀▀█▄   ██▀▀█▄ ▀███   ██     ▀█████▄███▀███ ▀██▀   ▀██▀  ▄▄█▀██▀███▄███ 
██          ▀█████▄ ██  ███  ▀██ ███  ▀██  ██   ██      ██ ██▀ ▀▀  ██   ██   ▄█   ▄█▀   ██ ██▀ ▀▀ 
██▄       ▄     ▀██ ██       ▄██      ▄██  ██   ██     ▄██ ██      ██    ██ ▄█    ██▀▀▀▀▀▀ ██     
▀██▄     ▄▀█     ██ ██     ▀▀██▄    ▀▀██▄  ██   ██    ▄██▀ ██      ██     ███     ██▄    ▄ ██     
  ▀▀█████▀█▀█████▀▄████▄      ██       ██▄████▄████████▀ ▄████▄  ▄████▄    █       ▀█████▀████▄   
                       ███  ▄█▀ ███  ▄█▀                                                          
                        █████▀   █████▀                                                           

    Cheers,
    - Ryder Johnson
    - Justin Hwang
 */
import java.util.List;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.function.Consumer;

import HW08.AfterTest;
import HW08.AsciiColorCode;
import HW08.BeforeTest;
import HW08.ColorUtils;
import HW08.IOHijacker;
import HW08.InjectData;
import HW08.StringUtils;
import HW08.TerminalOption;
import HW08.TestCase;
import HW08.TestContainer;
import HW08.TestFailedException;
import HW08.TestFunction;
import HW08.TestManager;
import HW08.TestUtils;
import HW08.Tip;
import HW08.Tuple;

import java.io.File;
import java.io.FileNotFoundException;
import java.lang.reflect.Field;
import java.util.Scanner;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
import java.io.PrintStream;
import java.io.IOException;
import java.nio.file.FileSystemException;
import java.nio.file.Files;
import java.io.PrintWriter;
//AUTOGENERATED FROM ../src/RestaurantTests.java

class RestaurantTests {

    @TestCase(name = "mergeSortRolls: Valid inputs.")
    @Tip(description = "Does RecursionUtils have helper methods that you can use?")
    public void mergeSortRollsValidInputs() throws TestFailedException {

        SushiRoll[] rolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Jimothy", Color.BLUE),
            new SushiRoll("Loser", Color.GREEN),
            new SushiRoll("Kangaroo", Color.GREEN),
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Jimothy", Color.BLUE),
            new SushiRoll("Kangaroo", Color.GREEN),
            new SushiRoll("Loser", Color.GREEN),
        };

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.mergeSortRolls(rolls)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "mergeSortRolls: Odd number of inputs.")
    @Tip(description = "Check your bounds when you split your array!")
    public void mergeSortRollsOddNumberInputs() throws TestFailedException {

        SushiRoll[] rolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Minneapolis", Color.GREEN),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Jimothy", Color.BLUE),
            new SushiRoll("Loser", Color.GREEN),
            new SushiRoll("Kangaroo", Color.GREEN),
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Jimothy", Color.BLUE),
            new SushiRoll("Kangaroo", Color.GREEN),
            new SushiRoll("Loser", Color.GREEN),
            new SushiRoll("Minneapolis", Color.GREEN),
        };

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.mergeSortRolls(rolls)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "mergeSortRolls: One input")
    @Tip(description = "What should happen when only one SushiRoll is given?")
    public void mergeSortRollsOneInput() throws TestFailedException {

        SushiRoll[] rolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED)
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED)
        };

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.mergeSortRolls(rolls)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "mergeSortRolls: No inputs")
    @Tip(description = "What should happen when NO SushiRolls are given?")
    public void mergeSortRollsZeroInput() throws TestFailedException {

        SushiRoll[] rolls = new SushiRoll[] {
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {
        };

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.mergeSortRolls(rolls)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "mergeOrders: Many inputs")
    @Tip(description = "Make sure you're properly sorting all of the SushiRolls!")
    public void mergeOrdersManyInputs() throws TestFailedException {

        SushiRoll[][] orders = new SushiRoll[][] {
            {new SushiRoll("Apple", Color.RED), new SushiRoll("Banana", Color.RED), new SushiRoll("Door", Color.BLUE)},
            {new SushiRoll("Cantaloupe", Color.BLUE), new SushiRoll("Elephant", Color.GREEN), new SushiRoll("Help", Color.GREEN)},
            {new SushiRoll("Green", Color.RED), new SushiRoll("Indiana", Color.RED), new SushiRoll("Minneapolis", Color.GREEN)},
            {new SushiRoll("Fan", Color.BLUE), new SushiRoll("Jimothy", Color.BLUE), new SushiRoll("Loser", Color.GREEN)},
            {new SushiRoll("Kangaroo", Color.GREEN)}
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Jimothy", Color.BLUE),
            new SushiRoll("Kangaroo", Color.GREEN),
            new SushiRoll("Loser", Color.GREEN),
            new SushiRoll("Minneapolis", Color.GREEN)
        };

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.mergeOrders(orders)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "mergeOrders: Many inputs (test 2)")
    @Tip(description = "Make sure you're properly sorting all of the SushiRolls!")
    public void mergeOrdersManyInputs2() throws TestFailedException {

        SushiRoll[][] orders = new SushiRoll[][] {
            {new SushiRoll("Fan", Color.BLUE), new SushiRoll("Jimothy", Color.BLUE), new SushiRoll("Loser", Color.GREEN)},
            {new SushiRoll("Apple", Color.RED), new SushiRoll("Banana", Color.RED), new SushiRoll("Door", Color.BLUE)},
            {new SushiRoll("Green", Color.RED), new SushiRoll("Indiana", Color.RED), new SushiRoll("Minneapolis", Color.GREEN)},
            {new SushiRoll("Cantaloupe", Color.BLUE), new SushiRoll("Elephant", Color.GREEN), new SushiRoll("Help", Color.GREEN)},
            {new SushiRoll("Kangaroo", Color.GREEN)}
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Jimothy", Color.BLUE),
            new SushiRoll("Kangaroo", Color.GREEN),
            new SushiRoll("Loser", Color.GREEN),
            new SushiRoll("Minneapolis", Color.GREEN)
        };

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.mergeOrders(orders)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "mergeOrders: Many inputs (test 3)")
    @Tip(description = "Make sure you're properly sorting all of the SushiRolls!")
    public void mergeOrdersManyInputs3() throws TestFailedException {

        SushiRoll[][] orders = new SushiRoll[][] {
            {new SushiRoll("Green", Color.RED), new SushiRoll("Indiana", Color.RED), new SushiRoll("Minneapolis", Color.GREEN)},
            {new SushiRoll("Apple", Color.RED), new SushiRoll("Banana", Color.RED), new SushiRoll("Door", Color.BLUE)},
            {new SushiRoll("Kangaroo", Color.GREEN)},
            {new SushiRoll("Cantaloupe", Color.BLUE), new SushiRoll("Elephant", Color.GREEN), new SushiRoll("Help", Color.GREEN)},
            {new SushiRoll("Fan", Color.BLUE), new SushiRoll("Jimothy", Color.BLUE), new SushiRoll("Loser", Color.GREEN)},
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Jimothy", Color.BLUE),
            new SushiRoll("Kangaroo", Color.GREEN),
            new SushiRoll("Loser", Color.GREEN),
            new SushiRoll("Minneapolis", Color.GREEN)
        };

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.mergeOrders(orders)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "mergeOrders: No inputs")
    @Tip(description = "What should mergeOrders() return if there are no orders?")
    public void mergeOrdersNone() throws TestFailedException {

        SushiRoll[][] orders = new SushiRoll[][] {};

        SushiRoll[] sortedRolls = new SushiRoll[] {};

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.mergeOrders(orders)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "mergeOrders: Contains only empty orders")
    @Tip(description = "What should mergeOrders() return if there are no orders?")
    public void mergeOrdersEmpty() throws TestFailedException {

        SushiRoll[][] orders = new SushiRoll[][] {{},{},{}};

        SushiRoll[] sortedRolls = new SushiRoll[] {};

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.mergeOrders(orders)).trim(), StringUtils.arrayToString(sortedRolls).trim());

    }

    @TestCase(name = "platesOfColor: Red")
    @Tip(description = "Make sure that the output array has ONLY the correct color!")
    public void platesOfColorRed() throws TestFailedException {

        
        SushiRoll[] rolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Jimothy", Color.BLUE),
            new SushiRoll("Loser", Color.GREEN),
            new SushiRoll("Kangaroo", Color.GREEN),
            new SushiRoll("Minneapolis", Color.GREEN),
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Indiana", Color.RED),
        };

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.platesOfColor(rolls, Color.RED)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "platesOfColor: Blue")
    @Tip(description = "Make sure that the output array has ONLY the correct color!")
    public void platesOfColorBlue() throws TestFailedException {

        
        SushiRoll[] rolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Jimothy", Color.BLUE),
            new SushiRoll("Loser", Color.GREEN),
            new SushiRoll("Kangaroo", Color.GREEN),
            new SushiRoll("Minneapolis", Color.GREEN),
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Jimothy", Color.BLUE),
        };

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.platesOfColor(rolls, Color.BLUE)), StringUtils.arrayToString(sortedRolls));

    }


    @TestCase(name = "platesOfColor: Green")
    @Tip(description = "Make sure that the output array has ONLY the correct color!")
    public void platesOfColorGreen() throws TestFailedException {

        
        SushiRoll[] rolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Jimothy", Color.BLUE),
            new SushiRoll("Loser", Color.GREEN),
            new SushiRoll("Kangaroo", Color.GREEN),
            new SushiRoll("Minneapolis", Color.GREEN),
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {
            new SushiRoll("Elephant", Color.GREEN),
            new SushiRoll("Help", Color.GREEN),
            new SushiRoll("Kangaroo", Color.GREEN),
            new SushiRoll("Loser", Color.GREEN),
            new SushiRoll("Minneapolis", Color.GREEN),
        };

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.platesOfColor(rolls, Color.GREEN)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "platesOfColor: None have specified color")
    @Tip(description = "If no plates match the specified color, what should platesOfColor() return?")
    public void platesOfColorNone() throws TestFailedException {

        
        SushiRoll[] rolls = new SushiRoll[] {
            new SushiRoll("Apple", Color.RED),
            new SushiRoll("Banana", Color.RED),
            new SushiRoll("Door", Color.BLUE),
            new SushiRoll("Cantaloupe", Color.BLUE),
            new SushiRoll("Green", Color.RED),
            new SushiRoll("Indiana", Color.RED),
            new SushiRoll("Fan", Color.BLUE),
            new SushiRoll("Jimothy", Color.BLUE),
        };

        SushiRoll[] sortedRolls = new SushiRoll[] {};

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.platesOfColor(rolls, Color.GREEN)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "platesOfColor: Empty list of SushiRoll")
    @Tip(description = "Although you may assume the given array is not null or contain null elements, you may not assume that it is not empty. Make sure to handle this case!")
    public void platesOfColorEmpty() throws TestFailedException {

        
        SushiRoll[] rolls = new SushiRoll[] {};

        SushiRoll[] sortedRolls = new SushiRoll[] {};

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.platesOfColor(rolls, Color.GREEN)), StringUtils.arrayToString(sortedRolls));

    }

    @TestCase(name = "mergeSortRolls: duplicates")
    @Tip(description = "The dupicate elements in the original array should be in the same order in the sorted array. This is called a stable attribute of a sort")
    public void mergeSortDuplicates() throws TestFailedException {
        //stability is not specified in the HW pdf but if you implement mergeSort right, it should be stable
        SushiRoll[] orders = new SushiRoll[] {
                new SushiRoll("Zebra", Color.RED),
                new SushiRoll("Cantaloupe", Color.BLUE),
                new SushiRoll("Cantaloupe", Color.RED),
                new SushiRoll("Banana", Color.BLUE),
                new SushiRoll("Cantaloupe", Color.GREEN),
                new SushiRoll("Fan", Color.BLUE),};

        SushiRoll[] sortedRolls = new SushiRoll[] {
                new SushiRoll("Banana", Color.BLUE),
                new SushiRoll("Cantaloupe", Color.BLUE),
                new SushiRoll("Cantaloupe", Color.RED),
                new SushiRoll("Cantaloupe", Color.GREEN),
                new SushiRoll("Fan", Color.BLUE),
                new SushiRoll("Zebra", Color.RED),};

        TestFunction.assertEqual(StringUtils.arrayToString(Restaurant.mergeSortRolls(orders)), StringUtils.arrayToString(sortedRolls));

    }



    @TestCase(name = "totalPrice: Generic Test 1")
    @Tip(description = "Check Color.java for each color's price value!")
    public void totalPriceGeneric() throws TestFailedException {


        SushiRoll[] rolls = new SushiRoll[] {
                new SushiRoll("Apple", Color.RED),
                new SushiRoll("Banana", Color.RED),
                new SushiRoll("Door", Color.BLUE),
                new SushiRoll("Cantaloupe", Color.BLUE),
                new SushiRoll("Elephant", Color.GREEN),
        };

        TestFunction.assertEqual(Restaurant.totalPrice(rolls), 15.0);

    }

    @TestCase(name = "totalPrice: One item (on RED plate)")
    @Tip(description = "Is your price for RED correct?")
    public void totalPriceRed() throws TestFailedException {


        SushiRoll[] rolls = new SushiRoll[] {
                new SushiRoll("Red", Color.RED)
        };

        TestFunction.assertEqual(Restaurant.totalPrice(rolls), 2.5);

    }

    @TestCase(name = "totalPrice: One item (on GREEN plate)")
    @Tip(description = "Is your price for GREEN correct?")
    public void totalPriceGreen() throws TestFailedException {


        SushiRoll[] rolls = new SushiRoll[] {
                new SushiRoll("Green", Color.GREEN)
        };

        TestFunction.assertEqual(Restaurant.totalPrice(rolls), 3.0);

    }

    @TestCase(name = "totalPrice: One item (on BLUE plate)")
    @Tip(description = "Is your price for BLUE correct?")
    public void totalPriceBlue() throws TestFailedException {


        SushiRoll[] rolls = new SushiRoll[] {
                new SushiRoll("BLUE", Color.BLUE)
        };

        TestFunction.assertEqual(Restaurant.totalPrice(rolls), 3.5);

    }

    @TestCase(name = "totalPrice: Empty SushiRoll[]")
    @Tip(description = "How much do 0 SushiRolls cost?")
    public void totalPriceEmpty() throws TestFailedException {
        SushiRoll[] rolls = new SushiRoll[] {};
        TestFunction.assertEqual(Restaurant.totalPrice(rolls), 0.0);

    }

    @TestCase(name = "totalPrice: Test single element")
    @Tip(description = "How should your recursive function work when there is only one element?")
    public void totalPriceSingle() throws TestFailedException {
        SushiRoll[] rolls = new SushiRoll[] {new SushiRoll("Meh", Color.RED)};
        TestFunction.assertEqual(Restaurant.totalPrice(rolls), 2.5);
    }

    @TestCase(name = "flip: Even number of inputs (6)")
    @Tip(description = "Make sure that all six inputs are reversed!")
    public void flipGeneric() throws TestFailedException {


        SushiRoll[] rolls = new SushiRoll[] {
                new SushiRoll("Avocado", Color.RED),
                new SushiRoll("Banana", Color.RED),
                new SushiRoll("Dragon", Color.BLUE),
                new SushiRoll("Maki", Color.BLUE),
                new SushiRoll("Tobiko", Color.GREEN),
                new SushiRoll("Unagi", Color.GREEN),
        };

        SushiRoll[] flipped = new SushiRoll[] {
                new SushiRoll("Unagi", Color.GREEN),
                new SushiRoll("Tobiko", Color.GREEN),
                new SushiRoll("Maki", Color.BLUE),
                new SushiRoll("Dragon", Color.BLUE),
                new SushiRoll("Banana", Color.RED),
                new SushiRoll("Avocado", Color.RED),
        };

        Restaurant.flip(rolls);

        TestFunction.assertEqual(StringUtils.arrayToString(rolls), StringUtils.arrayToString(flipped));
    }

    @TestCase(name = "flip: Odd number of inputs (7)")
    @Tip(description = "Make sure that all six inputs are reversed!")
    public void flipOdd() throws TestFailedException {


        SushiRoll[] rolls = new SushiRoll[] {
                new SushiRoll("Avocado", Color.RED),
                new SushiRoll("Banana", Color.RED),
                new SushiRoll("Dragon", Color.BLUE),
                new SushiRoll("Hokigai", Color.BLUE),
                new SushiRoll("Maki", Color.BLUE),
                new SushiRoll("Tobiko", Color.GREEN),
                new SushiRoll("Unagi", Color.GREEN),
        };

        SushiRoll[] flipped = new SushiRoll[] {
                new SushiRoll("Unagi", Color.GREEN),
                new SushiRoll("Tobiko", Color.GREEN),
                new SushiRoll("Maki", Color.BLUE),
                new SushiRoll("Hokigai", Color.BLUE),
                new SushiRoll("Dragon", Color.BLUE),
                new SushiRoll("Banana", Color.RED),
                new SushiRoll("Avocado", Color.RED),
        };

        Restaurant.flip(rolls);

        TestFunction.assertEqual(StringUtils.arrayToString(rolls), StringUtils.arrayToString(flipped));
    }

    @TestCase(name = "flip: Empty List")
    @Tip(description = "What should flip() do when given an empty array?")
    public void flipEmpty() throws TestFailedException {


        SushiRoll[] rolls = new SushiRoll[] {};

        SushiRoll[] flipped = new SushiRoll[] {};

        Restaurant.flip(rolls);

        TestFunction.assertEqual(StringUtils.arrayToString(rolls), StringUtils.arrayToString(flipped));

    }

    @TestCase(name = "flip: 1 Element List")
    @Tip(description = "Should be the same as the original")
    public void flipTwo() throws TestFailedException {


        SushiRoll[] rolls = new SushiRoll[] {new SushiRoll("Maki", Color.BLUE)
        };

        SushiRoll[] flipped = new SushiRoll[] {new SushiRoll("Maki", Color.BLUE),
        };

        Restaurant.flip(rolls);

        TestFunction.assertEqual(StringUtils.arrayToString(rolls), StringUtils.arrayToString(flipped));

    }
    

}

//AUTOGENERATED FROM ../src/HW07Driver.java


class Driver {
    public static void main(String[] args) {
        StringUtils.printHorizontalLine();

        System.out.println("\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255A\u2588\u2588\u2557 \u2588\u2588\u2554\u255D\u2588\u2588\u2554\u2550\u2550\u255D  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551 \u255A\u2588\u2588\u2588\u2588\u2554\u255D \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\n\u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u255D  \u255A\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u2550\u2550\u255D  \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D");

        TerminalOption helpOption = new TerminalOption("-h", "List all commands", "java <COMPILED_DRIVER_FILE> -h");
        TerminalOption runClassesOption = new TerminalOption("-c", "Run only specific test classes", "java <COMPILED_DRIVER_FILE> -c SomeClassWithTests AnotherClassWithTests");

        TerminalOption[] options = { helpOption, runClassesOption };

        TerminalOption currentOption = null;

        argloop: for (int i = 0; i < args.length; i++) {
            for (TerminalOption o : options) {
                if (o.getFlag().equals(args[i])) {
                    currentOption = o;
                    currentOption.setReceived(true);
                    continue argloop;
                }
            }

            if (currentOption != null) {
                currentOption.addInput(args[i]);
            }
        }

        List<String> filter = runClassesOption.getInput();

        if (helpOption.received()) {
            System.out.println("Commands:");
            for (TerminalOption o : options) {
                System.out.println(ColorUtils.formatForegroundColorString(AsciiColorCode.BRIGHT_YELLOW_FOREGROUND, o.getFlag()) + " " + o.getName());
                System.out.println("\tUsage: " + o.getUsage());
            }
        } else {

            TestManager.setTestFilter(filter);
            TestManager.runTestsOn(RestaurantTests.class);

        }

    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/InjectData.java


@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
@interface InjectData {
    /**
     * The name of the file data is injected from
     * 
     * @return The name of the TestCase
     */
    public String name();
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/BeforeTest.java


@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.FIELD })
@interface BeforeTest { }

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/Tip.java


@Retention(RetentionPolicy.RUNTIME)
@interface Tip {
    /**
     * Used to display a helpful tip when the user fails a test.
     * 
     * @return The main tip body message
     */
    public String description() default "";
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/DataClass.java

@interface DataClass { }

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/TestCase.java


@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
@interface TestCase {
    /**
     * The name of the TestCase, used for describing what a test might be doing
     * 
     * @return The name of the TestCase
     */
    public String name() default "UNNAMED_TEST";
}
//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/AfterTest.java


@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
@interface AfterTest { }

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/DeleteFileBefore.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
@interface DeleteFileBefore { }

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/DeleteFileAfter.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
@interface DeleteFileAfter { }

//AUTOGENERATED FROM ../src/com/cs1331/drivers/exception/TestFailedException.java
/**
 * A custom exception used for detecting tests failed.
 */
class TestFailedException extends Exception {
    public TestFailedException() {
    }

    public TestFailedException(String message) {
        super(message);
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/testing/TestContainer.java




/**
 * Represents a Runnable that can be thrown into a ThreadPoolExecutor. The
 * TestContainer will latch onto a Class<?> and attempt to run any methods
 * labeled as test functions, e.g. @TestCase or @BeforeTest
 */
class TestContainer implements Runnable {
    /**
     * The class belonging to the TestContainer
     */
    private Class<?> clazz;

    /**
     * As the methods are non-static, there must be an instance all share when
     * executing the methods. At the start of the test a single instance is
     * initialized for all tests to use.
     */
    private Object instance = null;

    /**
     * Initializes a new TestContainer. A TestContainer is used to prevent certain
     * edge cases such as infinite loops.
     * 
     * If an infinite loop occurs, the test will timeout and notify the user
     * accordingly.
     * 
     * @param clazz The class containing the tests
     */
    public TestContainer(Class<?> clazz) {
        this.clazz = clazz;
    }

    /**
     * Executes a method belonging to this instance.
     * This is used when cycling over the methods marked with @BeforeTest
     * and @AfterTest, as both require the same invocation logic.
     * 
     * @param method The method to execute
     */
    private void executeFunction(Method method) {
        try {
            method.invoke(instance);
        } catch (Exception e) {
            System.out.println(ColorUtils.formatColorString(AsciiColorCode.WHITE_BACKGROUND,
                    AsciiColorCode.RED_FOREGROUND,
                    "\tThe executed code caused the following exception."));

            e.getCause().printStackTrace();
        }
    }

    /**
     * Attempts to execute a TestCase found within the TestContainer.
     * 
     * @param tuple A Tuple<Method, TestCase> containing the method to run, and the
     *              TestCase associated with it. These are wrapped into a Tuple to
     *              avoid having to call getAnnotation twice.
     * @return true if the test case was successful
     */
    private boolean executeTestCase(Tuple<Method, TestCase> tuple) {
        Method m = tuple.first;
        TestCase testCase = tuple.second;
        Tip tip = m.getAnnotation(Tip.class);

        try {

            m.invoke(instance);

            System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_GREEN_BACKGROUND,
                    AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " PASSED \u00BB ") + " "
                    + testCase.name());

            TestManager.submitTest(0);
        } catch (InvocationTargetException e) {
            System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                    AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " FAILED \u00BB ") + " "
                    + testCase.name());

            if (e.getCause() instanceof TestFailedException) {
                TestFailedException tfe = (TestFailedException) e.getCause();

                System.out.println(StringUtils.formatIndented(tfe.getMessage()));

                } else if (e.getCause() instanceof StackOverflowError) {
                e.printStackTrace();
                
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.WHITE_BACKGROUND,
                        AsciiColorCode.RED_FOREGROUND,
                        "\tYour code resulted in a StackOverflowError. This is almost certainly because of a recursive method stuck in an infinite loop."));

            } else {
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.WHITE_BACKGROUND,
                        AsciiColorCode.RED_FOREGROUND,
                        "\tThe executed code caused the following exception. This is NOT the fault of the driver."));

                e.getCause().printStackTrace();
            }

            if (tip != null)
                    System.out.print(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_WHITE_BACKGROUND,
                            AsciiColorCode.BLACK_FOREGROUND, StringUtils.formatIndented(String.format("%s\n", "HINT: " + tip.description()))));
            

            return false;
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
        }

        return true;
    }

    @Override
    public void run() {
        try {
            TestManager.printTestCategory(clazz.getName());

            instance = clazz.getDeclaredConstructor().newInstance();

            int classTests = 0;
            int classTestsFailed = 0;

            // TODO: Likely move this to a more abstract system
            List<Tuple<Method, BeforeTest>> beforeTest = new ArrayList<>();
            List<Tuple<Method, AfterTest>> afterTest = new ArrayList<>();
            List<Tuple<Method, TestCase>> testMethods = new ArrayList<>();

            for (Method m : clazz.getMethods()) {
                TestCase testAnnotation = m.getAnnotation(TestCase.class);
                BeforeTest beforeTestAnnotation = m.getAnnotation(BeforeTest.class);
                AfterTest afterTestAnnotation = m.getAnnotation(AfterTest.class);

                if (testAnnotation != null) {
                    testMethods.add(new Tuple<Method, TestCase>(m, testAnnotation));
                } else if (beforeTestAnnotation != null) {
                    beforeTest.add(new Tuple<Method, BeforeTest>(m, beforeTestAnnotation));
                } else if (afterTestAnnotation != null) {
                    afterTest.add(new Tuple<Method, AfterTest>(m, afterTestAnnotation));
                }
            }

            for (Tuple<Method, BeforeTest> tuple : beforeTest) {
                executeFunction(tuple.first);
            }

            for (Tuple<Method, TestCase> tuple : testMethods) {
                boolean result = executeTestCase(tuple);

                classTests++;

                if (!result)
                    classTestsFailed++;
            }

            for (Tuple<Method, AfterTest> tuple : afterTest) {
                executeFunction(tuple.first);
            }

            TestManager.classTests.set(TestManager.classTests.get() + classTests);
            TestManager.classTestsFailed.set(TestManager.classTestsFailed.get() + classTestsFailed);

            System.out.println();
            StringUtils.printTextCentered(
                    String.format("TESTS PASSED: %d/%d", classTests - classTestsFailed, classTests));

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
//AUTOGENERATED FROM ../src/com/cs1331/drivers/testing/TestFunction.java


class TestFunction {
    /**
     * Detects if the given Strings do not have the same content (case-sensitive)
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(String actual, String expected) throws TestFailedException {
        boolean failed = false;

        if (actual == null) {
            if (expected != null) {
                throw new TestFailedException("Test failed! Received null, but expected \"" + expected + "\"");
            }
        } else if (expected == null) {
            throw new TestFailedException("Test failed! Received \"" + actual + "\", but expected null");
        } else {

            if (!actual.replaceAll("\n", System.lineSeparator()).equals(expected.replaceAll("\n", System.lineSeparator()))) {
                failed = true;
            }
        }

        if (failed) {
            
            
            String expectedString = "\"" + expected + "\"";
            String coloredActual = StringUtils.getColorCodedDifference("\"" + actual + "\"", expectedString);

            
            if (coloredActual.trim().contains("\n")) {
                coloredActual = "\n" + coloredActual + "\n";
            }
            if (expected.trim().contains("\n")) {
                expectedString = "\n\"" + expected + "\"\n";
            }

            throw new TestFailedException(
                    "Strings different! Received " + coloredActual + " but expected " + expectedString);
        }
    }

    public static void assertEqual(List<String> actual, List<String> expected) throws TestFailedException {
        boolean failed = false;

        if (actual == null || expected == null || actual.size() != expected.size()) {
            failed = actual == expected;
        } else {
            for (int i = 0; i < expected.size(); i++) {
                if (expected.get(i) == null) {
                    failed = actual.get(i) != null;

                } else {
                    failed = !actual.get(i).equals(expected.get(i));

                }
                if (failed) break;
            }
        }

        if (failed) {
            throw new TestFailedException(
                    "List Different! Received \"" + actual + "\", expected \"" + expected + "\"");
        }
    }

    /**
     * Detects if the given integers are not equal.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(int actual, int expected) throws TestFailedException {
        boolean failed = (actual != expected);
        if (failed) {
            throw new TestFailedException("Integer value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given doubles are not within 1.0e-6 of one another.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(double actual, double expected) throws TestFailedException {
        final double ALLOWABLE_ERROR = 0.000001;

        boolean failed = (Math.abs(actual - expected) > ALLOWABLE_ERROR);

        if (failed) {
            throw new TestFailedException("Double value difference: \n\tReceived " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given booleans do not have equal values.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(boolean actual, boolean expected) throws TestFailedException {
        boolean failed = (actual != expected);

        if (failed) {
            throw new TestFailedException("Boolean value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given objects are equal by their .equals() methods. By default, this method will also test
     * for symmetry.
     *
     * @param expected Whether or not these two objects should be equal by their .equals() methods
     * @param obj1 The first object to compare.
     * @param obj2 The second object to compare.
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(boolean expected, Object obj1, Object obj2) throws TestFailedException {
        boolean actual = obj1.equals(obj2);
        if (actual != expected) {
            throw new TestFailedException("Boolean value difference with .equals() method. When comparing\n\"" + obj1.toString() + "\" with \"" + obj2.toString() + "\", Received " + actual + ", expected " + expected);
        }

        if (actual != obj2.equals(obj1)) {
            throw new TestFailedException("Asymmetry detected! When comparing \"" + obj1.toString() + "\" with \"" + obj2.toString() + "\", Received " + actual + ". But when calling .equals() the other way, received " + !actual);
        }
    }

    /**
     * Tests the given code for a particular type of Exception.
     * @param exceptionType The class of the expected Exception.
     * @param codeThatThrowsException Runnable code that is intended to throw an exceptino of type exceptionType. Must NOT throw a TestFailedException
     * @throws TestFailedException
     */
    public static void testForException(Class<? extends Exception> exceptionType, Runnable codeThatThrowsException) throws TestFailedException {
        try {
            codeThatThrowsException.run();
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }
    }

    /**
     * Tester for String inputs. Takes in a String -> String function, and compares the output with the desired output.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @param inputs The StringInput values to test.
     * @throws TestFailedException
     */
    public static void testStringInputs(String actual, TestUtils.StringFunction codeToRun, TestUtils.StringInput[] inputs) throws TestFailedException {

        for (TestUtils.StringInput stringInput : inputs) {
            try {
                assertEqual(actual, codeToRun.run(stringInput.getStringValue()));
            } catch (TestFailedException tfe) {
                throw new TestFailedException("When inputted string is " + stringInput.toString() + ": " + tfe.getMessage());
            }
        }

    }

    /**
     * Convenience method that calls testStringInputs(String, StringFunction, StringInput[]) for ALL
     * values of the StringFunction enum.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @throws TestFailedException
     */
    public static void testStringInputs(String actual, TestUtils.StringFunction codeToRun) throws TestFailedException {
        testStringInputs(actual, codeToRun, TestUtils.StringInput.values());
    }

    /**
     * Tester for String inputs. Takes in a String -> String function, and compares the output with the desired output.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @param inputs The StringInput values to test.
     * @throws TestFailedException
     */
    public static void testStringInputsForException(Class<? extends Exception> exceptionType, Consumer<String> codeToRun, TestUtils.StringInput... inputs) throws TestFailedException {

        for (TestUtils.StringInput stringInput : inputs) {
            try {
                testForException(exceptionType, () -> codeToRun.accept(stringInput.getStringValue()));
            } catch (TestFailedException tfe) {
                throw new TestFailedException("When inputted string is " + stringInput.toString() + ": " + tfe.getMessage());
            }
        }

    }

    /**
     * Convenience method that calls testStringInputs(String, StringFunction, StringInput[]) for ALL
     * values of the StringFunction enum.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @throws TestFailedException
     */
    public static void testStringInputsForException(Class<? extends Exception> exceptionType, Consumer<String> codeToRun) throws TestFailedException {
        testStringInputsForException(exceptionType, codeToRun, TestUtils.StringInput.values());
    }

    /**
     * Prints an error message
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException If the test fails
     */
    public static void failTest(String errorMessage) throws TestFailedException {
        throw new TestFailedException("An error occurred: " + errorMessage);
    }

}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/testing/TestManager.java


class TestManager {
    protected volatile static AtomicInteger classTests = new AtomicInteger();
    protected volatile static AtomicInteger classTestsFailed = new AtomicInteger();

    private static List<String> filter;

    /**
     * A list of the currently registered classes to test
     */
    private static final List<Class<?>> testClazzes = new ArrayList<>();

    /**
     * A list of the currently registered data classes
     */
    private static final List<Class<?>> dataClazzes = new ArrayList<>();

    /**
     * When this method is called, the TestManager will run all tests in the given
     * classes.
     * 
     * @param classes The classes to test.
     */
    public static void runTestsOn(Class<?>... classes) {
        for (Class<?> currentClass : classes) {
            registerClass(currentClass);
        }

        executeTests();
    }

    public static void registerDataClasses(Class<?>... classes) {
        for (Class<?> clazz : classes) {
            registerDataClass(clazz);
        }
    }

    /**
     * Registers and marks test class to be scanned during test execution.
     * 
     * @param clazz The input class
     */
    public static void registerClass(Class<?> clazz) {
        if (filter.size() == 0 || filter.stream().anyMatch(s -> s.equals(clazz.getName()))) {
            testClazzes.add(clazz);
        }
    }

    public static void registerDataClass(Class<?> clazz) {
        dataClazzes.add(clazz);
    }

    /**
     * Executes all registered tests.
     */
    public static void executeTests() {
        injectData();

        ExecutorService executor = Executors.newFixedThreadPool(1);

        List<Runnable> runnables = new ArrayList<>();

        for (Class<?> testClass : testClazzes) {
            runnables.add(new TestContainer(testClass));
        }

        for (Runnable r : runnables) {
            Future<?> future = executor.submit(r);

            try {
                future.get(10, TimeUnit.SECONDS);
            } catch (InterruptedException ignored) {

            } catch (ExecutionException e) {
                e.getCause().printStackTrace();
            } catch (TimeoutException e) {
                future.cancel(true);

                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                        AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " FAILED \u00BB ")
                        + " A test failed by exceeding the time limit. You likely have an infinite loop somewhere.");

                System.exit(-1);
            }

        }

        executor.shutdown();

        StringUtils.printHorizontalLine();

        StringUtils.printTextCentered("Test Results");
        System.out.println();
        StringUtils.printTextCentered(
                String.format("TOTAL TESTS PASSED: %d/%d", classTests.get() - classTestsFailed.get(),
                        classTests.get()));
        StringUtils.printHorizontalLine();

    }

    private static void injectData() {

        for (Class<?> dataClass : dataClazzes) {
            for (Field f : dataClass.getFields()) {
                InjectData injectAnnotation = f.getAnnotation(InjectData.class);

                if (injectAnnotation != null) {
                    Scanner scanner = null;

                    StringBuilder output = new StringBuilder();

                    try {
                        scanner = new Scanner(new File(injectAnnotation.name()));

                        while (scanner.hasNextLine()) {
                            output.append(scanner.nextLine()).append("\n");
                        }
                    } catch (FileNotFoundException e) {
                        System.out.println("COULDN'T FIND INJECT DATA FILE " + injectAnnotation.name());
                        System.exit(-1);
                    } finally {
                        if (scanner != null) {
                            scanner.close();
                        }
                    }

                    // Inject data into variable
                    f.setAccessible(true);

                    try {
                        // Set private static final
                        f.set(null, output.toString());
                    } catch (Exception e) {
                        e.printStackTrace();
                        System.exit(-1);
                    }

                }
            }
            // getClass().getDeclaredField()
            // setAccessible

            // Field modifiers = getDeclaredField("modifiers")

            // modifiers.setInt(field, field.getModifiers() & ~Modifier.FINAL);

            // field.set(instance, newValue);
        }
    }

    /**
     * Prints a formatted test category section
     * 
     * @param category The name of the section (most likely the class name)
     */
    protected static void printTestCategory(String category) {
        StringUtils.printHorizontalLine();
        StringUtils.printTextCentered(category);
        System.out.println();
    }

    protected static void submitTest(int result) {
        // classTests++;
        // classTestsFailed += result;
    }

    public static void setTestFilter(List<String> filter) {
        TestManager.filter = filter;
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/io/IOHijacker.java

/**
 * A helper class used for redirecting System.out to check against
 */
class IOHijacker {
    private static IOHijacker INSTANCE;

    private String log = "";
    private PrintStream originalStream;
    private PrintStream redirectedStream;
    private boolean recording = false;

    private IOHijacker() {
        this.originalStream = System.out;
    }

    /**
     * Starts recording all System.out messages to the console and stores them in
     * IOHijacker.log.
     * 
     * Until stopRecording is called, no System.out messages will appear.
     */
    public void startRecording() {
        log = "";

        if (redirectedStream == null)
            redirectedStream = getRedirectedStream();

        System.setOut(redirectedStream);

        recording = true;
    }

    /**
     * Stops the current recording, resetting System.out to its default behavior.
     * 
     * @return A list of all messages sent during the recording
     */
    public String stopRecording() {
        recording = false;

        System.setOut(originalStream);

        return log;
    }

    /**
     * Retrieves the current log of messages in a recording
     * 
     * @return The current log of messages
     */
    public String getCurrentLog() {
        return log;
    }

    /**
     * Retrieves a custom PrintStream that redirects print to instead logMessage
     * 
     * @return The custom PrintStream
     */
    private PrintStream getRedirectedStream() {
        return new PrintStream(System.out, true) {
            @Override
            public void print(String s) {
                IOHijacker.appendMessage(s);
            }

            @Override
            public PrintStream printf(String message, Object... args) {
                IOHijacker.appendMessage(String.format(message, args));
                return this;
            }

            @Override
            public void println(String s) {
                IOHijacker.appendMessage(s + "\n");
            }

        };
    }

    /**
     * Returns the Singleton's instance, creating one if it doesn't exist.
     * 
     * @return The IOHijacker instance
     */
    public static IOHijacker getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new IOHijacker();
        }

        return INSTANCE;
    }

    /**
     * Appends a string message to the log ONLY if recording.
     * 
     * @param message The message to be recorded
     */
    private static void appendMessage(String message) {
        IOHijacker instance = getInstance();

        if (!instance.recording)
            return;

        instance.log += message.replaceAll("\r","");
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/terminal/TerminalOption.java

/**
 * Represents a potential option the terminal can accept as an input
 */
class TerminalOption {
    /**
     * The flag, denoted by '-<some sort of character>' the terminal will look for
     */
    private String flag;

    /**
     * The name of the flag
     */
    private String name;

    /**
     * An example of using the command, used in the help menu for the program
     */
    private String usage;

    /**
     * An internal boolean representing whether the test case has been successfully
     * added or not
     */
    private boolean received = false;

    /**
     * A list of all of the inputs received from the terminal. This is populated from the main parsing logic. 
     */
    private List<String> input;

    /**
     * Constructs a new TerminalOption given the following parameters
     * @param flag The flag of the option
     * @param name The name of the option, used in the help menu 
     * @param usage An example case of using the option, used in the help menu
     */
    public TerminalOption(String flag, String name, String usage) {
        this.flag = flag;
        this.name = name;
        this.usage = usage;

        this.input = new ArrayList<>();
    }

    /**
     * Retrieves the flag used for the TerminalOption
     * @return the flag
     */
    public String getFlag() {
        return flag;
    }

    /**
     * Adds a new received input to the TerminalOption
     * @param string The string to add to the input
     */
    public void addInput(String string) {
        this.input.add(string);
    }

    /**
     * Retrieves the list of inputs 
     * @return the inputs received of the TerminalOption
     */
    public List<String> getInput() {
        return input;
    }

    /**
     * Sets whether the TerminalOption has successfully received the flag or not
     * @param received true if the flag has been received
     */
    public void setReceived(boolean received) {
        this.received = received;
    }

    /**
     * Retrieves whether the TemrinalOption has been retrieved or not
     * @return true if the flag has been received
     */
    public boolean received() {
        return this.received;
    }

    /**
     * Retrieves the name of the terminal option
     * @return The name of the terminal option
     */
    public String getName() {
        return this.name;
    }

    /**
     * Retrieves the usage statement of the terminal option
     * @return An example usage statement of the terminal option
     */
    public String getUsage() {
        return this.usage;
    }

    public void process() {

    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/utils/TestUtils.java


class TestUtils {

    /**
     * Returns either 1, 0, or -1 depending on the sign of the input.
     * 
     * @param input
     * @return -1 if input < 0, 0 if input = 0, 1 if input > 0
     */
    public static int signOf(int input) {
        if (input == 0) {
            return input;
        } else {
            return Math.abs(input) / input;
        }
    }

    public static String combinePrintStatements(List<String> printedMessages) {
        if (printedMessages == null || printedMessages.size() == 0) {
            return "";
        }

        StringBuilder builder = new StringBuilder(printedMessages.get(0));
        for (int i = 1; i < printedMessages.size(); i++) {
            builder.append("\n");
            builder.append(printedMessages.get(i));
        }
        return builder.toString();
    }

    /**
     * Enum that contains "invalid" Strings.
     */
    enum StringInput {
        NULL(null),
        EMPTY(""),
        BLANK("   ");

        private final String stringValue;

        private StringInput(String stringValue) {
            this.stringValue = stringValue;
        }

        public String getStringValue() {
            return this.stringValue;
        }
    }

    /**
     * Interface to allow lambda function-like functionality with Strings
     */
    public interface StringFunction {
        String run(String str);
    }

    public static void deleteFile(String path) {
        File file = new File(path);

        try {
            Files.delete(file.toPath());
        } catch (FileSystemException e) {

            if (e.getMessage().contains("used by another process")) {
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_YELLOW_BACKGROUND,
                        AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " DELETE FILE ERROR: \u00BB ")
                        + " The program failed to delete " + file.getName() + ". Although this will not change the outcome of the tests, to solve this issue you must ensure ALL of your scanners have been properly closed, INCLUDING during an exception. This has only been recorded on Windows machines, but feel free to reach out if you encounter the issue!");

            }
        } catch (IOException ignored) {
        }
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/utils/StringUtils.java


class StringUtils {
    /**
     * The ASCII character to use for horizontal lines
     */
    public static final String HORIZONTAL_LINE_CHARACTER = "\u2500";

    /**
     * The amount of HORIZONTAL_LINE_CHARACTER elements to use in a line
     */
    public static final int HORIZONTAL_LINE_LENGTH = 48;

    /**
     * Prints a horizontal line to the terminal.
     */
    public static void printHorizontalLine() {
        System.out
                .println(String.format("%0" + HORIZONTAL_LINE_LENGTH + "d", 0).replace("0", HORIZONTAL_LINE_CHARACTER));
    }

    /**
     * Prints centered text to the terminal.
     * 
     * @param text The text to be centered
     */
    public static void printTextCentered(String text) {
        // HORIZONTAL_LINE_LENGTH is maximum width
        // if line is
        // xxxxxxxxxxxx
        // We can pad the start of the string with half of the horizontal:
        // xxxxxhelloxx
        // The problem is that this doesn't account for the length of the string.
        // We can add half of the string length as well to correct it:
        // xxxxhelloxxxx = CENTERED! (or at least as close as it can get)

        System.out.printf("%" + (HORIZONTAL_LINE_LENGTH / 2 + text.length() / 2) + "s%n", text);
    }

    /**
     * Util that a stack trace into a printable string.
     * 
     * @param e Exception to print the stacktrace of
     * @return
     */
    public static String stackTraceToString(Throwable e) {
        StackTraceElement[] stackTrace = e.getStackTrace();

        if (stackTrace.length == 0) {
            return "No stack trace.";
        }

        StringBuilder sb = new StringBuilder(stackTrace[0].toString());
        for (int i = 1; i < stackTrace.length; i++) {
            sb.append("\n    ");
            sb.append(stackTrace[i].toString());
        }
        return sb.toString();
    }

    public static String arrayListToString(ArrayList<? extends Object> inputs) {
        return arrayToString(inputs.toArray());
    }

    public static String arrayToString(Object[] inputs) {
        if (inputs.length == 0) {
            return "";
        }

        StringBuilder builder = new StringBuilder();

        for (Object input : inputs) {
            builder.append(input.toString()).append("\n");
        }

        return builder.toString();
    }

    public static String fileToString(String path) throws FileNotFoundException {
        Scanner scanner = new Scanner(new File(path));

        StringBuilder output = new StringBuilder();

        while (scanner.hasNextLine()) {
            String next = scanner.nextLine();

            output.append(next).append("\n");
        }

        scanner.close();

        return output.toString();
    }

    /**
     * Prints the given String to the file at the path.
     * THIS METHOD WILL OVERWRITE ANY DATA.
     * 
     * @param path Path to write at.
     * @param data Data to write to the file.
     * @throws FileNotFoundException
     */
    public static void stringToFile(String path, String data) throws FileNotFoundException {

        PrintWriter writer = new PrintWriter(path);

        writer.write(data);

        writer.close();

    }

    /**
     * Returns a modified version of 'actual', where the first character that
     * differs from
     * 'expected' is highlighted RED.
     * 
     * @param actual   The 'actual' String
     * @param expected The 'expected' String to compare against
     * @return
     */
    public static String getColorCodedDifference(String actual, String expected) {
        StringBuilder colored = new StringBuilder();
        for (int i = 0; i < actual.length(); i++) {
            char actualChar = actual.charAt(i);

            if (expected.length() <= i) {
                colored.append(actual.substring(i));
                break;
            }

            if (actualChar == expected.charAt(i)) {
                colored.append(actual.charAt(i));
            } else {
                colored.append(ColorUtils.formatColorString(AsciiColorCode.RED_BACKGROUND,
                        AsciiColorCode.WHITE_FOREGROUND, actualChar + ""));
                colored.append(actual.substring(i + 1));
                break;
            }

        }

        return colored.toString();

    }

    public static String formatIndented(String s) {
        String[] split = s.split("\n");

        StringBuilder output = new StringBuilder();

        for (int i = 0; i < split.length - 1; i++) {
            output.append(formatSingleLine(split[i]) + "\n");
        }

        output.append(formatSingleLine(split[split.length - 1]));

        return output.toString() + "\n";
    }

    private static String formatSingleLine(String s) {
        int currentLength = 0;

        StringBuilder builder = new StringBuilder("\t" + s);

        while (currentLength + HORIZONTAL_LINE_LENGTH < builder.length()
                && (currentLength = builder.lastIndexOf(" ", currentLength + HORIZONTAL_LINE_LENGTH)) != -1) {
            
            builder.replace(currentLength, currentLength + 1, "\n\t");
        }

        return builder.toString();
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/utils/ColorUtils.java

class ColorUtils {
    /**
     * Formats a string to have an ASCII background in terminal.
     * 
     * @param background The ASCII representation of the background color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatBackgroundColorString(String background, String s) {
        return background + s + AsciiColorCode.RESET_COLOR;
    }

    /**
     * Formats a string to have an ASCII foreground (text color) in terminal.
     * 
     * @param foreground The ASCII representation of the foreground color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatForegroundColorString(String foreground, String s) {
        return foreground + s + AsciiColorCode.RESET_COLOR;

    }

    /**
     * Formats a string to have both an ASCII foreground and background in terminal
     * 
     * @param background The ASCII representation of the background color, pulled
     *                   from AsciiColorCode
     * @param foreground The ASCII representation of the foreground color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatColorString(String background, String foreground, String s) {
        return foreground + background + s.replace("\n", AsciiColorCode.RESET_COLOR + "\n" + foreground + background) + AsciiColorCode.RESET_COLOR;
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/utils/AsciiColorCode.java

final class AsciiColorCode {

    public static final String RESET_COLOR = "\033[0m";

    public static final String BLACK_FOREGROUND = "\033[30m";
    public static final String BLACK_BACKGROUND = "\033[40m";

    public static final String RED_FOREGROUND = "\033[31m";
    public static final String RED_BACKGROUND = "\033[41m";

    public static final String GREEN_FOREGROUND = "\033[32m";
    public static final String GREEN_BACKGROUND = "\033[42m";

    public static final String YELLOW_FOREGROUND = "\033[33m";
    public static final String YELLOW_BACKGROUND = "\033[43m";

    public static final String BLUE_FOREGROUND = "\033[34m";
    public static final String BLUE_BACKGROUND = "\033[44m";

    public static final String MAGENTA_FOREGROUND = "\033[35m";
    public static final String MAGENTA_BACKGROUND = "\033[45m";

    public static final String CYAN_FOREGROUND = "\033[36m";
    public static final String CYAN_BACKGROUND = "\033[46m";

    public static final String WHITE_FOREGROUND = "\033[37m";
    public static final String WHITE_BACKGROUND = "\033[47m";

    public static final String BRIHGT_BLACK_FOREGROUND = "\033[90m";
    public static final String BRIGHT_BLACK_BACKGROUND = "\033[100m";

    public static final String BRIGHT_RED_FOREGROUND = "\033[91m";
    public static final String BRIGHT_RED_BACKGROUND = "\033[101m";

    public static final String BRIGHT_GREEN_FOREGROUND = "\033[92m";
    public static final String BRIGHT_GREEN_BACKGROUND = "\033[102m";

    public static final String BRIGHT_YELLOW_FOREGROUND = "\033[93m";
    public static final String BRIGHT_YELLOW_BACKGROUND = "\033[103m";

    public static final String BRIGHT_BLUE_FOREGROUND = "\033[94m";
    public static final String BRIGHT_BLUE_BACKGROUND = "\033[104m";

    public static final String BRIGHT_MAGENTA_FOREGROUND = "\033[95m";
    public static final String BRIGHT_MAGENTA_BACKGROUND = "\033[105m";

    public static final String BRIGHT_CYAN_FOREGROUND = "\033[96m";
    public static final String BRIGHT_CYAN_BACKGROUND = "\033[106m";

    public static final String BRIGHT_WHITE_FOREGROUND = "\033[97m";
    public static final String BRIGHT_WHITE_BACKGROUND = "\033[107m";
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/utils/Tuple.java
/**
 * A generic class used for holding two values that might be related
 */
class Tuple<X, Y> {
    /**
     * The first element
     */
    final X first;

    /**
     * The second element
     */
    final Y second;

    /**
     * Constructs a new Tuple.
     * @param first The first element
     * @param second The second element
     */
    public Tuple(X first, Y second) {
        this.first = first;
        this.second = second;
    }
}