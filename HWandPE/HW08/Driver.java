package HW08;

/*                  
                                                                   ▄▄                             
  ▄▄█▀▀▀█▄█▄█▀▀▀█▄█                           ▀███▀▀▀██▄           ██                             
▄██▀     ▀███    ▀█▄▄▄                    ▄▄▄   ██    ▀██▄                                        
██▀       ▀███▄   ▀███   ██▀▀█▄   ██▀▀█▄ ▀███   ██     ▀█████▄███▀███ ▀██▀   ▀██▀  ▄▄█▀██▀███▄███ 
██          ▀█████▄ ██  ███  ▀██ ███  ▀██  ██   ██      ██ ██▀ ▀▀  ██   ██   ▄█   ▄█▀   ██ ██▀ ▀▀ 
██▄       ▄     ▀██ ██       ▄██      ▄██  ██   ██     ▄██ ██      ██    ██ ▄█    ██▀▀▀▀▀▀ ██     
▀██▄     ▄▀█     ██ ██     ▀▀██▄    ▀▀██▄  ██   ██    ▄██▀ ██      ██     ███     ██▄    ▄ ██     
  ▀▀█████▀█▀█████▀▄████▄      ██       ██▄████▄████████▀ ▄████▄  ▄████▄    █       ▀█████▀████▄   
                       ███  ▄█▀ ███  ▄█▀                                                          
                        █████▀   █████▀                                                           

    Cheers,
    - Ryder Johnson
    - Justin Hwang
 */
import java.util.NoSuchElementException;
import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.function.Consumer;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.io.File;
import java.io.FileNotFoundException;
import java.lang.reflect.Field;
import java.util.Scanner;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
import java.io.PrintStream;
import java.io.IOException;
import java.nio.file.FileSystemException;
import java.nio.file.Files;
import java.io.PrintWriter;
//AUTOGENERATED FROM ../src/LinkedListGeneralTests.java

/**
 * General Tests for LinkedLists.
 */
class LinkedListGeneralTests {

    private static LinkedList<String> myList;
    private static LinkedList<String> emptyList;

    @BeforeTest
    public static void setupLinkedList() {
        myList = new LinkedList<>(new String[] {"Lindsay", "Elise", "Tarini", "Ethan", "Katia", "Laura", "Kritt"});
        emptyList = new LinkedList<>();
    }
    
    @TestCase(name = "Constructor: No-args constructor")
    @Tip(description = "Make sure you have properly implemented isEmpty() on a new LinkedList!")
    public static void constructorNoArgs() throws TestFailedException {
        
        TestFunction.assertEqual(emptyList.isEmpty(), true);

    }

    @TestCase(name = "Constructor: Iterator returns no elements")
    @Tip(description = "Make sure that your iterator() method returns a new iterator() of the correct type, and that it returns no elements")
    public static void constructorNoArgs2() throws TestFailedException {

        TestFunction.assertEqual(TestUtils.iterableToString(emptyList), "");

    }

    @TestCase(name = "Constructor: Given array of String")
    @Tip(description = "This test uses your iterator to convert the LinkedList to String. Even if your constructor is functional, this test may fail because of your iterator implementation!")
    public static void constructorArray() throws TestFailedException {

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt");

    }

    @TestCase(name = "Constructor: Given array of Object")
    @Tip(description = "This test uses your iterator to convert the LinkedList to String. Even if your constructor is functional, this test may fail because of your iterator implementation!")
    public static void constructorArrayObject() throws TestFailedException {
        
        LinkedList<Object> list = new LinkedList<>(new Object[] {"Lindsay", "Elise", "Tarini", "Ethan", "Katia", "Laura", "Kritt"});

        TestFunction.assertEqual(TestUtils.iterableToString(list), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt");

    }

    @TestCase(name = "Constructor: Given null array")
    @Tip(description = "What should occur when your constructor is given a null array?")
    public static void constructorArrayNull() throws TestFailedException {

        TestFunction.testForException(IllegalArgumentException.class, () -> new LinkedList<>(null));

    }

    @TestCase(name = "Constructor: Given array with one null element")
    @Tip(description = "What should occur when your constructor is given an array with a null element?")
    public static void constructorArrayNullElement() throws TestFailedException {

        TestFunction.testForException(IllegalArgumentException.class, () -> new LinkedList<String>(new String[] {"Tremor", "Skipper", null}));

    }

    @TestCase(name = "toArray(): Valid array of String")
    @Tip(description = "Make sure you're using the iterator's next() and hasNext() methods!")
    public static void toArrayValid() throws TestFailedException {

        TestFunction.assertEqual(StringUtils.arrayToString(myList.toArray()), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt,");

    }

    @TestCase(name = "toArray(): Valid array of Object")
    @Tip(description = "Make sure you're using the iterator's next() and hasNext() methods!")
    public static void toArrayValidObject() throws TestFailedException {

        LinkedList<Object> list = new LinkedList<>(new Object[] {"Lindsay", "Elise", "Tarini", "Ethan", "Katia", "Laura", "Kritt"});

        TestFunction.assertEqual(StringUtils.arrayToString(list.toArray()), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt,");

    }

    @TestCase(name = "toArray(): Empty array of String")
    @Tip(description = "Make sure you return an empty array, and not null!\nSee: https://edstem.org/us/courses/42939/discussion/3877975?comment=9010610")
    public static void toArrayEmpty() throws TestFailedException {

        TestFunction.assertEqual(StringUtils.arrayToString(emptyList.toArray()), "");

    }

    @TestCase(name = "contains(): Element at the start")
    @Tip(description =  "Remember to use an iterator, and NOT a loop!")
    public static void containsFirst() throws TestFailedException {
        
        TestFunction.assertEqual(myList.contains("Lindsay"), true);

    }

    @TestCase(name = "contains(): Element in the middle")
    @Tip(description =  "Remember to use an iterator, and NOT a loop!")
    public static void containsMiddle() throws TestFailedException {
        
        TestFunction.assertEqual(myList.contains("Tarini"), true);

    }

    @TestCase(name = "contains(): Element at the end")
    @Tip(description =  "Remember to use an iterator, and NOT a loop!")
    public static void containsLast() throws TestFailedException {
        
        TestFunction.assertEqual(myList.contains("Kritt"), true);

    }

    @TestCase(name = "contains(): Element that does not exist")
    @Tip(description =  "Remember to use an iterator, and NOT a loop!")
    public static void containsNone() throws TestFailedException {
        
        TestFunction.assertEqual(myList.contains("Armaan"), false);

    }

    @TestCase(name = "contains(): Element = null")
    @Tip(description =  "What should happen if the given element is null?")
    public static void containsNull() throws TestFailedException {
        
        TestFunction.testForException(IllegalArgumentException.class, () -> myList.contains(null));

    }

    @TestCase(name = "clear(): Clears the list (checks for elements)")
    @Tip(description =  "Make sure you remove ALL elements from this list!")
    public static void clearElements() throws TestFailedException {
        
        myList.clear();
        TestFunction.assertEqual(TestUtils.iterableToString(myList), "");

    }

    @TestCase(name = "clear(): Clears the list (checks for size)")
    @Tip(description =  "Make sure you update your size accordingly!")
    public static void clearElementsSize() throws TestFailedException {
        
        myList.clear();
        TestFunction.assertEqual(myList.size(), 0);

    }

    @TestCase(name = "isEmpty(): Checks a list that is not empty")
    @Tip(description =  "What criteria should you use to determine if your list is empty?")
    public static void isEmptyNotEmpty() throws TestFailedException {
        
        TestFunction.assertEqual(myList.isEmpty(), false);

    }

    @TestCase(name = "isEmpty(): Checks a list that is empty")
    @Tip(description =  "Make sure you update your size accordingly!")
    public static void isEmptyEmpty() throws TestFailedException {
        
        TestFunction.assertEqual(emptyList.isEmpty(), true);

    }

    @TestCase(name = "size(): Checks size of normal list")
    @Tip(description =  "Make sure you're updating your size throughout the whole program!")
    public static void sizeValidSize() throws TestFailedException {
        
        TestFunction.assertEqual(myList.size(), 7);

    }

    @TestCase(name = "size(): Checks size of empty list")
    @Tip(description =  "Make sure you're updating your size throughout the whole program!")
    public static void sizeEmpty() throws TestFailedException {
        
        TestFunction.assertEqual(emptyList.size(), 0);

    }

}

//AUTOGENERATED FROM ../src/LinkedListRemoveTests.java


class LinkedListRemoveTests {

    private static LinkedList<String> myList;
    private static LinkedList<String> emptyList;

    @BeforeTest
    public static void setupLinkedList() {
        myList = new LinkedList<>(new String[] {"Lindsay", "Elise", "Tarini", "Ethan", "Katia", "Laura", "Kritt"});
        emptyList = new LinkedList<>();
    }

    @TestCase(name = "remove(): Removes element from start of array (Checks for removal)")
    @Tip(description = "Make sure you remove from the array and update your head!")
    public static void removeNoArgsRemoved() throws TestFailedException {

        myList.remove();

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Elise,Tarini,Ethan,Katia,Laura,Kritt");

    }

    @TestCase(name = "remove(): Removes element from start of array (Checks for size)")
    @Tip(description = "Make sure you update your size!")
    public static void removeNoArgsRemovedSize() throws TestFailedException {

        myList.remove();

        TestFunction.assertEqual(myList.size(), 6);

    }

    @TestCase(name = "remove(): Removes element from start of array (Checks for return)")
    @Tip(description = "Make sure you return the element you removed!")
    public static void removeNoArgsRemovedReturned() throws TestFailedException {

        String removed = myList.remove();

        TestFunction.assertEqual(removed, "Lindsay");

    }

    @TestCase(name = "remove(): Remove from empty List")
    @Tip(description = "What should occur if you try to remove an element from an empty list?")
    public static void removeNoArgsEmpty() throws TestFailedException {

        TestFunction.testForException(NoSuchElementException.class, () -> emptyList.remove());

    }

    @TestCase(name = "remove(): Empty list (checking size)")
    @Tip(description = "Make sure that you do NOT update your size if you do not remove anything!")
    public static void removeNoArgsEmptySize() throws TestFailedException {

        try {
            emptyList.remove();
        } catch (Exception e) {
            // Do nothing
        };

        TestFunction.assertEqual(emptyList.size(), 0);

    }

    @TestCase(name = "remove(int index): Removes from index 0 (checking for removal)")
    @Tip(description = "Make sure you remove from the array and update your head!")
    public static void removeOneArg() throws TestFailedException {

        myList.remove(0);

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Elise,Tarini,Ethan,Katia,Laura,Kritt");

    }

    @TestCase(name = "remove(int index): Removes from index 0 (checking size)")
    @Tip(description = "Make sure you remove from the array and update your size!")
    public static void removeOneArgStartSize() throws TestFailedException {

        myList.remove(0);

        TestFunction.assertEqual(myList.size(), 6);

    }

    @TestCase(name = "remove(int index): Removes from index 0 (checking return)")
    @Tip(description = "Make sure you return the element you removed!")
    public static void removeOneArgStartReturn() throws TestFailedException {

        String returned = myList.remove(0);

        TestFunction.assertEqual(returned, "Lindsay");

    }

    @TestCase(name = "remove(int index): Removes from middle (checking for removal)")
    @Tip(description = "Make sure you remove from the array and update your head!")
    public static void removeOneArgMiddle() throws TestFailedException {

        myList.remove(4);

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Lindsay,Elise,Tarini,Ethan,Laura,Kritt");

    }

    @TestCase(name = "remove(int index): Removes from middle (checking size)")
    @Tip(description = "Make sure you remove from the array and update your size!")
    public static void removeOneArgMiddleSize() throws TestFailedException {

        myList.remove(4);

        TestFunction.assertEqual(myList.size(), 6);

    }

    @TestCase(name = "remove(int index): Removes from middle (checking return)")
    @Tip(description = "Make sure you return the element you removed!")
    public static void removeOneArgMiddleReturn() throws TestFailedException {

        String returned = myList.remove(4);

        TestFunction.assertEqual(returned, "Katia");

    }

    @TestCase(name = "remove(int index): Removes from last index (checking for removal)")
    @Tip(description = "Make sure you remove from the array and update your head!")
    public static void removeOneArgLast() throws TestFailedException {

        myList.remove(6);

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Lindsay,Elise,Tarini,Ethan,Katia,Laura");

    }

    @TestCase(name = "remove(int index): Removes from last index (checking size)")
    @Tip(description = "Make sure you remove from the array and update your size!")
    public static void removeOneArgLastSize() throws TestFailedException {

        myList.remove(6);

        TestFunction.assertEqual(myList.size(), 6);

    }

    @TestCase(name = "remove(int index): Removes from last index (checking return)")
    @Tip(description = "Make sure you return the element you removed!")
    public static void removeOneArgLastReturn() throws TestFailedException {

        String returned = myList.remove(6);

        TestFunction.assertEqual(returned, "Kritt");

    }

    @TestCase(name = "remove(int index): Empty list")
    @Tip(description = "What should happen if you try to remove from an empty list?")
    public static void removeOneArgEmpty() throws TestFailedException {

        TestFunction.testForException(NoSuchElementException.class, () -> emptyList.remove(0));

    }

    @TestCase(name = "remove(int index): Empty list (checking size)")
    @Tip(description = "Make sure that you do NOT update your size if you do not remove anything!")
    public static void removeOneArgEmptySize() throws TestFailedException {

        try {
            emptyList.remove(0);
        } catch (Exception e) {
            // Do nothing
        };

        TestFunction.assertEqual(emptyList.size(), 0);

    }

    @TestCase(name = "remove(int index): Empty list AND index = -1")
    @Tip(description = "What should happen if you try to remove from an empty list AND the index is invalid?")
    public static void removeOneArgEmptyAndInvalid() throws TestFailedException {

        TestFunction.testForException(NoSuchElementException.class, () -> emptyList.remove(-1));

    }

    @TestCase(name = "remove(int index): Index = -1")
    @Tip(description = "Is this a valid index to remove from? What should happen if an invalid index is passed in?")
    public static void removeOneArgInvalid() throws TestFailedException {

        TestFunction.testForException(IndexOutOfBoundsException.class, () -> myList.remove(-1));

    }

    @TestCase(name = "remove(int index): Index = -1 (checking size)")
    @Tip(description = "Make sure that you do NOT update your size if you do not remove anything!")
    public static void removeOneArgCheckSize() throws TestFailedException {

        try {
            myList.remove(-1);
        } catch (Exception e) {
            // Do nothing
        };

        TestFunction.assertEqual(myList.size(), 7);

    }

    @TestCase(name = "remove(int index): Index = size")
    @Tip(description = "Is this a valid index to remove from? What should happen if an invalid index is passed in?")
    public static void removeOneArgSize() throws TestFailedException {

        TestFunction.testForException(IndexOutOfBoundsException.class, () -> myList.remove(7));

    }

    @TestCase(name = "remove(int index): Index = size (checking size)")
    @Tip(description = "Make sure that you do NOT update your size if you do not remove anything!")
    public static void removeOneArgCheckSizeSize() throws TestFailedException {

        try {
            myList.remove(7);
        } catch (Exception e) {
            // Do nothing
        };

        TestFunction.assertEqual(myList.size(), 7);

    }

    @TestCase(name = "remove(T element): Remove element at start (check for removal)")
    @Tip(description = "Make sure you remove the element and update the head!")
    public static void removeElementStart() throws TestFailedException {

        myList.remove("Lindsay");

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Elise,Tarini,Ethan,Katia,Laura,Kritt");

    }

    @TestCase(name = "remove(T element): Remove element at start (check for size)")
    @Tip(description = "Make sure you remove the element and update the size!")
    public static void removeElementStartSize() throws TestFailedException {

        myList.remove("Lindsay");

        TestFunction.assertEqual(myList.size(), 6);

    }

    @TestCase(name = "remove(T element): Remove element at start (check for return)")
    @Tip(description = "Make sure you return the removed element!")
    public static void removeElementStartReturn() throws TestFailedException {

        String removed = myList.remove("Lindsay");

        TestFunction.assertEqual(removed, "Lindsay");

    }

    @TestCase(name = "remove(T element): Remove element in middle (check for removal)")
    @Tip(description = "Make sure you remove the element and update the head!")
    public static void removeElementMiddle() throws TestFailedException {

        myList.remove("Katia");

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Lindsay,Elise,Tarini,Ethan,Laura,Kritt");

    }

    @TestCase(name = "remove(T element): Remove element in middle (check for size)")
    @Tip(description = "Make sure you remove the element and update the size!")
    public static void removeElementMiddleSize() throws TestFailedException {

        myList.remove("Katia");

        TestFunction.assertEqual(myList.size(), 6);

    }

    @TestCase(name = "remove(T element): Remove element in middle (check for return)")
    @Tip(description = "Make sure you return the removed element!")
    public static void removeElementMiddleReturn() throws TestFailedException {

        String removed = myList.remove("Katia");

        TestFunction.assertEqual(removed, "Katia");

    }

    @TestCase(name = "remove(T element): Remove element at end (check for removal)")
    @Tip(description = "Make sure you remove the element and update the head!")
    public static void removeElementEnd() throws TestFailedException {

        myList.remove("Kritt");

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Lindsay,Elise,Tarini,Ethan,Katia,Laura");

    }

    @TestCase(name = "remove(T element): Remove element at end (check for size)")
    @Tip(description = "Make sure you remove the element and update the size!")
    public static void removeElementEndSize() throws TestFailedException {

        myList.remove("Kritt");

        TestFunction.assertEqual(myList.size(), 6);

    }

    @TestCase(name = "remove(T element): Remove element at end (check for return)")
    @Tip(description = "Make sure you return the removed element!")
    public static void removeElementEndReturn() throws TestFailedException {

        String removed = myList.remove("Kritt");

        TestFunction.assertEqual(removed, "Kritt");

    }

    @TestCase(name = "remove(T element): Null element")
    @Tip(description = "What should happen if your method is given a null element?")
    public static void removeElementNull() throws TestFailedException {

        TestFunction.testForException(IllegalArgumentException.class, () -> myList.remove(null));

    }

    @TestCase(name = "remove(T element): Element not found")
    @Tip(description = "What should happen if your method is not found in the list?")
    public static void removeElementNotFound() throws TestFailedException {

        TestFunction.testForException(NoSuchElementException.class, () -> myList.remove("Janhavi"));

    }

    @TestCase(name = "remove(T element): Empty list")
    @Tip(description = "Can an element be found in an empty list? What should happen if the element is not found?")
    public static void removeElementFromEmpty() throws TestFailedException {

        TestFunction.testForException(NoSuchElementException.class, () -> emptyList.remove("Janhavi"));

    }
}

//AUTOGENERATED FROM ../src/HW08Driver.java


class Driver {
    public static void main(String[] args) {
        StringUtils.printHorizontalLine();

        System.out.println("\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255A\u2588\u2588\u2557 \u2588\u2588\u2554\u255D\u2588\u2588\u2554\u2550\u2550\u255D  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551 \u255A\u2588\u2588\u2588\u2588\u2554\u255D \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\n\u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u255D  \u255A\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u2550\u2550\u255D  \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u255D");

        TerminalOption helpOption = new TerminalOption("-h", "List all commands", "java <COMPILED_DRIVER_FILE> -h");
        TerminalOption runClassesOption = new TerminalOption("-c", "Run only specific test classes", "java <COMPILED_DRIVER_FILE> -c SomeClassWithTests AnotherClassWithTests");

        TerminalOption[] options = getTerminalOptions(args, helpOption, runClassesOption);

        List<String> filter = runClassesOption.getInput();

        if (helpOption.received()) {
            System.out.println("Commands:");
            for (TerminalOption o : options) {
                System.out.println(ColorUtils.formatForegroundColorString(AsciiColorCode.BRIGHT_YELLOW_FOREGROUND, o.getFlag()) + " " + o.getName());
                System.out.println("\tUsage: " + o.getUsage());
            }
        } else {

            TestManager.setTestFilter(filter);
            TestManager.runTestsOn(NodeTests.class, LinkedListIteratorTests.class, LinkedListGeneralTests.class, LinkedListAddTests.class, LinkedListRemoveTests.class, LinkedListGetSetTests.class);

        }

    }

    private static TerminalOption[] getTerminalOptions(String[] args, TerminalOption helpOption, TerminalOption runClassesOption) {
        TerminalOption[] options = {helpOption, runClassesOption};

        TerminalOption currentOption = null;

        argloop:
        for (String arg : args) {
            for (TerminalOption o : options) {
                if (o.getFlag().equals(arg)) {
                    currentOption = o;
                    currentOption.setReceived(true);
                    continue argloop;
                }
            }

            if (currentOption != null) {
                currentOption.addInput(arg);
            }
        }
        return options;
    }
}

//AUTOGENERATED FROM ../src/LinkedListAddTests.java

class LinkedListAddTests {

    private static LinkedList<String> myList;
    private static LinkedList<String> emptyList;

    @BeforeTest
    public static void setupLinkedList() {
        myList = new LinkedList<>(new String[] {"Lindsay", "Elise", "Tarini", "Ethan", "Katia", "Laura", "Kritt"});
        emptyList = new LinkedList<>();
    }

    @TestCase(name = "add(T element): Add elements to an empty list")
    @Tip(description = "Make sure that your add() method works when you start with an empty List, and that size() is properly updated!")
    public static void addToEmpty() throws TestFailedException {

        emptyList.add("Lindsay");

        TestFunction.assertEqual(TestUtils.iterableToString(emptyList), "Lindsay");
        TestFunction.assertEqual(emptyList.size(), 1);

    }

    @TestCase(name = "add(T element): Add element to the end of an existing list")
    @Tip(description = "Make sure that you can add to the end, and that size() is properly updated!")
    public static void addToEnd() throws TestFailedException {

        LinkedList<Object> list = new LinkedList<>(new Object[] {"Lindsay", "Elise", "Tarini", "Ethan", "Katia", "Laura"});
        list.add("Kritt");

        TestFunction.assertEqual(TestUtils.iterableToString(list), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt");
        TestFunction.assertEqual(list.size(), 7);

    }

    @TestCase(name = "add(T element): Add two elements to the end of an existing list")
    @Tip(description = "Make sure that you can add to the end, and that size() is properly updated!")
    public static void addTwoToEnd() throws TestFailedException {

        LinkedList<Object> list = new LinkedList<>(new Object[] {"Lindsay", "Elise", "Tarini", "Ethan", "Katia"});
        list.add("Laura");
        list.add("Kritt");

        TestFunction.assertEqual(TestUtils.iterableToString(list), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt");
        TestFunction.assertEqual(list.size(), 7);

    }

    @TestCase(name = "add(T element): Giving null to one-arg add(T)")
    @Tip(description = "What should happen if you try to add a null element?")
    public static void addOneNull() throws TestFailedException {

        TestFunction.testForException(IllegalArgumentException.class, () -> myList.add(null));

    }

    @TestCase(name = "add(int index): Add element to the beginning of an existing list")
    @Tip(description = "Make sure that you can add to the beginning, and that both head and size are properly updated! If you do not update the head, then the iterator will not start at the new first element!")
    public static void addToStart() throws TestFailedException {

        LinkedList<Object> list = new LinkedList<>(new Object[] {"Elise", "Tarini", "Ethan", "Katia", "Laura", "Kritt"});
        list.add(0, "Lindsay");

        TestFunction.assertEqual(TestUtils.iterableToString(list), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt");
        TestFunction.assertEqual(list.size(), 7);

    }

    @TestCase(name = "add(int index): Add two elements to the beginning of an existing list")
    @Tip(description = "Make sure that you can add to the beginning, and that both head and size are properly updated! If you do not update the head, then the iterator will not start at the new first element!")
    public static void addTwoToStart() throws TestFailedException {

        LinkedList<Object> list = new LinkedList<>(new Object[] {"Tarini", "Ethan", "Katia", "Laura", "Kritt"});
        list.add(0, "Elise");
        list.add(0, "Lindsay"); // This gets inserted before Elise in the list

        TestFunction.assertEqual(TestUtils.iterableToString(list), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt");
        TestFunction.assertEqual(list.size(), 7);

    }

    @TestCase(name = "add(int index): Add element to the middle of an existing list")
    @Tip(description = "Make sure that you can add to the middle, and that the size is properly updated!")
    public static void addToMiddle() throws TestFailedException {

        LinkedList<Object> list = new LinkedList<>(new Object[] {"Lindsay", "Elise", "Tarini", "Katia", "Laura", "Kritt"});
        list.add(3, "Ethan");

        TestFunction.assertEqual(TestUtils.iterableToString(list), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt");
        TestFunction.assertEqual(list.size(), 7);

    }

    @TestCase(name = "add(int index): Add two elements to the middle of an existing list")
    @Tip(description = "Make sure that you can add to the middle, and that the size is properly updated!")
    public static void addTwoToMiddle() throws TestFailedException {

        LinkedList<Object> list = new LinkedList<>(new Object[] {"Lindsay", "Elise", "Tarini", "Laura", "Kritt"});
        list.add(3, "Katia");
        list.add(3, "Ethan");

        TestFunction.assertEqual(TestUtils.iterableToString(list), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt");
        TestFunction.assertEqual(list.size(), 7);

    }

    @TestCase(name = "add(int index): Giving null to two-arg add()")
    @Tip(description = "What should happen if you try to add a null element?")
    public static void addTwoNull() throws TestFailedException {

        TestFunction.testForException(IllegalArgumentException.class, () -> myList.add(3, null));

    }

    @TestCase(name = "add(int index): Give index -1")
    @Tip(description = "Can you add an element at this index?")
    public static void addToIndexNegOne() throws TestFailedException {

        TestFunction.testForException(IndexOutOfBoundsException.class, () -> myList.add(-1, "Hyeyoon"));

    }

    @TestCase(name = "add(int index): Give index 0")
    @Tip(description = "Can you add an element at this index?")
    public static void addToIndexZero() throws TestFailedException {

        LinkedList<Object> list = new LinkedList<>(new Object[] {"Lindsay", "Elise", "Tarini", "Ethan", "Katia", "Laura", "Kritt"});
        list.add(0, "Janhavi");

        TestFunction.assertEqual(TestUtils.iterableToString(list), "Janhavi,Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt");

    }

    @TestCase(name = "add(int index): Give index \"size\"")
    @Tip(description = "Can you add an element at this index? Check the javadocs under the add method!")
    public static void addToIndexSize() throws TestFailedException {

        LinkedList<Object> list = new LinkedList<>(new Object[] {"Lindsay", "Elise", "Tarini", "Ethan", "Katia", "Laura", "Kritt"});
        list.add(7, "Janhavi");

        TestFunction.assertEqual(TestUtils.iterableToString(list), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Kritt,Janhavi");

    }

    @TestCase(name = "add(int index): Give index size+1")
    @Tip(description = "Can you add an element at this index?")
    public static void addToIndexSizePlusOne() throws TestFailedException {

        TestFunction.testForException(IndexOutOfBoundsException.class, () -> myList.add(8, "Janhavi"));

    }

    @TestCase(name = "add(int index): Give index -1, and give a null element")
    @Tip(description = "Which exception should be thrown if the index is invalid AND the element is null?")
    public static void addInvalidIndexAndNull() throws TestFailedException {

        TestFunction.testForException(IndexOutOfBoundsException.class, () -> myList.add(-1, null));

    }
}

//AUTOGENERATED FROM ../src/LinkedListIteratorTests.java


class LinkedListIteratorTests {

    @TestCase(name = "Constructor: Valid array of String")
    @Tip(description = "Make sure you have a constructor! If your add method is incorrect, this test will likely fail.")
    public static void constructorValidInput() throws TestFailedException {

        LinkedList<String> list = new LinkedList<>(new String[] {"Ansel", "Ethan"});

        Iterator<String> iterator = new LinkedListIterator<>(list);

        TestFunction.assertEqual(iterator.hasNext(), true);

    }

    @TestCase(name = "hasNext: calling hasNext() several times")
    @Tip(description = "Do not move the Iterator forwards with just a hasNext() call!")
    public static void hasNextValid() throws TestFailedException {

        LinkedList<String> list = new LinkedList<>(new String[] {"Ansel", "Ethan"});

        Iterator<String> iterator = new LinkedListIterator<>(list);
        iterator.hasNext();
        iterator.hasNext();
        iterator.hasNext();

        TestFunction.assertEqual(iterator.hasNext(), true);

    }

    @TestCase(name = "hasNext: Empty List passed in")
    @Tip(description = "hasNext() should return false, since there are no elements in the list")
    public static void hasNextFalse() throws TestFailedException {

        LinkedList<String> list = new LinkedList<>(new String[] {});

        Iterator<String> iterator = new LinkedListIterator<>(list);

        TestFunction.assertEqual(iterator.hasNext(), false);

    }

    @TestCase(name = "next: Valid inputs passed in")
    @Tip(description = "next() should return the first element in the list the first time it's called!")
    public static void nextValidInput() throws TestFailedException {

        LinkedList<String> list = new LinkedList<>(new String[] {"Ansel", "Ethan"});

        Iterator<String> iterator = new LinkedListIterator<>(list);

        TestFunction.assertEqual(iterator.next(), "Ansel");

    }

    @TestCase(name = "next: Iterator gets advanced forwards")
    @Tip(description = "next() should move the Iterator forwards to the next Node")
    public static void nextAdvances() throws TestFailedException {

        LinkedList<String> list = new LinkedList<>(new String[] {"Ansel", "Ethan"});

        Iterator<String> iterator = new LinkedListIterator<>(list);
        iterator.next();

        TestFunction.assertEqual(iterator.next(), "Ethan");

    }

    @TestCase(name = "next: Throws NoSuchElementException")
    @Tip(description = "What should happen if there are no more elements to return?")
    public static void nextThrowsException() throws TestFailedException {

        LinkedList<String> list = new LinkedList<>(new String[] {"Ansel", "Ethan"});

        Iterator<String> iterator = new LinkedListIterator<>(list);
        iterator.next();
        iterator.next();

        TestFunction.testForException(NoSuchElementException.class, () -> iterator.next());

    }

    @TestCase(name = "Iterates through all elements in the list")
    @Tip(description = "Read the box on the bottom right of page 3 of the directions!")
    public static void iteratesThroughAll() throws TestFailedException {

        LinkedList<String> list = new LinkedList<>(new String[] {"Ansel", "Ethan", "Lindsay", "Elise", "Kritt", "Tarini", "Roopa", "Katia", "Laura", "Aarushi", "Clarence", "Skyla"});

        Iterator<String> iterator = new LinkedListIterator<>(list);
        
        StringBuilder builder = new StringBuilder();
        builder.append(iterator.next());
        
        while (iterator.hasNext()) {
            builder.append(",").append(iterator.next());
        }

        TestFunction.assertEqual(builder.toString(), "Ansel,Ethan,Lindsay,Elise,Kritt,Tarini,Roopa,Katia,Laura,Aarushi,Clarence,Skyla");

    }
    
}

//AUTOGENERATED FROM ../src/LinkedListGetSetTests.java

class LinkedListGetSetTests {

    private static LinkedList<String> myList;

    @BeforeTest
    public static void setupLinkedList() {
        myList = new LinkedList<>(new String[] {"Lindsay", "Elise", "Tarini", "Ethan", "Katia", "Laura", "Kritt"});
    }    

    @TestCase(name = "set(): Replace the first element")
    @Tip(description = "Make sure you update the head!")
    public static void setFirstElement() throws TestFailedException {
        
        myList.set(0, "Janhavi");

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Janhavi,Elise,Tarini,Ethan,Katia,Laura,Kritt");

    }

    @TestCase(name = "set(): Replace the first element (check for size)")
    @Tip(description = "Make sure you update the size!")
    public static void setFirstElementSize() throws TestFailedException {
        
        myList.set(0, "Janhavi");

        TestFunction.assertEqual(myList.size(), 7);

    }

    @TestCase(name = "set(): Replace the first element (check for return)")
    @Tip(description = "Make sure you return the replaced data!")
    public static void setFirstElementReturn() throws TestFailedException {
        
        String replaced = myList.set(0, "Janhavi");

        TestFunction.assertEqual(replaced, "Lindsay");

    }

    @TestCase(name = "set(): Replace a middle element")
    @Tip(description = "Make sure you update the head!")
    public static void setMiddleElement() throws TestFailedException {
        
        myList.set(3, "Edwar");

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Lindsay,Elise,Tarini,Edwar,Katia,Laura,Kritt");

    }

    @TestCase(name = "set(): Replace a middle element (check for size)")
    @Tip(description = "Make sure you update the size!")
    public static void setMiddleElementSize() throws TestFailedException {
        
        myList.set(3, "Edwar");

        TestFunction.assertEqual(myList.size(), 7);

    }

    @TestCase(name = "set(): Replace a middle element (check for return)")
    @Tip(description = "Make sure you return the replaced data!")
    public static void setMiddleElementReturn() throws TestFailedException {
        
        String replaced = myList.set(3, "Edwar");

        TestFunction.assertEqual(replaced, "Ethan");

    }

    @TestCase(name = "set(): Replace the last element")
    @Tip(description = "Make sure you update the head!")
    public static void setLastElement() throws TestFailedException {
        
        myList.set(6, "Rachel");

        TestFunction.assertEqual(TestUtils.iterableToString(myList), "Lindsay,Elise,Tarini,Ethan,Katia,Laura,Rachel");

    }

    @TestCase(name = "set(): Replace the last element (check for size)")
    @Tip(description = "Make sure you update the size!")
    public static void setLastElementSize() throws TestFailedException {
        
        myList.set(6, "Rachel");

        TestFunction.assertEqual(myList.size(), 7);

    }

    @TestCase(name = "set(): Replace the last element (check for return)")
    @Tip(description = "Make sure you return the replaced data!")
    public static void setLastElementReturn() throws TestFailedException {
        
        String replaced = myList.set(6, "Rachel");

        TestFunction.assertEqual(replaced, "Kritt");

    }

    @TestCase(name = "set(): Index = -1")
    @Tip(description =  "Is this a valid index? What should happen when this index is passed in?")
    public static void setNegative() throws TestFailedException {
        
        TestFunction.testForException(IndexOutOfBoundsException.class, () -> myList.set(-1, "Vi"));

    }

    @TestCase(name = "set(): Index = size")
    @Tip(description =  "Is this a valid index? What should happen when this index is passed in?")
    public static void setAtSize() throws TestFailedException {
        
        TestFunction.testForException(IndexOutOfBoundsException.class, () -> myList.set(7, "Aditi"));

    }

    @TestCase(name = "set(): Element is null")
    @Tip(description =  "What should happen when the element is null?")
    public static void setElementNull() throws TestFailedException {
        
        TestFunction.testForException(IllegalArgumentException.class, () -> myList.set(6, null));

    }

    @TestCase(name = "set(): Element is null AND index is invalid")
    @Tip(description =  "What exception should be thrown when both issues occur?")
    public static void setElementNullAndInvalid() throws TestFailedException {
        
        TestFunction.testForException(IndexOutOfBoundsException.class, () -> myList.set(-1, null));

    }

    @TestCase(name = "get(): Element at 0th index")
    @Tip(description =  "Make sure you're retrieving the correct element!")
    public static void getElementZero() throws TestFailedException {
        
        TestFunction.assertEqual(myList.get(0), "Lindsay");

    }

    @TestCase(name = "get(): Element at a middle index")
    @Tip(description =  "Make sure you're retrieving the correct element!")
    public static void getElementMiddle() throws TestFailedException {
        
        TestFunction.assertEqual(myList.get(3), "Ethan");

    }

    @TestCase(name = "get(): Element at last index")
    @Tip(description =  "Make sure you're retrieving the correct element!")
    public static void getElementLast() throws TestFailedException {
        
        TestFunction.assertEqual(myList.get(6), "Kritt");

    }

    @TestCase(name = "get(): Index = -1")
    @Tip(description =  "Is this a valid index? What should happen when this index is passed in?")
    public static void getElementNegative() throws TestFailedException {
        
        TestFunction.testForException(IndexOutOfBoundsException.class, () -> myList.get(-1));

    }

    @TestCase(name = "get(): Index = size")
    @Tip(description =  "Is this a valid index? What should happen when this index is passed in?")
    public static void getElementSize() throws TestFailedException {
        
        TestFunction.testForException(IndexOutOfBoundsException.class, () -> myList.get(7));

    }
}

//AUTOGENERATED FROM ../src/NodeTests.java

/**
 * Class to test the Node file
 */
class NodeTests {

    @TestCase(name = "Constructor: Null 'next' passed into two-arg constructor")
    @Tip(description = "Remember that null IS a valid input for the 'next' input. A Node may point to nothing!")
    public static void constructorNullNext() throws TestFailedException {

        Node<String> node = new Node<>("My Data", null);

        TestFunction.assertEqual(nodeToString(node), "My Data, null");

    }

    @TestCase(name = "Constructor: Valid data and next")
    @Tip(description = "Make sure that you have a constructor, as well as getters/setters for each variable!")
    public static void constructorValidInputs() throws TestFailedException {

        Node<String> next = new Node<>("Next Data");
        Node<String> node = new Node<>("My Data", next);

        TestFunction.assertEqual(nodeToString(node), "My Data, Next Data");

    }

    @TestCase(name = "Constructor: One-arg constructor")
    @Tip(description = "Make sure that you have a one-arg constructor. What should 'next' default to?")
    public static void constructorOneArg() throws TestFailedException {

        Node<String> node = new Node<>("My Data");

        TestFunction.assertEqual(nodeToString(node), "My Data, null");

    }

    @TestCase(name = "Constructor: Null data given to 2-arg constructor")
    @Tip(description = "What should happen if 'data' gets set to null?")
    public static void constructorNullData() throws TestFailedException {

        Node<String> next = new Node<>("NextData");

        TestFunction.testForException(IllegalArgumentException.class, () -> new Node<>(null, next));

    }

    @TestCase(name = "Constructor: Null data given to 1-arg constructor")
    @Tip(description = "What should happen if 'data' gets set to null?")
    public static void constructorOneNullData() throws TestFailedException {

        TestFunction.testForException(IllegalArgumentException.class, () -> new Node<>(null));

    }

    @TestCase(name = "getData: Returns the data")
    @Tip(description = "Make sure that your getter returns a reference to the SPECIFIC instance of the Object passed into the constructor, not a copy of it.")
    public static void getDataValid() throws TestFailedException {

        // This weird node-nesting is to test the == operator, not just a .equals(). This ensures
        // that the specific Object returned is the SPECIFIC object passed in, not just an identical one.
        Node<Integer> thisNode = new Node<>(6);
        Node<Integer> nextNode = new Node<>(70);
        Node<Node<?>> next = new Node<>(nextNode);
        Node<Node<?>> node = new Node<>(thisNode, next);

        TestFunction.assertEqual(node.getData() == thisNode, true);

    }

    @TestCase(name = "setData: Sets data to a valid value")
    @Tip(description = "Make sure that your setter properly sets `data` to the new data!")
    public static void setDataValid() throws TestFailedException {

        Integer thisInteger = 9;
        Integer nextInteger = 71;
        Node<Integer> next = new Node<>(nextInteger);
        Node<Integer> node = new Node<>(thisInteger, next);
        node.setData(73);

        TestFunction.assertEqual(node.getData(), 73);

    }

    @TestCase(name = "setData: Sets data to null")
    @Tip(description = "What should happen if null data gets passed into the setter?")
    public static void setDataNull() throws TestFailedException {

        Integer thisInteger = 9;
        Integer nextInteger = 71;
        Node<Integer> next = new Node<>(nextInteger);
        Node<Integer> node = new Node<>(thisInteger, next);
        TestFunction.testForException(IllegalArgumentException.class, () -> node.setData(null));

    }

    @TestCase(name = "getNext: Returns the correct Node")
    @Tip(description = "Make sure that your getter returns a reference to the SPECIFIC instance of Node passed into the constructor")
    public static void getNextValid() throws TestFailedException {

        // This weird node-nesting is to test the == operator, not just a .equals(). This ensures
        // that the specific Object returned is the SPECIFIC object passed in, not just an identical one.
        Node<Integer> thisNode = new Node<>(6);
        Node<Integer> nextNode = new Node<>(70);
        Node<Node<?>> next = new Node<>(nextNode);
        Node<Node<?>> node = new Node<>(thisNode, next);

        TestFunction.assertEqual(node.getNext() == next, true);

    }

    @TestCase(name = "setNext: Sets next to a valid value")
    @Tip(description = "Make sure that your setter properly sets `data` to the new data!")
    public static void setNextValid() throws TestFailedException {

        Integer thisInteger = 9;
        Integer nextInteger = 71;
        Node<Integer> next = new Node<>(nextInteger);
        Node<Integer> newNext = new Node<>(73);
        Node<Integer> node = new Node<>(thisInteger, next);
        node.setNext(newNext);

        TestFunction.assertEqual(node.getNext().getData(), 73);

    }

    @TestCase(name = "setNext: Sets next to null")
    @Tip(description = "Remember, null IS a valid 'next'!")
    public static void setNextNull() throws TestFailedException {

        Integer thisInteger = 9;
        Integer nextInteger = 71;
        Node<Integer> next = new Node<>(nextInteger);
        Node<Integer> node = new Node<>(thisInteger, next);
        node.setNext(null);

        TestFunction.assertEqual(node.getNext() == null, true);

    }

    

    /**
     * Returns a String in the following format:
     * {data}, {nextNode}
     * without curly braces. Data and nextData are replaced with the String representations of the objects contained
     * in the current and next nodes, as defined by the Object's toString() method.
     * @param node The Node to convert to String.
     * @return A String, formatted as specified above.
     */
    public static String nodeToString(Node<?> node) {
        return String.format("%s, %s", node.getData().toString(), node.getNext() == null ? "null" : node.getNext().getData().toString());
    }

}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/terminal/TerminalOption.java

/**
 * Represents a potential option the terminal can accept as an input
 */
class TerminalOption {
    /**
     * The flag, denoted by '-<some sort of character>' the terminal will look for
     */
    private String flag;

    /**
     * The name of the flag
     */
    private String name;

    /**
     * An example of using the command, used in the help menu for the program
     */
    private String usage;

    /**
     * An internal boolean representing whether the test case has been successfully
     * added or not
     */
    private boolean received = false;

    /**
     * A list of all of the inputs received from the terminal. This is populated from the main parsing logic. 
     */
    private List<String> input;

    /**
     * Constructs a new TerminalOption given the following parameters
     * @param flag The flag of the option
     * @param name The name of the option, used in the help menu 
     * @param usage An example case of using the option, used in the help menu
     */
    public TerminalOption(String flag, String name, String usage) {
        this.flag = flag;
        this.name = name;
        this.usage = usage;

        this.input = new ArrayList<>();
    }

    /**
     * Retrieves the flag used for the TerminalOption
     * @return the flag
     */
    public String getFlag() {
        return flag;
    }

    /**
     * Adds a new received input to the TerminalOption
     * @param string The string to add to the input
     */
    public void addInput(String string) {
        this.input.add(string);
    }

    /**
     * Retrieves the list of inputs 
     * @return the inputs received of the TerminalOption
     */
    public List<String> getInput() {
        return input;
    }

    /**
     * Sets whether the TerminalOption has successfully received the flag or not
     * @param received true if the flag has been received
     */
    public void setReceived(boolean received) {
        this.received = received;
    }

    /**
     * Retrieves whether the TemrinalOption has been retrieved or not
     * @return true if the flag has been received
     */
    public boolean received() {
        return this.received;
    }

    /**
     * Retrieves the name of the terminal option
     * @return The name of the terminal option
     */
    public String getName() {
        return this.name;
    }

    /**
     * Retrieves the usage statement of the terminal option
     * @return An example usage statement of the terminal option
     */
    public String getUsage() {
        return this.usage;
    }

    public void process() {

    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/DeleteFileBefore.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
@interface DeleteFileBefore { }

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/BeforeTest.java


@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.FIELD })
@interface BeforeTest { }

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/DeleteFileAfter.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
@interface DeleteFileAfter { }

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/Tip.java


@Retention(RetentionPolicy.RUNTIME)
@interface Tip {
    /**
     * Used to display a helpful tip when the user fails a test.
     * 
     * @return The main tip body message
     */
    public String description() default "";
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/DataClass.java

@interface DataClass { }

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/InjectData.java


@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
@interface InjectData {
    /**
     * The name of the file data is injected from
     * 
     * @return The name of the TestCase
     */
    public String name();
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/TestCase.java


@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
@interface TestCase {
    /**
     * The name of the TestCase, used for describing what a test might be doing
     * 
     * @return The name of the TestCase
     */
    public String name() default "UNNAMED_TEST";
}
//AUTOGENERATED FROM ../src/com/cs1331/drivers/annotations/AfterTest.java


@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
@interface AfterTest { }

//AUTOGENERATED FROM ../src/com/cs1331/drivers/testing/TestFunction.java


class TestFunction {
    /**
     * Detects if the given Strings do not have the same content (case-sensitive)
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(String actual, String expected) throws TestFailedException {
        boolean failed = false;

        if (actual == null) {
            if (expected != null) {
                throw new TestFailedException("Test failed! Received null, but expected \"" + expected + "\"");
            }
        } else if (expected == null) {
            throw new TestFailedException("Test failed! Received \"" + actual + "\", but expected null");
        } else {

            if (!actual.replaceAll("\n", System.lineSeparator()).equals(expected.replaceAll("\n", System.lineSeparator()))) {
                failed = true;
            }
        }

        if (failed) {
            
            
            String expectedString = "\"" + expected + "\"";
            String coloredActual = StringUtils.getColorCodedDifference("\"" + actual + "\"", expectedString);

            
            if (coloredActual.trim().contains("\n")) {
                coloredActual = "\n" + coloredActual + "\n";
            }
            if (expected.trim().contains("\n")) {
                expectedString = "\n\"" + expected + "\"\n";
            }

            throw new TestFailedException(
                    "Strings different! Received " + coloredActual + " but expected " + expectedString);
        }
    }

    public static void assertEqual(Iterable<?> actual, Iterable<?> expected) throws TestFailedException {

        boolean failed = false;

        if (actual == null || expected == null) {
            failed = actual == expected;
            throw new TestFailedException(
                    "List different! Received \"" + actual == null ? "null" : TestUtils.iterableToString(actual) + "\", expected \"" + expected == null ? "null" : TestUtils.iterableToString(expected) + "\"");
        } else {
            Iterator<?> aIterator = actual.iterator();
            Iterator<?> eIterator = expected.iterator();
            while (aIterator.hasNext() && eIterator.hasNext()) {
                if (!aIterator.next().equals(eIterator.next())) {
                    failed = true;
                }
            }

            if (aIterator.hasNext() != eIterator.hasNext()) {
                throw new TestFailedException("List lengths different! Received \"" + TestUtils.iterableToString(actual) + "\" but expected \"" + TestUtils.iterableToString(expected) + "\"");
            }
        }

        if (failed) {
            throw new TestFailedException(
                    "List different! Received \"" + TestUtils.iterableToString(actual) + "\", expected \"" + TestUtils.iterableToString(expected) + "\"");
        }

    }

    public static void assertEqual(List<String> actual, List<String> expected) throws TestFailedException {
        boolean failed = false;

        if (actual == null || expected == null || actual.size() != expected.size()) {
            failed = actual == expected;
        } else {
            for (int i = 0; i < expected.size(); i++) {
                if (expected.get(i) == null) {
                    failed = actual.get(i) != null;

                } else {
                    failed = !actual.get(i).equals(expected.get(i));

                }
                if (failed) break;
            }
        }

        if (failed) {
            throw new TestFailedException(
                    "List Different! Received \"" + actual + "\", expected \"" + expected + "\"");
        }
    }

    /**
     * Detects if the given integers are not equal.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(int actual, int expected) throws TestFailedException {
        boolean failed = (actual != expected);
        if (failed) {
            throw new TestFailedException("Integer value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given doubles are not within 1.0e-6 of one another.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(double actual, double expected) throws TestFailedException {
        final double ALLOWABLE_ERROR = 0.000001;

        boolean failed = (Math.abs(actual - expected) > ALLOWABLE_ERROR);

        if (failed) {
            throw new TestFailedException("Double value difference: \n\tReceived " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given booleans do not have equal values.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(boolean actual, boolean expected) throws TestFailedException {
        boolean failed = (actual != expected);

        if (failed) {
            throw new TestFailedException("Boolean value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given objects are equal by their .equals() methods. By default, this method will also test
     * for symmetry.
     *
     * @param expected Whether or not these two objects should be equal by their .equals() methods
     * @param obj1 The first object to compare.
     * @param obj2 The second object to compare.
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(boolean expected, Object obj1, Object obj2) throws TestFailedException {
        boolean actual = obj1.equals(obj2);
        if (actual != expected) {
            throw new TestFailedException("Boolean value difference with .equals() method. When comparing\n\"" + obj1.toString() + "\" with \"" + obj2.toString() + "\", Received " + actual + ", expected " + expected);
        }

        if (actual != obj2.equals(obj1)) {
            throw new TestFailedException("Asymmetry detected! When comparing \"" + obj1.toString() + "\" with \"" + obj2.toString() + "\", Received " + actual + ". But when calling .equals() the other way, received " + !actual);
        }
    }

    /**
     * Tests the given code for a particular type of Exception.
     * @param exceptionType The class of the expected Exception.
     * @param codeThatThrowsException Runnable code that is intended to throw an exceptino of type exceptionType. Must NOT throw a TestFailedException
     * @throws TestFailedException
     */
    public static void testForException(Class<? extends Exception> exceptionType, Runnable codeThatThrowsException) throws TestFailedException {
        try {
            codeThatThrowsException.run();
            throw new TestFailedException(exceptionType.getSimpleName() + " did NOT occur when it was supposed to!");
        } catch (Exception e) {
            if (e.getClass() == exceptionType) {
                if (e.getMessage() == null || e.getMessage().isBlank()) {
                    throw new TestFailedException("Make sure you're setting a descriptive message for your " + e.getClass().getSimpleName() + "!");
                }
                // Test passed! Finish running method and return to the invoker
            } else if (e.getClass() == TestFailedException.class && e.getMessage().contains("did NOT occur")) {

                throw new TestFailedException("No exception occurred! The code should have thrown a " + exceptionType.getSimpleName());

            } else {

                throw new TestFailedException("Exception class difference! Received " + e.getClass().getSimpleName() + " but expected " + exceptionType.getSimpleName() + "."
                    + "\nFull stack trace:\n" + StringUtils.stackTraceToString(e));

            }
        }
    }

    /**
     * Tester for String inputs. Takes in a String -> String function, and compares the output with the desired output.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @param inputs The StringInput values to test.
     * @throws TestFailedException
     */
    public static void testStringInputs(String actual, TestUtils.StringFunction codeToRun, TestUtils.StringInput[] inputs) throws TestFailedException {

        for (TestUtils.StringInput stringInput : inputs) {
            try {
                assertEqual(actual, codeToRun.run(stringInput.getStringValue()));
            } catch (TestFailedException tfe) {
                throw new TestFailedException("When inputted string is " + stringInput.toString() + ": " + tfe.getMessage());
            }
        }

    }

    /**
     * Convenience method that calls testStringInputs(String, StringFunction, StringInput[]) for ALL
     * values of the StringFunction enum.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @throws TestFailedException
     */
    public static void testStringInputs(String actual, TestUtils.StringFunction codeToRun) throws TestFailedException {
        testStringInputs(actual, codeToRun, TestUtils.StringInput.values());
    }

    /**
     * Tester for String inputs. Takes in a String -> String function, and compares the output with the desired output.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @param inputs The StringInput values to test.
     * @throws TestFailedException
     */
    public static void testStringInputsForException(Class<? extends Exception> exceptionType, Consumer<String> codeToRun, TestUtils.StringInput... inputs) throws TestFailedException {

        for (TestUtils.StringInput stringInput : inputs) {
            try {
                testForException(exceptionType, () -> codeToRun.accept(stringInput.getStringValue()));
            } catch (TestFailedException tfe) {
                throw new TestFailedException("When inputted string is " + stringInput.toString() + ": " + tfe.getMessage());
            }
        }

    }

    /**
     * Convenience method that calls testStringInputs(String, StringFunction, StringInput[]) for ALL
     * values of the StringFunction enum.
     * @param actual The expected String output of the runnable function.
     * @param codeToRun A runnable function that takes in a String and outputs a String.
     * @throws TestFailedException
     */
    public static void testStringInputsForException(Class<? extends Exception> exceptionType, Consumer<String> codeToRun) throws TestFailedException {
        testStringInputsForException(exceptionType, codeToRun, TestUtils.StringInput.values());
    }

    /**
     * Prints an error message
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException If the test fails
     */
    public static void failTest(String errorMessage) throws TestFailedException {
        throw new TestFailedException("An error occurred: " + errorMessage);
    }

}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/testing/TestContainer.java




/**
 * Represents a Runnable that can be thrown into a ThreadPoolExecutor. The
 * TestContainer will latch onto a Class<?> and attempt to run any methods
 * labeled as test functions, e.g. @TestCase or @BeforeTest
 */
class TestContainer implements Runnable {
    /**
     * The class belonging to the TestContainer
     */
    private Class<?> clazz;

    /**
     * As the methods are non-static, there must be an instance all share when
     * executing the methods. At the start of the test a single instance is
     * initialized for all tests to use.
     */
    private Object instance = null;

    /**
     * Initializes a new TestContainer. A TestContainer is used to prevent certain
     * edge cases such as infinite loops.
     * 
     * If an infinite loop occurs, the test will timeout and notify the user
     * accordingly.
     * 
     * @param clazz The class containing the tests
     */
    public TestContainer(Class<?> clazz) {
        this.clazz = clazz;
    }

    /**
     * Executes a method belonging to this instance.
     * This is used when cycling over the methods marked with @BeforeTest
     * and @AfterTest, as both require the same invocation logic.
     * 
     * @param method The method to execute
     */
    private void executeFunction(Method method) {
        try {
            method.invoke(instance);
        } catch (Exception e) {
            System.out.println(ColorUtils.formatColorString(AsciiColorCode.WHITE_BACKGROUND,
                    AsciiColorCode.RED_FOREGROUND,
                    "\tThe executed code caused the following exception."));

            e.getCause().printStackTrace();
        }
    }

    /**
     * Attempts to execute a TestCase found within the TestContainer.
     * 
     * @param tuple A Tuple<Method, TestCase> containing the method to run, and the
     *              TestCase associated with it. These are wrapped into a Tuple to
     *              avoid having to call getAnnotation twice.
     * @return true if the test case was successful
     */
    private boolean executeTestCase(Tuple<Method, TestCase> tuple) {
        Method m = tuple.first;
        TestCase testCase = tuple.second;
        Tip tip = m.getAnnotation(Tip.class);

        try {

            m.invoke(instance);

            System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_GREEN_BACKGROUND,
                    AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " PASSED \u00BB ") + " "
                    + testCase.name());
        } catch (InvocationTargetException e) {
            System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                    AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " FAILED \u00BB ") + " "
                    + testCase.name());

            if (e.getCause() instanceof TestFailedException) {
                TestFailedException tfe = (TestFailedException) e.getCause();

                System.out.println(StringUtils.formatIndented(tfe.getMessage()));

                } else if (e.getCause() instanceof StackOverflowError) {
                e.printStackTrace();
                
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.WHITE_BACKGROUND,
                        AsciiColorCode.RED_FOREGROUND,
                        "\tYour code resulted in a StackOverflowError. This is almost certainly because of a recursive method stuck in an infinite loop."));

            } else {
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.WHITE_BACKGROUND,
                        AsciiColorCode.RED_FOREGROUND,
                        "\tThe executed code caused the following exception. This is NOT the fault of the driver."));

                e.getCause().printStackTrace();
            }

            if (tip != null)
                    System.out.print(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_WHITE_BACKGROUND,
                            AsciiColorCode.BLACK_FOREGROUND, StringUtils.formatIndented(String.format("%s\n", "HINT: " + tip.description()))));
            

            return false;
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
        }

        return true;
    }

    @Override
    public void run() {
        try {
            TestManager.printTestCategory(clazz.getName());

            instance = clazz.getDeclaredConstructor().newInstance();

            int classTests = 0;
            int classTestsFailed = 0;

            // TODO: Likely move this to a more abstract system
            List<Tuple<Method, BeforeTest>> beforeTest = new ArrayList<>();
            List<Tuple<Method, AfterTest>> afterTest = new ArrayList<>();
            List<Tuple<Method, TestCase>> testMethods = new ArrayList<>();

            for (Method m : clazz.getMethods()) {
                TestCase testAnnotation = m.getAnnotation(TestCase.class);
                BeforeTest beforeTestAnnotation = m.getAnnotation(BeforeTest.class);
                AfterTest afterTestAnnotation = m.getAnnotation(AfterTest.class);

                if (testAnnotation != null) {
                    testMethods.add(new Tuple<Method, TestCase>(m, testAnnotation));
                } else if (beforeTestAnnotation != null) {
                    beforeTest.add(new Tuple<Method, BeforeTest>(m, beforeTestAnnotation));
                } else if (afterTestAnnotation != null) {
                    afterTest.add(new Tuple<Method, AfterTest>(m, afterTestAnnotation));
                }
            }

            for (Tuple<Method, TestCase> tuple : testMethods) {

                for (Tuple<Method, BeforeTest> beforeTuple : beforeTest) {
                    executeFunction(beforeTuple.first);
                }

                boolean result = executeTestCase(tuple);

                classTests++;

                if (!result)
                    classTestsFailed++;
            }

            for (Tuple<Method, AfterTest> tuple : afterTest) {
                executeFunction(tuple.first);
            }

            TestManager.classTests.set(TestManager.classTests.get() + classTests);
            TestManager.classTestsFailed.set(TestManager.classTestsFailed.get() + classTestsFailed);

            System.out.println();
            StringUtils.printTextCentered(
                    String.format("TESTS PASSED: %d/%d", classTests - classTestsFailed, classTests));

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
//AUTOGENERATED FROM ../src/com/cs1331/drivers/testing/TestManager.java


class TestManager {
    protected volatile static AtomicInteger classTests = new AtomicInteger();
    protected volatile static AtomicInteger classTestsFailed = new AtomicInteger();

    private static List<String> filter;

    /**
     * A list of the currently registered classes to test
     */
    private static final List<Class<?>> testClazzes = new ArrayList<>();

    /**
     * A list of the currently registered data classes
     */
    private static final List<Class<?>> dataClazzes = new ArrayList<>();

    /**
     * When this method is called, the TestManager will run all tests in the given
     * classes.
     * 
     * @param classes The classes to test.
     */
    public static void runTestsOn(Class<?>... classes) {
        for (Class<?> currentClass : classes) {
            registerClass(currentClass);
        }

        executeTests();
    }

    public static void registerDataClasses(Class<?>... classes) {
        for (Class<?> clazz : classes) {
            registerDataClass(clazz);
        }
    }

    /**
     * Registers and marks test class to be scanned during test execution.
     * 
     * @param clazz The input class
     */
    public static void registerClass(Class<?> clazz) {
        if (filter.isEmpty() || filter.stream().anyMatch(s -> s.equals(clazz.getName()))) {
            testClazzes.add(clazz);
        }
    }

    public static void registerDataClass(Class<?> clazz) {
        dataClazzes.add(clazz);
    }

    /**
     * Executes all registered tests.
     */
    public static void executeTests() {
        injectData();

        ExecutorService executor = Executors.newFixedThreadPool(1);

        List<Runnable> runnables = new ArrayList<>();

        for (Class<?> testClass : testClazzes) {
            runnables.add(new TestContainer(testClass));
        }

        for (Runnable r : runnables) {
            Future<?> future = executor.submit(r);

            try {
                future.get(10, TimeUnit.SECONDS);
            } catch (InterruptedException ignored) {

            } catch (ExecutionException e) {
                e.getCause().printStackTrace();
            } catch (TimeoutException e) {
                future.cancel(true);

                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                        AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " FAILED \u00BB ")
                        + " A test failed by exceeding the time limit. You likely have an infinite loop somewhere.");

                System.exit(-1);
            }

        }

        executor.shutdown();

        StringUtils.printHorizontalLine();

        StringUtils.printTextCentered("Test Results");
        System.out.println();
        StringUtils.printTextCentered(
                String.format("TOTAL TESTS PASSED: %d/%d", classTests.get() - classTestsFailed.get(),
                        classTests.get()));
        StringUtils.printHorizontalLine();

    }

    private static void injectData() {

        for (Class<?> dataClass : dataClazzes) {
            for (Field f : dataClass.getFields()) {
                InjectData injectAnnotation = f.getAnnotation(InjectData.class);

                if (injectAnnotation != null) {
                    Scanner scanner = null;

                    StringBuilder output = new StringBuilder();

                    try {
                        scanner = new Scanner(new File(injectAnnotation.name()));

                        while (scanner.hasNextLine()) {
                            output.append(scanner.nextLine()).append("\n");
                        }
                    } catch (FileNotFoundException e) {
                        System.out.println("COULDN'T FIND INJECT DATA FILE " + injectAnnotation.name());
                        System.exit(-1);
                    } finally {
                        if (scanner != null) {
                            scanner.close();
                        }
                    }

                    // Inject data into variable
                    f.setAccessible(true);

                    try {
                        // Set private static final
                        f.set(null, output.toString());
                    } catch (Exception e) {
                        e.printStackTrace();
                        System.exit(-1);
                    }

                }
            }
        }
    }

    /**
     * Prints a formatted test category section
     * 
     * @param category The name of the section (most likely the class name)
     */
    protected static void printTestCategory(String category) {
        StringUtils.printHorizontalLine();
        StringUtils.printTextCentered(category);
        System.out.println();
    }


    /**
     * Sets a filter to determine what test class files can be run.
     * This is primarily used in the CLI options.
     * @param filter The filter of classes
     */
    public static void setTestFilter(List<String> filter) {
        TestManager.filter = filter;
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/io/IOHijacker.java

/**
 * A helper class used for redirecting System.out to check against
 */
class IOHijacker {
    private static IOHijacker INSTANCE;

    private String log = "";
    private PrintStream originalStream;
    private PrintStream redirectedStream;
    private boolean recording = false;

    private IOHijacker() {
        this.originalStream = System.out;
    }

    /**
     * Starts recording all System.out messages to the console and stores them in
     * IOHijacker.log.
     * 
     * Until stopRecording is called, no System.out messages will appear.
     */
    public void startRecording() {
        log = "";

        if (redirectedStream == null)
            redirectedStream = getRedirectedStream();

        System.setOut(redirectedStream);

        recording = true;
    }

    /**
     * Stops the current recording, resetting System.out to its default behavior.
     * 
     * @return A list of all messages sent during the recording
     */
    public String stopRecording() {
        recording = false;

        System.setOut(originalStream);

        return log;
    }

    /**
     * Retrieves the current log of messages in a recording
     * 
     * @return The current log of messages
     */
    public String getCurrentLog() {
        return log;
    }

    /**
     * Retrieves a custom PrintStream that redirects print to instead logMessage
     * 
     * @return The custom PrintStream
     */
    private PrintStream getRedirectedStream() {
        return new PrintStream(System.out, true) {
            @Override
            public void print(String s) {
                IOHijacker.appendMessage(s);
            }

            @Override
            public PrintStream printf(String message, Object... args) {
                IOHijacker.appendMessage(String.format(message, args));
                return this;
            }

            @Override
            public void println(String s) {
                IOHijacker.appendMessage(s + "\n");
            }

        };
    }

    /**
     * Returns the Singleton's instance, creating one if it doesn't exist.
     * 
     * @return The IOHijacker instance
     */
    public static IOHijacker getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new IOHijacker();
        }

        return INSTANCE;
    }

    /**
     * Appends a string message to the log ONLY if recording.
     * 
     * @param message The message to be recorded
     */
    private static void appendMessage(String message) {
        IOHijacker instance = getInstance();

        if (!instance.recording)
            return;

        instance.log += message.replaceAll("\r","");
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/exception/TestFailedException.java
/**
 * A custom exception used for detecting tests failed.
 */
class TestFailedException extends Exception {
    public TestFailedException() {
    }

    public TestFailedException(String message) {
        super(message);
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/utils/AsciiColorCode.java

final class AsciiColorCode {

    public static final String RESET_COLOR = "\033[0m";

    public static final String BLACK_FOREGROUND = "\033[30m";
    public static final String BLACK_BACKGROUND = "\033[40m";

    public static final String RED_FOREGROUND = "\033[31m";
    public static final String RED_BACKGROUND = "\033[41m";

    public static final String GREEN_FOREGROUND = "\033[32m";
    public static final String GREEN_BACKGROUND = "\033[42m";

    public static final String YELLOW_FOREGROUND = "\033[33m";
    public static final String YELLOW_BACKGROUND = "\033[43m";

    public static final String BLUE_FOREGROUND = "\033[34m";
    public static final String BLUE_BACKGROUND = "\033[44m";

    public static final String MAGENTA_FOREGROUND = "\033[35m";
    public static final String MAGENTA_BACKGROUND = "\033[45m";

    public static final String CYAN_FOREGROUND = "\033[36m";
    public static final String CYAN_BACKGROUND = "\033[46m";

    public static final String WHITE_FOREGROUND = "\033[37m";
    public static final String WHITE_BACKGROUND = "\033[47m";

    public static final String BRIGHT_BLACK_FOREGROUND = "\033[90m";
    public static final String BRIGHT_BLACK_BACKGROUND = "\033[100m";

    public static final String BRIGHT_RED_FOREGROUND = "\033[91m";
    public static final String BRIGHT_RED_BACKGROUND = "\033[101m";

    public static final String BRIGHT_GREEN_FOREGROUND = "\033[92m";
    public static final String BRIGHT_GREEN_BACKGROUND = "\033[102m";

    public static final String BRIGHT_YELLOW_FOREGROUND = "\033[93m";
    public static final String BRIGHT_YELLOW_BACKGROUND = "\033[103m";

    public static final String BRIGHT_BLUE_FOREGROUND = "\033[94m";
    public static final String BRIGHT_BLUE_BACKGROUND = "\033[104m";

    public static final String BRIGHT_MAGENTA_FOREGROUND = "\033[95m";
    public static final String BRIGHT_MAGENTA_BACKGROUND = "\033[105m";

    public static final String BRIGHT_CYAN_FOREGROUND = "\033[96m";
    public static final String BRIGHT_CYAN_BACKGROUND = "\033[106m";

    public static final String BRIGHT_WHITE_FOREGROUND = "\033[97m";
    public static final String BRIGHT_WHITE_BACKGROUND = "\033[107m";
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/utils/Tuple.java
/**
 * A generic class used for holding two values that might be related
 */
class Tuple<X, Y> {
    /**
     * The first element
     */
    final X first;

    /**
     * The second element
     */
    final Y second;

    /**
     * Constructs a new Tuple.
     * @param first The first element
     * @param second The second element
     */
    public Tuple(X first, Y second) {
        this.first = first;
        this.second = second;
    }
}
//AUTOGENERATED FROM ../src/com/cs1331/drivers/utils/TestUtils.java


class TestUtils {

    /**
     * Returns either 1, 0, or -1 depending on the sign of the input.
     * 
     * @param input the input number
     * @return -1 if input < 0, 0 if input = 0, 1 if input > 0
     */
    public static int signOf(int input) {
        if (input == 0) {
            return input;
        } else {
            return Math.abs(input) / input;
        }
    }

    /**
     * Utility method for taking in a list of strings and converting it into one string,
     * separated by newline characters.
     * @param printedMessages The messages to combine
     * @return The combined final string
     */
    public static String combinePrintStatements(List<String> printedMessages) {
        if (printedMessages == null || printedMessages.isEmpty()) {
            return "";
        }

        StringBuilder builder = new StringBuilder(printedMessages.get(0));
        for (int i = 1; i < printedMessages.size(); i++) {
            builder.append("\n");
            builder.append(printedMessages.get(i));
        }
        return builder.toString();
    }

    /**
     * Enum that contains "invalid" Strings.
     */
    enum StringInput {
        NULL(null),
        EMPTY(""),
        BLANK("   ");

        private final String stringValue;

        private StringInput(String stringValue) {
            this.stringValue = stringValue;
        }

        public String getStringValue() {
            return this.stringValue;
        }
    }

    /**
     * Interface to allow lambda function-like functionality with Strings
     */
    public interface StringFunction {
        String run(String str);
    }

    /**
     * Delete a file at a given path
     * @param path The file to delete
     */
    public static void deleteFile(String path) {
        File file = new File(path);

        try {
            Files.delete(file.toPath());
        } catch (FileSystemException e) {

            if (e.getMessage().contains("used by another process")) {
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_YELLOW_BACKGROUND,
                        AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " DELETE FILE ERROR: \u00BB ")
                        + " The program failed to delete " + file.getName() + ". Although this will not change the outcome of the tests, to solve this issue you must ensure ALL of your scanners have been properly closed, INCLUDING during an exception. This has only been recorded on Windows machines, but feel free to reach out if you encounter the issue!");

            }
        } catch (IOException ignored) {
        }
    }

    /**
     * Converts the given Iterable to String by calling the toString() method of each
     * element in the iterator, in the order given, with commas (but no spaces) between
     * each element.
     * @param iterable The Iterable object to be converted to String.
     * @return The combined String, in the aforementioned format.
     */
    public static String iterableToString(Iterable<?> iterable) {
        Iterator<?> iterator = iterable.iterator();
        if (!iterator.hasNext()) { // If the iterator is empty, then return nothing
            return "";
        }
        
        StringBuilder builder = new StringBuilder();
        builder.append(iterator.next().toString());
        
        while (iterator.hasNext()) {
            builder.append(",").append(iterator.next().toString());
        }

        return builder.toString();
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/utils/ColorUtils.java

class ColorUtils {
    /**
     * Formats a string to have an ASCII background in terminal.
     * 
     * @param background The ASCII representation of the background color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatBackgroundColorString(String background, String s) {
        return background + s + AsciiColorCode.RESET_COLOR;
    }

    /**
     * Formats a string to have an ASCII foreground (text color) in terminal.
     * 
     * @param foreground The ASCII representation of the foreground color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatForegroundColorString(String foreground, String s) {
        return foreground + s + AsciiColorCode.RESET_COLOR;

    }

    /**
     * Formats a string to have both an ASCII foreground and background in terminal
     * 
     * @param background The ASCII representation of the background color, pulled
     *                   from AsciiColorCode
     * @param foreground The ASCII representation of the foreground color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatColorString(String background, String foreground, String s) {
        return foreground + background + s.replace("\n", AsciiColorCode.RESET_COLOR + "\n" + foreground + background) + AsciiColorCode.RESET_COLOR;
    }
}

//AUTOGENERATED FROM ../src/com/cs1331/drivers/utils/StringUtils.java



class StringUtils {
    /**
     * The ASCII character to use for horizontal lines
     */
    public static final String HORIZONTAL_LINE_CHARACTER = "\u2500";

    /**
     * The amount of HORIZONTAL_LINE_CHARACTER elements to use in a line
     */
    public static final int HORIZONTAL_LINE_LENGTH = 64;

    /**
     * Prints a horizontal line to the terminal.
     */
    public static void printHorizontalLine() {
        System.out
                .println(String.format("%0" + HORIZONTAL_LINE_LENGTH + "d", 0).replace("0", HORIZONTAL_LINE_CHARACTER));
    }

    /**
     * Prints centered text to the terminal.
     * 
     * @param text The text to be centered
     */
    public static void printTextCentered(String text) {
        // HORIZONTAL_LINE_LENGTH is maximum width
        // if line is
        // xxxxxxxxxxxx
        // We can pad the start of the string with half of the horizontal:
        // xxxxxhelloxx
        // The problem is that this doesn't account for the length of the string.
        // We can add half of the string length as well to correct it:
        // xxxxhelloxxxx = CENTERED! (or at least as close as it can get)

        System.out.printf("%" + (HORIZONTAL_LINE_LENGTH / 2 + text.length() / 2) + "s%n", text);
    }

    /**
     * Utility for converting a Throwable to a stack trace string.
     * 
     * @param e Exception to print the stacktrace of
     * @return The formatted stack trace
     */
    public static String stackTraceToString(Throwable e) {
        StackTraceElement[] stackTrace = e.getStackTrace();

        if (stackTrace.length == 0) {
            return "No stack trace.";
        }

        StringBuilder sb = new StringBuilder(stackTrace[0].toString());
        for (int i = 1; i < stackTrace.length; i++) {
            sb.append("\n\t");
            sb.append(stackTrace[i].toString());
        }
        return sb.toString();
    }

    /**
     * Converts an arraylist into a readable string.
     * @param inputs the input arraylist
     * @return the arraylist as a string
     * @throws TestFailedException if the method was unable to convert the arraylist
     */
    public static String arrayListToString(ArrayList<?> inputs) throws TestFailedException {
        return arrayToString(inputs.toArray(), ",");
    }

    /**
     * Returns the Array as a String using the toString() method of each item.
     * The resulting String has an itemSeparator between each element.
     * @param inputs The Array to convert to String.
     * @param itemSeparator The String to put BETWEEN each item.
     * @return the array as a string
     */
    public static String arrayToString(Object[] inputs, String itemSeparator) throws TestFailedException {
        if (inputs.length == 0) {
            return "";
        }

        StringBuilder builder = new StringBuilder();

        for (Object input : inputs) {
            builder.append(input == null ? "null" : input.toString()).append(itemSeparator);
        }

        return builder.toString();
    }

    public static String arrayToString(Object[] inputs) throws TestFailedException {
        return arrayToString(inputs, ",");
    }

    /**
     * Reads the contents of a file and converts it into a string,
     * using \n as the delimiter.
     * @param path the path to the file
     * @return the file's contents as a string
     * @throws FileNotFoundException if the file cannot be found
     */
    public static String fileToString(String path) throws FileNotFoundException {
        Scanner scanner = new Scanner(new File(path));

        StringBuilder output = new StringBuilder();

        while (scanner.hasNextLine()) {
            String next = scanner.nextLine();

            output.append(next).append("\n");
        }

        scanner.close();

        return output.toString();
    }

    /**
     * Prints the given String to the file at the path.
     * THIS METHOD WILL OVERWRITE ANY DATA.
     * 
     * @param path Path to write at.
     * @param data Data to write to the file.
     * @throws FileNotFoundException if the file cannot be found
     */
    public static void stringToFile(String path, String data) throws FileNotFoundException {

        PrintWriter writer = new PrintWriter(path);

        writer.write(data);

        writer.close();

    }

    /**
     * Returns a modified version of 'actual', where the first character that
     * differs from 'expected' is highlighted RED.
     * 
     * @param actual   The 'actual' String
     * @param expected The 'expected' String to compare against
     * @return The string showing the color coded difference.
     */
    public static String getColorCodedDifference(String actual, String expected) {
        StringBuilder colored = new StringBuilder();
        for (int i = 0; i < actual.length(); i++) {
            char actualChar = actual.charAt(i);

            if (expected.length() <= i) {
                colored.append(actual.substring(i));
                break;
            }

            if (actualChar == expected.charAt(i)) {
                colored.append(actual.charAt(i));
            } else {
                colored.append(ColorUtils.formatColorString(AsciiColorCode.RED_BACKGROUND,
                        AsciiColorCode.WHITE_FOREGROUND, actualChar + ""));
                colored.append(actual.substring(i + 1));
                break;
            }

        }

        return colored.toString();

    }

    public static String formatIndented(String s) {

        String[] split = s.split("\n");

        StringBuilder output = new StringBuilder();

        for (int i = 0; i < split.length - 1; i++) {
            output.append(formatSingleLine(split[i])).append("\n");
        }

        output.append(formatSingleLine(split[split.length - 1]));

        return output + "\n";
    }

    private static String formatSingleLine(String s) {
        int currentLength = 0;

        StringBuilder builder = new StringBuilder("\t" + s);

        while (currentLength + HORIZONTAL_LINE_LENGTH < builder.length()
                && (currentLength = builder.indexOf(" ", currentLength + HORIZONTAL_LINE_LENGTH)) != -1) {
            
            builder.replace(currentLength, currentLength + 1, "\n\t");
        }

        return builder.toString();
    }
}
