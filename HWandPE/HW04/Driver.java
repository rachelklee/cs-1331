package HW04;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.List;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.io.PrintStream;
//AUTOGENERATED FROM ../src/TrickOrTreaterTests.java
class TrickOrTreaterTests {

    private static final String COMPARE_TO_METHOD_TIP = "What criteria should compareTo use to determine greater/less than? What order should these be compared?\n"
                                                        + "    Note: This test only checks the SIGN of compareTo, since the intended number is not specified.\n"
                                                        + "    1 means that compareTo() returned a positive number, -1 means a negative number, 0 means 0.";

    @TestCase(name = "Constructor: Valid inputs passed in.")
    @Tip(description = "Make sure there isn't any field shadowing in your constructor!")
    public void threeArgConstructor() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Yoon", 6, 70);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Yoon/6/70");
    }

    @TestCase(name = "Constructor: null name")
    @Tip(description = "What should invalid inputs default to?")
    public void constructorNullName() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Charlie Brown", 6, 70);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Charlie Brown/6/70");
    }

    @TestCase(name = "Constructor: empty name")
    @Tip(description = "What should invalid inputs default to?")
    public void constructorEmptyName() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("", 6, 70);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Charlie Brown/6/70");
    }

    @TestCase(name = "Constructor: blank name")
    @Tip(description = "What should invalid inputs default to?")
    public void constructorBlankName() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("  \n   ", 6, 70);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Charlie Brown/6/70");
    }

    @TestCase(name = "Age must be in the inclusive interval [0, 12]. What should an invalid age default to?")
    @Tip(description = "A negative age should default to 8!")
    public void threeArgConstructorNegativeAge() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Mark", -1, 40);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Mark/8/40");
    }

    @TestCase(name = "Constructor: age = 0")
    @Tip(description = "Age must be in the inclusive interval [0, 12]")
    public void threeArgConstructorZeroAge() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Rush", 0, 27);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Rush/0/27");
    }

    @TestCase(name = "Constructor: age = 12")
    @Tip(description = "Age must be in the inclusive interval [0, 12]")
    public void threeArgConstructorTwelveAge() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("John", 12, 34);
        String string = treater.toString();

        TestFunction.assertEqual(string, "John/12/34");
    }

    @TestCase(name = "Constructor: age = 13")
    @Tip(description = "Age must be in the inclusive interval [0, 12]. What should an invalid age default to?")
    public void threeArgConstructorThirteenAge() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Ara", 13, 40);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Ara/8/40");
    }

    @TestCase(name = "Constructor: numCandy = -1")
    @Tip(description = "TrickOrTreaters cannot have negative candy. What should a negative default to?")
    public void threeArgConstructorNegativeCandy() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Dipper", 12, -1);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Dipper/12/0");
    }

    @TestCase(name = "Constructor: numCandy = 0")
    @Tip(description = "numCandy may be equal to 0.")
    public void threeArgConstructorZeroCandy() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Mabel", 12, 0);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Mabel/12/0");
    }

    @TestCase(name = "gainCandy: add -1 candy")
    @Tip(description = "gainCandy cannot subtract candy from TrickOrTreaters!")
    public void gainCandyNegative() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Lindsay", 6, 70);
        treater.gainCandy(-1);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Lindsay/6/70");
    }

    @TestCase(name = "gainCandy: add 0 candy")
    @Tip(description = "Should the number of candy change?")
    public void gainCandyZero() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Elise", 6, 70);
        treater.gainCandy(0);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Elise/6/70");
    }

    @TestCase(name = "gainCandy: add 1 candy")
    @Tip(description = "How much candy should this TrickOrTreater gain?")
    public void gainCandyOne() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Tarini", 9, 70);
        treater.gainCandy(1);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Tarini/9/71");
    }

    @TestCase(name = "gainCandy: add 117 candy")
    @Tip(description = "How much candy should this TrickOrTreater gain?")
    public void gainCandyOneEighteen() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("NASA", 0, 1);
        treater.gainCandy(117);
        String string = treater.toString();

        TestFunction.assertEqual(string, "NASA/0/118");
    }

    @TestCase(name = "loseCandy: lose -1 candy")
    @Tip(description = "Can a TrickOrTreater lose negative candy?")
    public void loseCandyNegative() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Krit", 6, 70);
        treater.loseCandy(-1);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Krit/6/70");
    }

    @TestCase(name = "loseCandy: lose 0 candy")
    @Tip(description = "How much candy should this TrickOrTreater lose?")
    public void loseCandyZero() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Ansel", 6, 70);
        treater.loseCandy(0);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Ansel/6/70");
    }

    @TestCase(name = "loseCandy: lose 1 candy")
    @Tip(description = "How much candy should this TrickOrTreater lose?")
    public void loseCandyOne() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Spartan", 9, 72);
        treater.loseCandy(1);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Spartan/9/71");
    }

    @TestCase(name = "loseCandy: lose all candy")
    @Tip(description = "How much candy does this TrickOrTreater have to lose? Can a TrickOrTreater have zero candy?")
    public void loseCandyMaximumLoss() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Jim", 1, 10);
        treater.loseCandy(10);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Jim/1/0");
    }

    @TestCase(name = "loseCandy: lose more candy than available")
    @Tip(description = "How much candy does this TrickOrTreater have to lose? Can a TrickOrTreater have negative candy?")
    public void loseCandyTooMany() throws TestFailedException {

        TrickOrTreater treater = new TrickOrTreaterSubclass("Bob", 1, 10);
        treater.loseCandy(11);
        String string = treater.toString();

        TestFunction.assertEqual(string, "Bob/1/0");
    }

    @TestCase(name = "compareTo: other has greater candy, smaller age")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToGreaterSmaller() throws TestFailedException {

        TrickOrTreater treater1 = new TrickOrTreaterSubclass("Coke", 2, 9);
        TrickOrTreater treater2 = new TrickOrTreaterSubclass("Pepsi", 1, 10);
        int result = TestUtils.signOf(treater1.compareTo(treater2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has greater candy, equal age")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToGreaterEqual() throws TestFailedException {

        TrickOrTreater treater1 = new TrickOrTreaterSubclass("Coke", 1, 9);
        TrickOrTreater treater2 = new TrickOrTreaterSubclass("Pepsi", 1, 10);
        int result = TestUtils.signOf(treater1.compareTo(treater2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has greater candy, greater age")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToGreaterGreater() throws TestFailedException {

        TrickOrTreater treater1 = new TrickOrTreaterSubclass("Coke", 1, 9);
        TrickOrTreater treater2 = new TrickOrTreaterSubclass("Pepsi", 2, 10);
        int result = TestUtils.signOf(treater1.compareTo(treater2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has equal candy, smaller age")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualSmaller() throws TestFailedException {

        TrickOrTreater treater1 = new TrickOrTreaterSubclass("Coke", 2, 10);
        TrickOrTreater treater2 = new TrickOrTreaterSubclass("Pepsi", 1, 10);
        int result = TestUtils.signOf(treater1.compareTo(treater2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has equal candy, equal age")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualEqual() throws TestFailedException {

        TrickOrTreater treater1 = new TrickOrTreaterSubclass("Coke", 1, 10);
        TrickOrTreater treater2 = new TrickOrTreaterSubclass("Pepsi", 1, 10);
        int result = TestUtils.signOf(treater1.compareTo(treater2));

        TestFunction.assertEqual(result, 0);
    }

    @TestCase(name = "compareTo: other has equal candy, greater age")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualGreater() throws TestFailedException {

        TrickOrTreater treater1 = new TrickOrTreaterSubclass("Coke", 1, 10);
        TrickOrTreater treater2 = new TrickOrTreaterSubclass("Pepsi", 2, 10);
        int result = TestUtils.signOf(treater1.compareTo(treater2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has fewer candy, smaller age")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToSmallerSmaller() throws TestFailedException {

        TrickOrTreater treater1 = new TrickOrTreaterSubclass("Coke", 2, 10);
        TrickOrTreater treater2 = new TrickOrTreaterSubclass("Pepsi", 1, 9);
        int result = TestUtils.signOf(treater1.compareTo(treater2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has fewer candy, equal age")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToSmallerEqual() throws TestFailedException {

        TrickOrTreater treater1 = new TrickOrTreaterSubclass("Coke", 1, 10);
        TrickOrTreater treater2 = new TrickOrTreaterSubclass("Pepsi", 1, 9);
        int result = TestUtils.signOf(treater1.compareTo(treater2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has fewer candy, greater age")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToSmallerGreater() throws TestFailedException {

        TrickOrTreater treater1 = new TrickOrTreaterSubclass("Coke", 1, 10);
        TrickOrTreater treater2 = new TrickOrTreaterSubclass("Pepsi", 2, 9);
        int result = TestUtils.signOf(treater1.compareTo(treater2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: transitivity check...")
    @Tip(description = "Read the Java 11 compareTo() documentation for info on transitivity.\n"
               + "\t      If x.compareTo(y) > 0 and y.compareTo(z) > 0, then x.compareTo(z) MUST be > 0.\n"
               + "\t      This method checks MANY combinations of ages and numCandys for transitivity.\n")
    public void compareToTransitivity() throws TestFailedException {

        String trickOrTreaterX, trickOrTreaterY, trickOrTreaterZ;
        
        TrickOrTreaterSubclass[] possibleX = getAllTrickOrTreatersOnInterval("Xander", 0, 12, 0, 50);
        TrickOrTreaterSubclass[] possibleY = getAllTrickOrTreatersOnInterval("Yang", 0, 12, 0, 50);
        TrickOrTreaterSubclass[] possibleZ = getAllTrickOrTreatersOnInterval("Zan", 0, 12, 0, 50);

        for (TrickOrTreaterSubclass totOne : possibleX) {
            for (TrickOrTreaterSubclass totTwo : possibleY) {
                for (TrickOrTreaterSubclass totThree : possibleZ) {
                    if (totOne.compareTo(totTwo) > 0 && totTwo.compareTo(totThree) > 0 && totOne.compareTo(totThree) <= 0) { // This comes directly from the compareTo docs
                        trickOrTreaterX = totOne.toString();
                        trickOrTreaterY = totTwo.toString();
                        trickOrTreaterZ = totThree.toString();
                        System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                                AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " TRANSITIVITY TEST FAILED: \u00BB ") + "\nWhen "
                                + "x = \"" + trickOrTreaterX + "\", y = \"" + trickOrTreaterY + "\", z = \"" + trickOrTreaterZ + "\"");
                        TestFunction.assertEqual(totOne.compareTo(totThree), 1);
                    }
                }
            }
        }
    }

    @TestCase(name = "compareTo: extra compareTo() condition...")
    @Tip(description = "Read the Java 11 compareTo() documentation for the compareTo() condition.\n"
               + "\t      If x.compareTo(y) == 0, then sgn(x.compareTo(z)) must equal sgn(y.compareTo(z)).\n"
               + "\t      This method checks MANY combinations of ages and numCandys for transitivity.\n")
    public void compareThirdCondition() throws TestFailedException {
        String trickOrTreaterX = "", trickOrTreaterY = "", trickOrTreaterZ = "";
        
        TrickOrTreaterSubclass[] possibleX = getAllTrickOrTreatersOnInterval("Xander", 0, 12, 0, 50);
        TrickOrTreaterSubclass[] possibleY = getAllTrickOrTreatersOnInterval("Yang", 0, 12, 0, 50);
        TrickOrTreaterSubclass[] possibleZ = getAllTrickOrTreatersOnInterval("Zan", 0, 12, 0, 50);

        for (TrickOrTreaterSubclass totOne : possibleX) {
            for (TrickOrTreaterSubclass totTwo : possibleY) {
                for (TrickOrTreaterSubclass totThree : possibleZ) {
                    if (totOne.compareTo(totTwo) == 0 && TestUtils.signOf(totOne.compareTo(totThree)) != TestUtils.signOf(totTwo.compareTo(totThree))) {
                        trickOrTreaterX = totOne.toString();
                        trickOrTreaterY = totTwo.toString();
                        trickOrTreaterZ = totThree.toString();
                        System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                                AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " THIRD COMPARETO() CONDITION FAILED: \u00BB ") + "\nWhen "
                                + "x = \"" + trickOrTreaterX + "\", y = \"" + trickOrTreaterY + "\", z = \"" + trickOrTreaterZ + "\"");
                        TestFunction.assertEqual(0, 1);
                    }
                }
            }
        }
    }

    /**
     * Helper method to retrieve all possible TrickOrTreaters on the given intervals (inclusive).
     * @param name The name of all of the TrickOrTreaters
     * @param minAge Min age, inclusive.
     * @param maxAge Max age, inclusive.
     * @param minCandy Min candy, inclusive.
     * @param maxCandy Max candy, inclusive.
     * @return An array containing all possible trick or treaters on the interval.
     */
    private TrickOrTreaterSubclass[] getAllTrickOrTreatersOnInterval(String name, int minAge, int maxAge, int minCandy, int maxCandy) {
        TrickOrTreaterSubclass[] combos = new TrickOrTreaterSubclass[(maxAge + 1 - minAge) * (maxCandy + 1 - minCandy)];
        int index = 0;
        for (int i = minAge; i <= maxAge; i++) {
            for (int j = minCandy; j <= maxCandy; j++) {
                combos[index] = new TrickOrTreaterSubclass(name, i, j);
                index++;
            }
        }
        return combos;
    }

    /**
     * Placeholder subclass to force-call TrickOrTreater's methods
     */
    static class TrickOrTreaterSubclass extends TrickOrTreater {

        public TrickOrTreaterSubclass(String name, int age, int numCandy) {
            super(name, age, numCandy);
        }

        @Override
        public void trickOrTreat() {
        }

    }
}

//AUTOGENERATED FROM ../src/TestCase.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
@interface TestCase {
    /**
     * The name of the TestCase, used for describing what a test might be doing
     * 
     * @return The name of the TestCase
     */
    public String name() default "UNNAMED_TEST";
}

//AUTOGENERATED FROM ../src/TestFunction.java

class TestFunction {
    /**
     * Detects if the given Strings do not have the same content (case-sensitive)
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(String actual, String expected) throws TestFailedException {
        boolean failed = false;

        if (actual == null) {
            failed = expected == null;
        } else {

            if (!actual.replaceAll("\n", System.lineSeparator()).equals(expected.replaceAll("\n", System.lineSeparator()))) {
                failed = true;
            }
        }

        if (failed) {
            
            String actualString = "\"" + actual + "\" ";
            String expectedString = "\"" + expected + "\"";
            
            if (actual.trim().contains("\n")) {
                actualString = "\n\"" + actual + "\"\n";
            }
            if (expected.trim().contains("\n")) {
                expectedString = "\n\"" + expected + "\"\n";
            }

            throw new TestFailedException(
                    "Strings different! Received " + actualString + "but expected " + expectedString);
        }
    }

    public static void assertEqual(List<String> actual, List<String> expected) throws TestFailedException {
        boolean failed = false;

        if (actual == null || expected == null || actual.size() != expected.size()) {
            failed = actual == expected;
        } else {
            for (int i = 0; i < expected.size(); i++) {
                if (expected.get(i) == null) {
                    failed = actual.get(i) != null;

                } else {
                    failed = !actual.get(i).equals(expected.get(i));

                }
                if (failed) break;
            }
        }

        if (failed) {
            throw new TestFailedException(
                    "List Different! Received \"" + actual + "\", expected \"" + expected + "\"");
        }
    }

    /**
     * Detects if the given integers are not equal.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(int actual, int expected) throws TestFailedException {
        boolean failed = (actual != expected);
        if (failed) {
            throw new TestFailedException("Integer value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given doubles are not within 1.0e-6 of one another.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(double actual, double expected) throws TestFailedException {
        final double ALLOWABLE_ERROR = 0.000001;

        boolean failed = (Math.abs(actual - expected) > ALLOWABLE_ERROR);

        if (failed) {
            throw new TestFailedException("Double value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given booleans do not have equal values.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(boolean actual, boolean expected) throws TestFailedException {
        boolean failed = (actual != expected);

        if (failed) {
            throw new TestFailedException("Boolean value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given Exceptions are the same TYPE, not if they are caused by
     * the same thing. Any two
     * NullPointerExceptions will, when passed into this function, return true, even
     * if they are caused by
     * two unrelated issues.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException If the test fails
     */
    public static void assertEqual(Exception actual, Exception expected) throws TestFailedException {
        boolean failed = (actual.getCause().getClass() != expected.getCause().getClass());

        if (failed) {
            throw new TestFailedException("Exception class difference: Received " + actual.getCause().getClass()
                    + ", but expected " + expected.getCause().getClass());
        }
    }
}

//AUTOGENERATED FROM ../src/AsciiColorCode.java
final class AsciiColorCode {

    public static final String RESET_COLOR = "\033[0m";

    public static final String BLACK_FOREGROUND = "\033[30m";
    public static final String BLACK_BACKGROUND = "\033[40m";

    public static final String RED_FOREGROUND = "\033[31m";
    public static final String RED_BACKGROUND = "\033[41m";

    public static final String GREEN_FOREGROUND = "\033[32m";
    public static final String GREEN_BACKGROUND = "\033[42m";

    public static final String YELLOW_FOREGROUND = "\033[33m";
    public static final String YELLOW_BACKGROUND = "\033[43m";

    public static final String BLUE_FOREGROUND = "\033[34m";
    public static final String BLUE_BACKGROUND = "\033[44m";

    public static final String MAGENTA_FOREGROUND = "\033[35m";
    public static final String MAGENTA_BACKGROUND = "\033[45m";

    public static final String CYAN_FOREGROUND = "\033[36m";
    public static final String CYAN_BACKGROUND = "\033[46m";

    public static final String WHITE_FOREGROUND = "\033[37m";
    public static final String WHITE_BACKGROUND = "\033[47m";

    public static final String BRIHGT_BLACK_FOREGROUND = "\033[90m";
    public static final String BRIGHT_BLACK_BACKGROUND = "\033[100m";

    public static final String BRIGHT_RED_FOREGROUND = "\033[91m";
    public static final String BRIGHT_RED_BACKGROUND = "\033[101m";

    public static final String BRIGHT_GREEN_FOREGROUND = "\033[92m";
    public static final String BRIGHT_GREEN_BACKGROUND = "\033[102m";

    public static final String BRIGHT_YELLOW_FOREGROUND = "\033[93m";
    public static final String BRIGHT_YELLOW_BACKGROUND = "\033[103m";

    public static final String BRIGHT_BLUE_FOREGROUND = "\033[94m";
    public static final String BRIGHT_BLUE_BACKGROUND = "\033[104m";

    public static final String BRIGHT_MAGENTA_FOREGROUND = "\033[95m";
    public static final String BRIGHT_MAGENTA_BACKGROUND = "\033[105m";

    public static final String BRIGHT_CYAN_FOREGROUND = "\033[96m";
    public static final String BRIGHT_CYAN_BACKGROUND = "\033[106m";

    public static final String BRIGHT_WHITE_FOREGROUND = "\033[97m";
    public static final String BRIGHT_WHITE_BACKGROUND = "\033[107m";
}

//AUTOGENERATED FROM ../src/StringUtils.java
class StringUtils {
    /**
     * The ASCII character to use for horizontal lines
     */
    public static final String HORIZONTAL_LINE_CHARACTER = "\u2500";

    /**
     * The amount of HORIZONTAL_LINE_CHARACTER elements to use in a line
     */
    public static final int HORIZONTAL_LINE_LENGTH = 48;

    /**
     * Prints a horizontal line to the terminal.
     */
    public static void printHorizontalLine() {
        System.out
                .println(String.format("%0" + HORIZONTAL_LINE_LENGTH + "d", 0).replace("0", HORIZONTAL_LINE_CHARACTER));
    }

    /**
     * Prints centered text to the terminal.
     * 
     * @param text The text to be centered
     */
    public static void printTextCentered(String text) {
        // HORIZONTAL_LINE_LENGTH is maximum width
        // if line is
        // xxxxxxxxxxxx
        // We can pad the start of the string with half of the horizontal:
        // xxxxxhelloxx
        // The problem is that this doesn't account for the length of the string.
        // We can add half of the string length as well to correct it:
        // xxxxhelloxxxx = CENTERED! (or at least as close as it can get)

        System.out.printf("%" + (HORIZONTAL_LINE_LENGTH / 2 + text.length() / 2) + "s%n", text);
    }
}

//AUTOGENERATED FROM ../src/TestUtils.java

class TestUtils {
    /**
     * Returns either 1, 0, or -1 depending on the sign of the input.
     * 
     * @param input
     * @return -1 if input < 0, 0 if input = 0, 1 if input > 0
     */
    public static int signOf(int input) {
        if (input == 0) {
            return input;
        } else {
            return Math.abs(input) / input;
        }
    }

    public static String combinePrintStatements(List<String> printedMessages) {
        if (printedMessages == null || printedMessages.size() == 0) {
            return "";
        }

        StringBuilder builder = new StringBuilder(printedMessages.get(0));
        for (int i = 1; i < printedMessages.size(); i++) {
            builder.append("\n");
            builder.append(printedMessages.get(i));
        }
        return builder.toString();
    }
}

//AUTOGENERATED FROM ../src/Tip.java

@Retention(RetentionPolicy.RUNTIME)
@interface Tip {
    /**
     * Used to display a helpful tip when the user fails a test.
     * 
     * @return The main tip body message
     */
    public String description() default "";
}

//AUTOGENERATED FROM ../src/WitchTests.java
class WitchTests {
    private static final String COMPARE_TO_METHOD_TIP = "What criteria should compareTo use to determine greater/less than? What order should these be compared?\n"
                                                        + "    Note: This test only checks the SIGN of compareTo, since the intended number is not specified.\n"
                                                        + "    1 means that compareTo() returned a positive number, -1 means a negative number, 0 means 0.";

    @TestCase(name = "Constructor: Valid inputs passed in (this test does not check cackle)")
    @Tip(description = "Make sure there isn't any field shadowing in your constructor!")
    public void constructorFourArgs() throws TestFailedException {

        Witch ghost = new Witch("Yoon", 6, 70, "Wahoo!");
        String string = ghost.toString();

        TestFunction.assertEqual(string, "Yoon/6/70");
    }

    @TestCase(name = "Constructor: null name (this test does not check cackle)")
    @Tip(description = "What is a valid input for name? What should it default to?")
    public void constructorNullName() throws TestFailedException {

        Witch ghost = new Witch(null, 6, 70, "Wahoo!");
        String string = ghost.toString();

        TestFunction.assertEqual(string, "Charlie Brown/6/70");
    }

    @TestCase(name = "Constructor: empty name (this test does not check cackle)")
    @Tip(description = "What is a valid input for name? What should it default to?")
    public void constructorEmptyName() throws TestFailedException {

        Witch ghost = new Witch("", 6, 70, "Wahoo!");
        String string = ghost.toString();

        TestFunction.assertEqual(string, "Charlie Brown/6/70");
    }

    @TestCase(name = "Constructor: blank name (this test does not check cackle)")
    @Tip(description = "What is a valid input for name? What should it default to?")
    public void constructorBlankName() throws TestFailedException {

        Witch ghost = new Witch("", 6, 70, "Wahoo!");
        String string = ghost.toString();

        TestFunction.assertEqual(string, "Charlie Brown/6/70");
    }

    @TestCase(name = "Constructor: no args (this test does not check cackle)")
    @Tip(description = "What is a valid input for name? What should it default to?")
    public void constructorNoArgs() throws TestFailedException {

        Witch ghost = new Witch("   ", 6, 70, "Wahoo!");
        String string = ghost.toString();

        TestFunction.assertEqual(string, "Charlie Brown/6/70");
    }

    @TestCase(name = "Constructor: null signatureCackle")
    @Tip(description = "What qualifies as a valid input for signatureCackle?")
    public void constructorNullCackle() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Witch witch = new Witch("Skipper", 6, 70,null);
        witch.trickOrTreat();

        String consoleOutput = hijacker.stopRecording();

        TestFunction.assertEqual(consoleOutput, "Bwahaha! I'll get you my pretty!\n");
    }

    @TestCase(name = "Constructor: empty signatureCackle")
    @Tip(description = "What qualifies as a valid input for signatureCackle?")
    public void constructorEmptyCackle() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Witch witch = new Witch("Skipper", 6, 70,"");
        witch.trickOrTreat();

        String consoleOutput = hijacker.stopRecording();

        TestFunction.assertEqual(consoleOutput, "Bwahaha! I'll get you my pretty!\n");
    }


    @TestCase(name = "Constructor: blank signatureCackle")
    @Tip(description = "What qualifies as a valid input for signatureCackle?")
    public void constructorBlankCackle() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Witch witch = new Witch("Skipper", 6, 70,"     ");
        witch.trickOrTreat();

        String consoleOutput = hijacker.stopRecording();

        TestFunction.assertEqual(consoleOutput, "Bwahaha! I'll get you my pretty!\n");
    }

    @TestCase(name = "trickOrTreat: run once (checking for console output)")
    @Tip(description = "Check for leading or trailing whitespace in your print statements.")
    public void trickOrTreatOutputOnce() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Witch witch = new Witch("Grey", 9, 70, "Yippee");
        witch.trickOrTreat();

        String consoleOutput = hijacker.stopRecording();

        TestFunction.assertEqual(consoleOutput, "Yippee! I'll get you my pretty!\n");
    }

    @TestCase(name = "trickOrTreat: run twice (checking for console output)")
    @Tip(description = "Check for leading or trailing whitespace in your print statements.")
    public void trickOrTreatOutputTwice() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Witch witch = new Witch("Spartan", 9, 65, "Hooray");
        witch.trickOrTreat();
        witch.trickOrTreat();

        String consoleOutput = hijacker.stopRecording();

        TestFunction.assertEqual(consoleOutput, "Hooray! I'll get you my pretty!\nHooray! I'll get you my pretty!\n");
    }

    @TestCase(name = "trickOrTreat: run three times (checking for console output)")
    @Tip(description = "Check for leading or trailing whitespace in your print statements.")
    public void trickOrTreatOutputThrice() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Witch witch = new Witch("Poof", 2, 45, "Wahoo");
        witch.trickOrTreat();
        witch.trickOrTreat();
        witch.trickOrTreat();

        String consoleOutput = hijacker.stopRecording();

        TestFunction.assertEqual(consoleOutput, "Wahoo! I'll get you my pretty!\nWahoo! I'll get you my pretty!\nWahoo! I'll get you my pretty!\n");
    }

    @TestCase(name = "trickOrTreat: run once (checking for number of candy)")
    @Tip(description = "How much candy should a Witch gain when it trickOrTreats?")
    public void trickOrTreatCandyOnce() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Witch witch = new Witch("Grey", 9, 70, "yippee");
        witch.trickOrTreat();
        String output = witch.toString();

        hijacker.stopRecording();
        
        TestFunction.assertEqual(output, "Grey/9/73");
    }

    @TestCase(name = "trickOrTreat: run twice (checking for number of candy)")
    @Tip(description = "How much candy should a Witch gain when it trickOrTreats?")
    public void trickOrTreatCandyTwice() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Witch witch = new Witch("Spartan", 9, 65, "yippee");
        witch.trickOrTreat();
        witch.trickOrTreat();
        String output = witch.toString();

        hijacker.stopRecording();

        TestFunction.assertEqual(output, "Spartan/9/71");
    }

    @TestCase(name = "trickOrTreat: run three times (checking for number of candy)")
    @Tip(description = "How much candy should a Witch gain when it trickOrTreats?")
    public void trickOrTreatCandyThrice() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Witch witch = new Witch("Poof", 2, 45, "yippee");
        witch.trickOrTreat();
        witch.trickOrTreat();
        witch.trickOrTreat();
        String output = witch.toString();

        hijacker.stopRecording();

        TestFunction.assertEqual(output, "Poof/2/54");
    }

    @TestCase(name = "compareTo: other has greater candy, smaller age, equal cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToGreaterSmaller() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 2, 9, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 1, 10, "Haha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has greater candy, equal age, equal cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToGreaterEqual() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 1, 9, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 1, 10, "Haha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has greater candy, greater age, equal cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToGreaterGreater() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 1, 9, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 2, 10, "Haha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has equal candy, smaller age, equal cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualSmaller() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 2, 10, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 1, 10, "Haha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has equal candy, equal age, equal cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualEqual() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 1, 10, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 1, 10, "Haha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, 0);
    }

    @TestCase(name = "compareTo: other has equal candy, greater age, equal cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualGreater() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 1, 10, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 2, 10, "Haha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has fewer candy, smaller age, equal cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToSmallerSmaller() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 2, 10, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 1, 9, "Haha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has fewer candy, equal age, equal cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToSmallerEqual() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 1, 10, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 1, 9, "Haha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has fewer candy, greater ag, equal cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToSmallerGreater() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 1, 10, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 2, 9, "Haha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has equal candy, equal age, greater cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualEqualGreater() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 1, 10, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 1, 10, "Hahaha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has equal candy, equal age, smaller cackleLength")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualEqualGreaterSmaller() throws TestFailedException {

        Witch witch1 = new Witch("Skipper", 1, 10, "Haha");
        Witch witch2 = new Witch("Sun Tzu", 1, 10, "Ha");
        int result = TestUtils.signOf(witch1.compareTo(witch2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: Check for transitivity (not necessarily correctness)")
    @Tip(description = "Read the Java 11 compareTo() documentation for info on transitivity.\n"
               + "\t      If x.compareTo(y) > 0 and y.compareTo(z) > 0, then x.compareTo(z) MUST be > 0.\n"
               + "\t      This method checks MANY combinations of ages and numCandys for transitivity.\n")
    public void compareToTransitivity() throws TestFailedException {

        String witchX, witchY, witchZ;
        
        Witch[] possibleX = getAllWitchesOnInterval("Xander", 0,12, 0, 10, 0, 3);
        Witch[] possibleY = getAllWitchesOnInterval("Yang", 0, 12, 0, 10, 0, 3);
        Witch[] possibleZ = getAllWitchesOnInterval("Zan", 0, 12, 0, 10, 0, 3);

        for (Witch witchOne : possibleX) {
            for (Witch witchTwo : possibleY) {
                for (Witch witchThree : possibleZ) {
                    if (witchOne.compareTo(witchTwo) > 0 && witchTwo.compareTo(witchThree) > 0 && witchOne.compareTo(witchThree) <= 0) { // This comes directly from the compareTo docs
                        witchX = witchOne.toString();
                        witchY = witchTwo.toString();
                        witchZ = witchThree.toString();
                        System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                                AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " TRANSITIVITY TEST FAILED: \u00BB ") + "\nWhen "
                                + "x = \"" + witchX + "\", y = \"" + witchY + "\", z = \"" + witchZ + "\"");
                        TestFunction.assertEqual(TestUtils.signOf(witchOne.compareTo(witchThree)), 1);
                    }
                }
            }
        }
    }

    /**
     * Helper method to retrieve all possible Ghosts on the given intervals (inclusive).
     * @param name The name of all of the Ghosts
     * @param minAge Min age, inclusive.
     * @param maxAge Max age, inclusive.
     * @param minCandy Min candy, inclusive.
     * @param maxCandy Max candy, inclusive.
     * @param minCackleLength Min cackle length, inclusive.
     * @param maxCackleLength Max cackle length, inclusive.
     * @return An array containing all possible trick or treaters on the interval.
     */
    private Witch[] getAllWitchesOnInterval(String name, int minAge, int maxAge, int minCandy, int maxCandy, int minCackleLength, int maxCackleLength) {
        Witch[] combos = new Witch[(maxAge + 1 - minAge) * (maxCandy + 1 - minCandy) * (maxCackleLength + 1 - minCackleLength)];
        int index = 0;
        for (int i = minAge; i <= maxAge; i++) {
            for (int j = minCandy; j <= maxCandy; j++) {
                for (int k = minCackleLength; k <= maxCackleLength; k++) {
                    StringBuilder s = new StringBuilder();
                    for (int l = 0; l < k; l++) {
                        s.append("-");
                    }
                    combos[index] = new Witch(name, i, j, s.toString());
                    index++;
                }
            }
        }
        return combos;
    }
}
//AUTOGENERATED FROM ../src/TestFailedException.java
/**
 * A custom exception used for detecting tests failed.
 */
class TestFailedException extends Exception {
    public TestFailedException() {
    }

    public TestFailedException(String message) {
        super(message);
    }
}

//AUTOGENERATED FROM ../src/TestManager.java

class TestManager {
    /**
     * A list of the currently registered classes to test
     */
    private static final List<Class<?>> testClazzes = new ArrayList<>();

    public static void main(String[] args) {

        // REGISTER CLASSES HERE
        registerClass(TrickOrTreaterTests.class);
        registerClass(GhostTests.class);
        registerClass(WitchTests.class);
        registerClass(HalloweenNightTests.class);
        
        executeTests();
    }

    /**
     * Registers and marks test class to be scanned during test execution.
     * 
     * @param clazz The input class
     */
    public static void registerClass(Class<?> clazz) {
        testClazzes.add(clazz);
    }

    /**
     * Executes all registered tests.
     */
    public static void executeTests() {
        int totalTests = 0;
        int totalTestsFailed = 0;

        for (Class<?> testClass : testClazzes) {
            try {
                printTestCategory(testClass.getName());

                Object instance = testClass.getDeclaredConstructor().newInstance();

                int classTests = 0;
                int classTestsFailed = 0;

                for (Method m : testClass.getMethods()) {
                    TestCase testCase = m.getAnnotation(TestCase.class);
                    Tip tip = m.getAnnotation(Tip.class);

                    if (testCase != null) {
                        try {

                            m.invoke(instance);

                            System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_GREEN_BACKGROUND,
                                    AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " PASSED: \u00BB ") + " "
                                    + testCase.name());
                        } catch (InvocationTargetException e) {
                            if (e.getCause() instanceof TestFailedException) {
                                TestFailedException tfe = (TestFailedException) e.getCause();

                                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                                        AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " FAILED: \u00BB ") + " "
                                        + testCase.name());

                                System.out.println("\t" + tfe.getMessage());

                                classTestsFailed++;
                                if (tip != null)
                                    System.out.printf("\tHINT: %s\n", tip.description());
                            } else {
                                e.getCause().printStackTrace();
                            }
                        } catch (IllegalAccessException e) {
                            e.printStackTrace();
                        } catch (IllegalArgumentException e) {
                            e.printStackTrace();
                        }

                        classTests++;
                    }
                }

                totalTests += classTests;
                totalTestsFailed += classTestsFailed;

                System.out.println();
                StringUtils.printTextCentered(
                        String.format("TESTS PASSED: %d/%d", classTests - classTestsFailed, classTests));

            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        StringUtils.printHorizontalLine();

        StringUtils.printTextCentered("Test Results");
        System.out.println();
        StringUtils.printTextCentered(
                String.format("TOTAL TESTS PASSED: %d/%d", totalTests - totalTestsFailed, totalTests));
        StringUtils.printHorizontalLine();

    }

    /**
     * Prints a formatted test category section
     * 
     * @param category The name of the section (most likely the class name)
     */
    private static void printTestCategory(String category) {
        StringUtils.printHorizontalLine();
        StringUtils.printTextCentered(category);
        System.out.println();
    }
}

//AUTOGENERATED FROM ../src/IOHijacker.java

/**
 * A helper class used for redirecting System.out to check against
 */
class IOHijacker {
    private static IOHijacker INSTANCE;

    private String log = "";
    private PrintStream originalStream;
    private PrintStream redirectedStream;
    private boolean recording = false;

    private IOHijacker() {
        this.originalStream = System.out;
    }

    /**
     * Starts recording all System.out messages to the console and stores them in
     * IOHijacker.log.
     * 
     * Until stopRecording is called, no System.out messages will appear.
     */
    public void startRecording() {
        log = "";

        if (redirectedStream == null)
            redirectedStream = getRedirectedStream();

        System.setOut(redirectedStream);

        recording = true;
    }

    /**
     * Stops the current recording, resetting System.out to its default behavior.
     * 
     * @return A list of all messages sent during the recording
     */
    public String stopRecording() {
        recording = false;

        System.setOut(originalStream);

        return log;
    }

    /**
     * Retrieves the current log of messages in a recording
     * 
     * @return The current log of messages
     */
    public String getCurrentLog() {
        return log;
    }

    /**
     * Retrieves a custom PrintStream that redirects print to instead logMessage
     * 
     * @return The custom PrintStream
     */
    private PrintStream getRedirectedStream() {
        return new PrintStream(System.out, true) {
            @Override
            public void print(String s) {
                IOHijacker.appendMessage(s);
            }

            @Override
            public PrintStream printf(String message, Object... args) {
                IOHijacker.appendMessage(String.format(message, args));
                return this;
            }

            @Override
            public void println(String s) {
                IOHijacker.appendMessage(s + "\n");
            }

        };
    }

    /**
     * Returns the Singleton's instance, creating one if it doesn't exist.
     * 
     * @return The IOHijacker instance
     */
    public static IOHijacker getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new IOHijacker();
        }

        return INSTANCE;
    }

    /**
     * Appends a string message to the log ONLY if recording.
     * 
     * @param message The message to be recorded
     */
    private static void appendMessage(String message) {
        IOHijacker instance = getInstance();

        if (!instance.recording)
            return;

        instance.log += message.replaceAll("\r","");
    }
}

//AUTOGENERATED FROM ../src/GhostTests.java
class GhostTests {
    private static final String COMPARE_TO_METHOD_TIP = "What criteria should compareTo use to determine greater/less than? What order should these be compared?\n"
                                                        + "    Note: This test only checks the SIGN of compareTo, since the intended number is not specified.\n"
                                                        + "    1 means that compareTo() returned a positive number, -1 means a negative number, 0 means 0.";

    @TestCase(name = "Constructor: Valid inputs passed in.")
    @Tip(description = "\nMake sure there isn't any field shadowing in your constructor!\nWhat should numberOfRobberies default to?")
    public void constructorThreeArgs() throws TestFailedException {

        Ghost ghost = new Ghost("Yoon", 6, 7);
        String string = ghost.toString();

        TestFunction.assertEqual(string, "Yoon/6/7/0");
    }

    @TestCase(name = "Constructor: No args")
    @Tip(description = "What should each of Ghost's fields default to?")
    public void constructorNoArgs() throws TestFailedException {

        Ghost ghost = new Ghost();
        String string = ghost.toString();

        TestFunction.assertEqual(string, "Casper the Unfriendly Ghost/12/0/0");
    }

    @TestCase(name = "trickOrTreat() method: Printed message (when run once).")
    @Tip(description = "One thing should be printed each time trickOrTreat() gets called. What is it?")
    public void trickOrTreatPrintWhenRunOnce() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Ghost ghost = new Ghost("Katia", 9, 7);
        ghost.trickOrTreat();

        String output = hijacker.stopRecording();
        
        TestFunction.assertEqual(output, "Boo! Trick or treat!\n");
    }

    @TestCase(name = "trickOrTreat() method: Printed message (when run twice).")
    @Tip(description = "One thing should be printed each time trickOrTreat() gets called. What is it?")
    public void trickOrTreatPrintWhenRunTwice() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Ghost ghost = new Ghost("Katia", 9, 7);
        ghost.trickOrTreat();
        ghost.trickOrTreat();

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "Boo! Trick or treat!\nBoo! Trick or treat!\n");
    }

    @TestCase(name = "trickOrTreat() method: Printed message (when run three times).")
    @Tip(description = "One thing should be printed each time trickOrTreat() gets called. What is it?")
    public void trickOrTreatPrintWhenRunThrice() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Ghost ghost = new Ghost("Katia", 9, 7);
        ghost.trickOrTreat();
        ghost.trickOrTreat();
        ghost.trickOrTreat();

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "Boo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\n");
    }

    @TestCase(name = "trickOrTreat() method: Ghost's candy is properly added after one trickOrTreat()")
    @Tip(description = "How many pieces of candy does a Ghost get every time it runs trickOrTreat()?")
    public void trickOrTreatOneRun() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Ghost ghost = new Ghost("Laura", 6, 5);
        ghost.trickOrTreat();
        String string = ghost.toString();

        hijacker.stopRecording();

        TestFunction.assertEqual(string, "Laura/6/7/0");
    }

    @TestCase(name = "trickOrTreat() method: Ghost's candy is properly added after two trickOrTreat()'s")
    @Tip(description = "How many pieces of candy does a Ghost get every time it runs trickOrTreat()?")
    public void trickOrTreatTwoRuns() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Ghost ghost = new Ghost("Skyla", 6, 3);
        ghost.trickOrTreat();
        ghost.trickOrTreat();
        String string = ghost.toString();

        hijacker.stopRecording();

        TestFunction.assertEqual(string, "Skyla/6/7/0");
    }

    @TestCase(name = "trickOrTreat() method: Ghost's candy is properly added after three trickOrTreat()'s")
    @Tip(description = "How many pieces of candy does a Ghost get every time it runs trickOrTreat()?")
    public void trickOrTreatThreeRuns() throws TestFailedException {
        IOHijacker hijacker = IOHijacker.getInstance();

        hijacker.startRecording();

        Ghost ghost = new Ghost("Radhika", 6, 1);
        ghost.trickOrTreat();
        ghost.trickOrTreat();
        ghost.trickOrTreat();
        String string = ghost.toString();

        hijacker.stopRecording();

        TestFunction.assertEqual(string, "Radhika/6/7/0");
    }

    @TestCase(name = "rob() method: Increments robberiesConducted when given a valid Robbale")
    @Tip(description = "Make sure you're incrementing robberiesConducted!")
    public void robValidInputs() throws TestFailedException {
        Ghost ghost = new Ghost("Spartan", 9, 6);
        RobbableSubclass victim = new RobbableSubclass("Clarence", 5, 1);

        ghost.rob(victim);

        String string = ghost.toString();

        TestFunction.assertEqual(string, "Spartan/9/7/1");
    }

    @TestCase(name = "rob() method: Does not increment robberiesConducted when given null")
    @Tip(description = "As written, the instructions do not forbid a null input to rob().")
    public void robNull() throws TestFailedException {
        Ghost ghost = new Ghost("Tremor", 6, 7);

        ghost.rob(null);

        String string = ghost.toString();

        TestFunction.assertEqual(string, "Tremor/6/7/0");
    }

    @TestCase(name = "rob() method: Does not increment robberiesConducted when stealing 0 candies.")
    @Tip(description = "As mentioned in the HW04 clarification thread, robberiesConducted should only increment when 1 or more candies are stolen.")
    public void robZero() throws TestFailedException {
        Ghost ghost = new Ghost("Skipper", 6, 7);
        RobbableSubclass victim = new RobbableSubclass("Clarence", 5, 0);

        ghost.rob(victim);

        String string = ghost.toString();

        TestFunction.assertEqual(string, "Skipper/6/7/0");
    }

    @TestCase(name = "rob() method: Increments robberiesConducted when doing 2 robberies.")
    @Tip(description = "Make sure you're incrementing robberiesConducted!")
    public void robTwice() throws TestFailedException {
        Ghost ghost = new Ghost("Iron", 9, 5);
        RobbableSubclass victim = new RobbableSubclass("Clarence", 5, 1);

        ghost.rob(victim);
        ghost.rob(victim);

        String string = ghost.toString();

        TestFunction.assertEqual(string, "Iron/9/7/2");
    }

    @TestCase(name = "rob() method: Increments robberiesConducted when doing 3 robberies.")
    @Tip(description = "Make sure you're incrementing robberiesConducted!")
    public void robThrice() throws TestFailedException {
        Ghost ghost = new Ghost("Grey", 9, 4);
        RobbableSubclass victim = new RobbableSubclass("Clarence", 5, 1);

        ghost.rob(victim);
        ghost.rob(victim);
        ghost.rob(victim);

        String string = ghost.toString();

        TestFunction.assertEqual(string, "Grey/9/7/3");
    }

    @TestCase(name = "compareTo: other has greater candy, smaller age, equal robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToGreaterSmaller() throws TestFailedException {

        Ghost ghost1 = new Ghost("Skipper", 2, 9);
        Ghost ghost2 = new Ghost("Sun Tzu", 1, 10);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has greater candy, equal age, equal robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToGreaterEqual() throws TestFailedException {

        Ghost ghost1 = new Ghost("Skipper", 1, 9);
        Ghost ghost2 = new Ghost("Sun Tzu", 1, 10);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has greater candy, greater age, equal robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToGreaterGreater() throws TestFailedException {

        Ghost ghost1 = new Ghost("Skipper", 1, 9);
        Ghost ghost2 = new Ghost("Sun Tzu", 2, 10);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has equal candy, smaller age, equal robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualSmaller() throws TestFailedException {

        Ghost ghost1 = new Ghost("Skipper", 2, 10);
        Ghost ghost2 = new Ghost("Sun Tzu", 1, 10);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has equal candy, equal age, equal robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualEqual() throws TestFailedException {

        Ghost ghost1 = new Ghost("Skipper", 1, 10);
        Ghost ghost2 = new Ghost("Sun Tzu", 1, 10);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, 0);
    }

    @TestCase(name = "compareTo: other has equal candy, greater age, equal robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualGreater() throws TestFailedException {

        Ghost ghost1 = new Ghost("Skipper", 1, 10);
        Ghost ghost2 = new Ghost("Sun Tzu", 2, 10);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has fewer candy, smaller age, equal robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToSmallerSmaller() throws TestFailedException {

        Ghost ghost1 = new Ghost("Skipper", 2, 10);
        Ghost ghost2 = new Ghost("Sun Tzu", 1, 9);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has fewer candy, equal age, equal robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToSmallerEqual() throws TestFailedException {

        Ghost ghost1 = new Ghost("Skipper", 1, 10);
        Ghost ghost2 = new Ghost("Sun Tzu", 1, 9);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has fewer candy, greater age, equal robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToSmallerGreater() throws TestFailedException {

        Ghost ghost1 = new Ghost("Skipper", 1, 10);
        Ghost ghost2 = new Ghost("Sun Tzu", 2, 9);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: other has equal candy, equal age, greater robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualEqualGreater() throws TestFailedException {
        RobbableSubclass dummy = new RobbableSubclass("dummy", 0, 1);
        Ghost ghost1 = new Ghost("Skipper", 1, 10);
        Ghost ghost2 = new Ghost("Sun Tzu", 1, 10);
        ghost2.rob(dummy);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, -1);
    }

    @TestCase(name = "compareTo: other has equal candy, equal age, fewer robberies")
    @Tip(description = COMPARE_TO_METHOD_TIP)
    public void compareToEqualEqualSmaller() throws TestFailedException {
        RobbableSubclass dummy = new RobbableSubclass("dummy", 0, 1);

        Ghost ghost1 = new Ghost("Skipper", 1, 10);
        ghost1.rob(dummy);
        Ghost ghost2 = new Ghost("Sun Tzu", 1, 10);
        int result = TestUtils.signOf(ghost1.compareTo(ghost2));

        TestFunction.assertEqual(result, 1);
    }

    @TestCase(name = "compareTo: transitivity check...")
    @Tip(description = "Read the Java 11 compareTo() documentation for info on transitivity.\n"
               + "\t      If x.compareTo(y) > 0 and y.compareTo(z) > 0, then x.compareTo(z) MUST be > 0.\n"
               + "\t      This method checks MANY combinations of ages and numCandys for transitivity.\n")
    public void compareToTransitivity() throws TestFailedException {

        String ghostX, ghostY, ghostZ;
        
        Ghost[] possibleX = getAllGhostsOnInterval("Xander", 0,12, 0, 10, 0, 3);
        Ghost[] possibleY = getAllGhostsOnInterval("Yang", 0, 12, 0, 10, 0, 3);
        Ghost[] possibleZ = getAllGhostsOnInterval("Zan", 0, 12, 0, 10, 0, 3);

        for (Ghost ghostOne : possibleX) {
            for (Ghost ghostTwo : possibleY) {
                for (Ghost ghostThree : possibleZ) {
                    if (ghostOne.compareTo(ghostTwo) > 0 && ghostTwo.compareTo(ghostThree) > 0 && ghostOne.compareTo(ghostThree) <= 0) { // This comes directly from the compareTo docs
                        ghostX = ghostOne.toString();
                        ghostY = ghostTwo.toString();
                        ghostZ = ghostThree.toString();
                        System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                                AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " TRANSITIVITY TEST FAILED: \u00BB ") + "\nWhen "
                                + "x = \"" + ghostX + "\", y = \"" + ghostY + "\", z = \"" + ghostZ + "\"");
                        TestFunction.assertEqual(TestUtils.signOf(ghostOne.compareTo(ghostThree)), 1);
                    }
                }
            }
        }
    }

    /**
     * Private class to test Ghost's rob() function.
     */
    private static class RobbableSubclass extends TrickOrTreater implements Robbable {

        public RobbableSubclass(String name, int age, int numCandy) {
            super(name, age, numCandy);
        }

        @Override
        public int beRobbed() {
            return this.getNumCandy();
        }

        @Override
        public void trickOrTreat() {
        }

    }

    /**
     * Helper method to retrieve all possible Ghosts on the given intervals (inclusive).
     * @param name The name of all of the Ghosts
     * @param minAge Min age, inclusive.
     * @param maxAge Max age, inclusive.
     * @param minCandy Min candy, inclusive.
     * @param maxCandy Max candy, inclusive.
     * @param minRobberies Min robberies, inclusive.
     * @param maxRobberies Max robberies, inclusive.
     * @return An array containing all possible trick or treaters on the interval.
     */
    private Ghost[] getAllGhostsOnInterval(String name, int minAge, int maxAge, int minCandy, int maxCandy, int minRobberies, int maxRobberies) {
        Ghost[] combos = new Ghost[(maxAge + 1 - minAge) * (maxCandy + 1 - minCandy) * (maxRobberies + 1 - minRobberies)];
        RobbableSubclass dummy = new RobbableSubclass("dummy", 0, 0);
        int index = 0;
        for (int i = minAge; i <= maxAge; i++) {
            for (int j = minCandy; j <= maxCandy; j++) {
                for (int k = minRobberies; k <= maxRobberies; k++) {
                    combos[index] = new Ghost(name, i, j);
                    for (int l = 0; l < k; l++) {
                        combos[index].rob(dummy);
                    }
                    index++;
                }
            }
        }
        return combos;
    }
}

//AUTOGENERATED FROM ../src/HalloweenNightTests.java
class HalloweenNightTests {

    @TestCase(name = "Constructor: Valid inputs passed in.")
    @Tip(description = "Make sure that there is no field shadowing in your constructor!")
    public void constructorValidInputs() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        cryptKickerFive[0] = new Ghost("kicker1", 0, 0);
        cryptKickerFive[1] = new Ghost("kicker2", 0, 0);
        cryptKickerFive[2] = new Ghost("kicker3", 0, 0);
        cryptKickerFive[3] = new Ghost("kicker4", 0, 0);
        cryptKickerFive[4] = new Ghost("kicker5", 0, 0);
        ghoulGang[0] = new Ghost("ghoul1", 0, 0);
        ghoulGang[1] = new Ghost("ghoul2", 0, 0);
        ghoulGang[2] = new Ghost("ghoul3", 0, 0);
        ghoulGang[3] = new Ghost("ghoul4", 0, 0);
        ghoulGang[4] = new Ghost("ghoul5", 0, 0);

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);

        String string = night.toString();

        TestFunction.assertEqual(string, "cryptKickerFive: kicker1/0/0/0, kicker2/0/0/0, kicker3/0/0/0, kicker4/0/0/0, kicker5/0/0/0 versus ghoulGang: ghoul1/0/0/0, ghoul2/0/0/0, ghoul3/0/0/0, ghoul4/0/0/0, ghoul5/0/0/0");
    }

    @TestCase(name = "compareTeams: cryptKicker5 is favored 3 to 2")
    @Tip(description = "Make sure you're comparing the same index on each team!")
    public void compareTeamsCK5Favored() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        IOHijacker hijacker = IOHijacker.getInstance();
        hijacker.startRecording();

        cryptKickerFive[0] = new Ghost("kicker1", 0, 1);
        cryptKickerFive[1] = new Ghost("kicker2", 0,1);
        cryptKickerFive[2] = new Ghost("kicker3", 0, 1);
        cryptKickerFive[3] = new Ghost("kicker4", 0, 0);
        cryptKickerFive[4] = new Ghost("kicker5", 0, 0);
        ghoulGang[0] = new Ghost("ghoul1", 0, 0);
        ghoulGang[1] = new Ghost("ghoul2", 0, 0);
        ghoulGang[2] = new Ghost("ghoul3", 0, 0);
        ghoulGang[3] = new Ghost("ghoul4", 0, 1);
        ghoulGang[4] = new Ghost("ghoul5", 0, 1);

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);
        night.compareTeams();

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "cryptKickerFive is favored.\n");
    }

    @TestCase(name = "compareTeams: ghoulGang is favored 3 to 2")
    @Tip(description = "Make sure you're comparing the same index on each team!")
    public void compareTeamsGGFavored() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        IOHijacker hijacker = IOHijacker.getInstance();
        hijacker.startRecording();

        cryptKickerFive[0] = new Ghost("kicker1", 0, 1);
        cryptKickerFive[1] = new Ghost("kicker2", 0,1);
        cryptKickerFive[2] = new Ghost("kicker3", 0, 1);
        cryptKickerFive[3] = new Ghost("kicker4", 1, 1);
        cryptKickerFive[4] = new Ghost("kicker5", 1, 1);
        ghoulGang[0] = new Ghost("ghoul1", 0, 2);
        ghoulGang[1] = new Ghost("ghoul2", 0, 2);
        ghoulGang[2] = new Ghost("ghoul3", 0, 2);
        ghoulGang[3] = new Ghost("ghoul4", 0, 1);
        ghoulGang[4] = new Ghost("ghoul5", 0, 1);

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);
        night.compareTeams();

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "ghoulGang is favored.\n");
    }

    @TestCase(name = "compareTeams: neither team is favored (all 5 TrickOrTreaters are equal)")
    @Tip(description = "Make sure you're comparing the same index on each team!")
    public void compareTeamsNeitherFavoredFive() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        IOHijacker hijacker = IOHijacker.getInstance();
        hijacker.startRecording();

        cryptKickerFive[0] = new Ghost("kicker1", 3, 2);
        cryptKickerFive[1] = new Ghost("kicker2", 1, 2);
        cryptKickerFive[2] = new Ghost("kicker3", 0, 2);
        cryptKickerFive[3] = new Ghost("kicker4", 1, 1);
        cryptKickerFive[4] = new Ghost("kicker5", 1, 1);
        ghoulGang[0] = new Ghost("ghoul1", 3, 2);
        ghoulGang[1] = new Ghost("ghoul2", 1, 2);
        ghoulGang[2] = new Ghost("ghoul3", 0, 2);
        ghoulGang[3] = new Ghost("ghoul4", 1, 1);
        ghoulGang[4] = new Ghost("ghoul5", 1, 1);

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);
        night.compareTeams();

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "Neither team is favored.\n");
    }

    @TestCase(name = "compareTeams: neither team is favored (3 TrickOrTreaters are equal)")
    @Tip(description = "Make sure you're comparing the same index on each team!")
    public void compareTeamsNeitherFavoredThree() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        IOHijacker hijacker = IOHijacker.getInstance();
        hijacker.startRecording();

        cryptKickerFive[0] = new Ghost("kicker1", 4, 2);
        cryptKickerFive[1] = new Ghost("kicker2", 0, 2);
        cryptKickerFive[2] = new Ghost("kicker3", 0, 2);
        cryptKickerFive[3] = new Ghost("kicker4", 1, 1);
        cryptKickerFive[4] = new Ghost("kicker5", 1, 1);
        ghoulGang[0] = new Ghost("ghoul1", 3, 2);
        ghoulGang[1] = new Ghost("ghoul2", 1, 2);
        ghoulGang[2] = new Ghost("ghoul3", 0, 2);
        ghoulGang[3] = new Ghost("ghoul4", 1, 1);
        ghoulGang[4] = new Ghost("ghoul5", 1, 1);

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);
        night.compareTeams();

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "Neither team is favored.\n");
    }

    @TestCase(name = "compareTeams: neither team is favored (1 TrickOrTreater is equal)")
    @Tip(description = "Make sure you're comparing the same index on each team!")
    public void compareTeamsNeitherFavoredOne() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        IOHijacker hijacker = IOHijacker.getInstance();
        hijacker.startRecording();

        cryptKickerFive[0] = new Ghost("kicker1", 4, 2);
        cryptKickerFive[1] = new Ghost("kicker2", 0, 2);
        cryptKickerFive[2] = new Ghost("kicker3", 1, 2);
        cryptKickerFive[3] = new Ghost("kicker4", 0, 1);
        cryptKickerFive[4] = new Ghost("kicker5", 1, 1);
        ghoulGang[0] = new Ghost("ghoul1", 3, 2);
        ghoulGang[1] = new Ghost("ghoul2", 1, 2);
        ghoulGang[2] = new Ghost("ghoul3", 0, 2);
        ghoulGang[3] = new Ghost("ghoul4", 1, 1);
        ghoulGang[4] = new Ghost("ghoul5", 1, 1);

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);
        night.compareTeams();

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "Neither team is favored.\n");
    }

    @TestCase(name = "battle: cryptKickerFive wins in one turn by trickOrTreating")
    @Tip(description = "Remember to trickOrTreat() first!")
    public void battleWinImmediately() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        IOHijacker hijacker = IOHijacker.getInstance();
        hijacker.startRecording();

        cryptKickerFive[0] = new Ghost("kicker1", 0, 8);
        cryptKickerFive[1] = new Ghost("kicker2", 0, 8);
        cryptKickerFive[2] = new Ghost("kicker3", 0, 8);
        cryptKickerFive[3] = new Ghost("kicker4", 0, 8);
        cryptKickerFive[4] = new Ghost("kicker5", 0, 8);
        ghoulGang[0] = new Witch("ghoul1", 1, 0, "Ha");
        ghoulGang[1] = new Witch("ghoul2", 1, 0, "Ha");
        ghoulGang[2] = new Witch("ghoul3", 1, 0, "Ha");
        ghoulGang[3] = new Witch("ghoul4", 1, 0, "Ha");
        ghoulGang[4] = new Witch("ghoul5", 1, 0, "Ha");

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);
        night.battle(48);

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "Boo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\n"
            + "Ha! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\n" 
            + "cryptKickerFive won!\n");
    }

    @TestCase(name = "battle: threshold defaults to 60")
    @Tip(description = "Remember to trickOrTreat() first!")
    public void battleDefaultThreshold() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        IOHijacker hijacker = IOHijacker.getInstance();
        hijacker.startRecording();

        cryptKickerFive[0] = new Ghost("kicker1", 0, 9);
        cryptKickerFive[1] = new Ghost("kicker2", 0, 9);
        cryptKickerFive[2] = new Ghost("kicker3", 0, 9);
        cryptKickerFive[3] = new Ghost("kicker4", 0, 9);
        cryptKickerFive[4] = new Ghost("kicker5", 0, 9);
        ghoulGang[0] = new Witch("ghoul1", 1, 0, "Ha");
        ghoulGang[1] = new Witch("ghoul2", 1, 0, "Ha");
        ghoulGang[2] = new Witch("ghoul3", 1, 0, "Ha");
        ghoulGang[3] = new Witch("ghoul4", 1, 0, "Ha");
        ghoulGang[4] = new Witch("ghoul5", 1, 0, "Ha");

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);
        night.battle(0);

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "Boo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\n"
            + "Ha! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\n" 
            + "Boo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\n"
            + "Ha! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\n" 
            + "cryptKickerFive won!\n");
    }

    @TestCase(name = "battle: Both teams go at least once")
    @Tip(description = "Even if the threshold is met, make sure that the teams both get the same number of turns!")
    public void battleBothTeamsGo() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        IOHijacker hijacker = IOHijacker.getInstance();
        hijacker.startRecording();

        cryptKickerFive[0] = new Ghost("kicker1", 0, 10);
        cryptKickerFive[1] = new Ghost("kicker2", 0, 10);
        cryptKickerFive[2] = new Ghost("kicker3", 0, 10);
        cryptKickerFive[3] = new Ghost("kicker4", 0, 10);
        cryptKickerFive[4] = new Ghost("kicker5", 0, 10);
        ghoulGang[0] = new Witch("ghoul1", 1, 69, "Ha");
        ghoulGang[1] = new Witch("ghoul2", 1, 0, "Ha");
        ghoulGang[2] = new Witch("ghoul3", 1, 0, "Ha");
        ghoulGang[3] = new Witch("ghoul4", 1, 0, "Ha");
        ghoulGang[4] = new Witch("ghoul5", 1, 0, "Ha");

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);
        night.battle(65);

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "Boo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\n"
            + "Ha! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\n"
            + "It is a tie!\n");
    }

    @TestCase(name = "battle: ghoulGang just barely meets the threshold")
    @Tip(description = "Is a threshold a greater-than requirement, or a greater-than-or-equal-to?")
    public void battleMinimumAmount() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        IOHijacker hijacker = IOHijacker.getInstance();
        hijacker.startRecording();

        cryptKickerFive[0] = new Witch("kicker1", 1, 0, "Ha");
        cryptKickerFive[1] = new Witch("kicker2", 1, 0, "Ha");
        cryptKickerFive[2] = new Witch("kicker3", 1, 0, "Ha");
        cryptKickerFive[3] = new Witch("kicker4", 1, 0, "Ha");
        cryptKickerFive[4] = new Witch("kicker5", 1, 0, "Ha");
        ghoulGang[0] = new Ghost("ghoul1", 0, 10);
        ghoulGang[1] = new Ghost("ghoul2", 0, 10);
        ghoulGang[2] = new Ghost("ghoul3", 0, 10);
        ghoulGang[3] = new Ghost("ghoul4", 0, 10);
        ghoulGang[4] = new Ghost("ghoul5", 0, 10);

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);
        night.battle(75);

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "Ha! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\n" 
            + "Boo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\n"
            + "ghoulGang won!\n");
    }

    @TestCase(name = "battle: ghoulGang wins by robbing")
    @Tip(description = "What should each Ghost do after it TrickOrTreats?")
    public void battleWinByRobbing() throws TestFailedException {
        TrickOrTreater[] cryptKickerFive = new TrickOrTreater[5];
        TrickOrTreater[] ghoulGang = new TrickOrTreater[5];

        IOHijacker hijacker = IOHijacker.getInstance();
        hijacker.startRecording();

        cryptKickerFive[0] = new Witch("kicker1", 1, 10, "Ha");
        cryptKickerFive[1] = new Witch("kicker2", 1, 10, "Ha");
        cryptKickerFive[2] = new Witch("kicker3", 1, 10, "Ha");
        cryptKickerFive[3] = new Witch("kicker4", 1, 10, "Ha");
        cryptKickerFive[4] = new Witch("kicker5", 1, 10, "Ha");
        ghoulGang[0] = new Ghost("ghoul1", 0, 10);
        ghoulGang[1] = new Ghost("ghoul2", 0, 10);
        ghoulGang[2] = new Ghost("ghoul3", 0, 10);
        ghoulGang[3] = new Ghost("ghoul4", 0, 10);
        ghoulGang[4] = new Ghost("ghoul5", 0, 10);

        HalloweenNight night = new HalloweenNight(cryptKickerFive, ghoulGang);
        night.battle(90);

        String output = hijacker.stopRecording();

        TestFunction.assertEqual(output, "Ha! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\nHa! I'll get you my pretty!\n" 
            + "Boo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\nBoo! Trick or treat!\n"
            + "ghoulGang won!\n");
    }
}

//AUTOGENERATED FROM ../src/ColorUtils.java
class ColorUtils {
    /**
     * Formats a string to have an ASCII background in terminal.
     * 
     * @param background The ASCII representation of the background color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatBackgroundColorString(String background, String s) {
        return background + s + AsciiColorCode.RESET_COLOR;
    }

    /**
     * Formats a string to have an ASCII foreground (text color) in terminal.
     * 
     * @param foreground The ASCII representation of the foreground color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatForegroundColorString(String foreground, String s) {
        return foreground + s + AsciiColorCode.RESET_COLOR;

    }

    /**
     * Formats a string to have both an ASCII foreground and background in terminal
     * 
     * @param background The ASCII representation of the background color, pulled
     *                   from AsciiColorCode
     * @param foreground The ASCII representation of the foreground color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatColorString(String background, String foreground, String s) {
        return foreground + background + s + AsciiColorCode.RESET_COLOR;
    }
}
