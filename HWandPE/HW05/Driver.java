package HW05;
import java.util.List;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Field;
import java.io.PrintStream;
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
//AUTOGENERATED FROM ../src/ColorUtils.java
class ColorUtils {
    /**
     * Formats a string to have an ASCII background in terminal.
     * 
     * @param background The ASCII representation of the background color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatBackgroundColorString(String background, String s) {
        return background + s + AsciiColorCode.RESET_COLOR;
    }

    /**
     * Formats a string to have an ASCII foreground (text color) in terminal.
     * 
     * @param foreground The ASCII representation of the foreground color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatForegroundColorString(String foreground, String s) {
        return foreground + s + AsciiColorCode.RESET_COLOR;

    }

    /**
     * Formats a string to have both an ASCII foreground and background in terminal
     * 
     * @param background The ASCII representation of the background color, pulled
     *                   from AsciiColorCode
     * @param foreground The ASCII representation of the foreground color, pulled
     *                   from AsciiColorCode
     * @param s          The string to color
     * @return The colored string
     */
    public static String formatColorString(String background, String foreground, String s) {
        return foreground + background + s + AsciiColorCode.RESET_COLOR;
    }
}

//AUTOGENERATED FROM ../src/TestFunction.java

class TestFunction {
    /**
     * Detects if the given Strings do not have the same content (case-sensitive)
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(String actual, String expected) throws TestFailedException {
        boolean failed = false;

        if (actual == null) {
            if (expected != null) {
                throw new TestFailedException("Test failed! Received null, but expected \"" + expected + "\"");
            }
        } else if (expected == null) {
            if (actual != null) {
                throw new TestFailedException("Test failed! Received \"" + actual + "\", but expected null");
            }
        } else {

            if (!actual.replaceAll("\n", System.lineSeparator()).equals(expected.replaceAll("\n", System.lineSeparator()))) {
                failed = true;
            }
        }

        if (failed) {
            
            String actualString = "\"" + actual + "\"";
            String expectedString = (expected == null) ? "null" : "\"" + expected + "\"";
            
            if (actual.trim().contains("\n")) {
                actualString = "\n\"" + actual + "\"\n";
            }
            if (expected.trim().contains("\n")) {
                expectedString = "\n\"" + expected + "\"\n";
            }

            throw new TestFailedException(
                    "Strings different! Received " + actualString + " but expected " + expectedString);
        }
    }

    public static void assertEqual(List<String> actual, List<String> expected) throws TestFailedException {
        boolean failed = false;

        if (actual == null || expected == null || actual.size() != expected.size()) {
            failed = actual == expected;
        } else {
            for (int i = 0; i < expected.size(); i++) {
                if (expected.get(i) == null) {
                    failed = actual.get(i) != null;

                } else {
                    failed = !actual.get(i).equals(expected.get(i));

                }
                if (failed) break;
            }
        }

        if (failed) {
            throw new TestFailedException(
                    "List Different! Received \"" + actual + "\", expected \"" + expected + "\"");
        }
    }

    /**
     * Detects if the given integers are not equal.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(int actual, int expected) throws TestFailedException {
        boolean failed = (actual != expected);
        if (failed) {
            throw new TestFailedException("Integer value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given doubles are not within 1.0e-6 of one another.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(double actual, double expected) throws TestFailedException {
        final double ALLOWABLE_ERROR = 0.000001;

        boolean failed = (Math.abs(actual - expected) > ALLOWABLE_ERROR);

        if (failed) {
            throw new TestFailedException("Double value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given booleans do not have equal values.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException if the test fails
     */
    public static void assertEqual(boolean actual, boolean expected) throws TestFailedException {
        boolean failed = (actual != expected);

        if (failed) {
            throw new TestFailedException("Boolean value difference: Received " + actual + ", expected " + expected);
        }
    }

    /**
     * Detects if the given Exceptions are the same TYPE, not if they are caused by
     * the same thing. Any two
     * NullPointerExceptions will, when passed into this function, return true, even
     * if they are caused by
     * two unrelated issues.
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException If the test fails
     */
    public static void assertEqual(Exception actual, Exception expected) throws TestFailedException {
        boolean failed = (actual.getCause().getClass() != expected.getCause().getClass());

        if (failed) {
            throw new TestFailedException("Exception class difference: Received " + actual.getCause().getClass()
                    + ", but expected " + expected.getCause().getClass());
        }
    }

    /**
     * Prints an error message
     *
     * @param actual   The actual value
     * @param expected The expected value
     * @throws TestFailedException If the test fails
     */
    public static void failTest(String errorMessage) throws TestFailedException {
        throw new TestFailedException("An error occurred: " + errorMessage);
    }
}

//AUTOGENERATED FROM ../src/StringUtils.java
class StringUtils {
    /**
     * The ASCII character to use for horizontal lines
     */
    public static final String HORIZONTAL_LINE_CHARACTER = "\u2500";

    /**
     * The amount of HORIZONTAL_LINE_CHARACTER elements to use in a line
     */
    public static final int HORIZONTAL_LINE_LENGTH = 48;

    /**
     * Prints a horizontal line to the terminal.
     */
    public static void printHorizontalLine() {
        System.out
                .println(String.format("%0" + HORIZONTAL_LINE_LENGTH + "d", 0).replace("0", HORIZONTAL_LINE_CHARACTER));
    }

    /**
     * Prints centered text to the terminal.
     * 
     * @param text The text to be centered
     */
    public static void printTextCentered(String text) {
        // HORIZONTAL_LINE_LENGTH is maximum width
        // if line is
        // xxxxxxxxxxxx
        // We can pad the start of the string with half of the horizontal:
        // xxxxxhelloxx
        // The problem is that this doesn't account for the length of the string.
        // We can add half of the string length as well to correct it:
        // xxxxhelloxxxx = CENTERED! (or at least as close as it can get)

        System.out.printf("%" + (HORIZONTAL_LINE_LENGTH / 2 + text.length() / 2) + "s%n", text);
    }
}

//AUTOGENERATED FROM ../src/TestUtils.java

class TestUtils {
    /**
     * Returns either 1, 0, or -1 depending on the sign of the input.
     * 
     * @param input
     * @return -1 if input < 0, 0 if input = 0, 1 if input > 0
     */
    public static int signOf(int input) {
        if (input == 0) {
            return input;
        } else {
            return Math.abs(input) / input;
        }
    }

    public static String combinePrintStatements(List<String> printedMessages) {
        if (printedMessages == null || printedMessages.size() == 0) {
            return "";
        }

        StringBuilder builder = new StringBuilder(printedMessages.get(0));
        for (int i = 1; i < printedMessages.size(); i++) {
            builder.append("\n");
            builder.append(printedMessages.get(i));
        }
        return builder.toString();
    }
}

//AUTOGENERATED FROM ../src/TestManager.java

class TestManager {
    protected volatile static AtomicInteger classTests = new AtomicInteger();
    protected volatile static AtomicInteger classTestsFailed = new AtomicInteger();

    /**
     * A list of the currently registered classes to test
     */
    private static final List<Class<?>> testClazzes = new ArrayList<>();

    /**
     * When this method is called, the TestManager will run all tests in the given classes.
     * @param classes The classes to test.
     */
    public static void runTestsOn(Class<?> ... classes) {

        for (Class<?> currentClass : classes) {
            registerClass(currentClass);
        }
        
        executeTests();
    }

    /**
     * Registers and marks test class to be scanned during test execution.
     * 
     * @param clazz The input class
     */
    public static void registerClass(Class<?> clazz) {
        testClazzes.add(clazz);
    }

    /**
     * Executes all registered tests.
     */
    public static void executeTests() {
        ExecutorService executor = Executors.newFixedThreadPool(1);

        List<Runnable> runnables = new ArrayList<>();

        for (Class<?> testClass: testClazzes) {
            runnables.add(new TestContainer(testClass));
        }

        
        for (Runnable r : runnables) {
            Future<?> future = executor.submit(r);

            try {
                future.get(15, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                
            } catch (ExecutionException e) {                
                e.getCause().printStackTrace();
            } catch (TimeoutException e) {
                future.cancel(true);

                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " FAILED: \u00BB ") + " A test failed by exceeding the time limit. You likely have an infinite loop somewhere.");

                System.exit(-1);
            }

        }

        executor.shutdown();

        StringUtils.printHorizontalLine();

        StringUtils.printTextCentered("Test Results");
        System.out.println();
        StringUtils.printTextCentered(
                String.format("TOTAL TESTS PASSED: %d/%d", classTests.get() - classTestsFailed.get(), classTests.get()));
        StringUtils.printHorizontalLine();

    }

    /**
     * Prints a formatted test category section
     * 
     * @param category The name of the section (most likely the class name)
     */
    protected static void printTestCategory(String category) {
        StringUtils.printHorizontalLine();
        StringUtils.printTextCentered(category);
        System.out.println();
    }

    protected static void submitTest(int result) {
        // classTests++;
        // classTestsFailed += result;
    }
}

//AUTOGENERATED FROM ../src/Tip.java

@Retention(RetentionPolicy.RUNTIME)
@interface Tip {
    /**
     * Used to display a helpful tip when the user fails a test.
     * 
     * @return The main tip body message
     */
    public String description() default "";
}

//AUTOGENERATED FROM ../src/EqualsTests.java
class EqualsTests {
    private static final Media[] MEDIA = new Media[] {
        new MediaTests.MediaSubclass(Genre.COMEDY, "Ghostbusters", 99, 6.70),
        new Movie(Genre.COMEDY, "Ghostbusters", 99, 6.70, 120),
        new VideoGame(Genre.ACTION, "Ghostbusters", 99, 6.70, 2, true)
    };

    @TestCase(name = "Testing .equals() method of Media and all subclasses to ensure symmetry (not necessarily correctness)")
    @Tip(description = "\nHow can you ensure symmetry in the .equals() method? What should be compared before each field?")
    public void equalsSymmetryTest() throws TestFailedException {

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (MEDIA[i].equals(MEDIA[j]) != MEDIA[j].equals(MEDIA[i])) {
                    System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                                AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " SYMMETRY TEST FAILED: \u00BB ") + "\nWhen "
                                + "media1 = \"" + MEDIA[i].toString() + "\", media2 = \"" + MEDIA[j].toString() + "\"");
                    TestFunction.assertEqual(MEDIA[i].equals(MEDIA[j]), MEDIA[j].equals(MEDIA[i]));
                }
            }
        }
    }

    @TestCase(name = "Testing .equals() method of Media and all subclasses for correctness")
    @Tip(description = "\nWhat fields should be compared for the .equals() method? How should .equals() behave when comparing different classes?")
    public void equalsCorrectnessTest() throws TestFailedException {
        boolean[][] correctAnswers = new boolean[][] {{true, false, false}, {false, true, false}, {false, false, true}};

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (MEDIA[i].equals(MEDIA[j]) != correctAnswers[i][j]) {
                    System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                                AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " .EQUALS() TEST FAILED: \u00BB ") + "\nWhen "
                                + "media1 = \"" + MEDIA[i].toString() + "\", media2 = \"" + MEDIA[j].toString() + "\"");
                    TestFunction.assertEqual(MEDIA[i].equals(MEDIA[j]), MEDIA[j].equals(MEDIA[i]));
                }
            }
        }
    }
}
//AUTOGENERATED FROM ../src/VideoGameTests.java
class VideoGameTests {

    private static final String[] NAMES = new String[] {"Lord of the Rings 1", "Lord of the Rings 2", "Lord of the Rings 3"};
    private static final int[] RATINGS = new int[] {7, 8, 9};
    private static final double[] PRICES = new double[] {9.71, 9.72, 9.73};
    private static final int[] PLAYERS = new int[] {1, 2, 3};


    @TestCase(name = "Testing the default 6-arg constructor with a game that DOES NOT need a console.")
    @Tip(description = "What args should the constructor receive?")
    public void sixArgConstructorFalse() throws TestFailedException {

        VideoGame movie = new VideoGame(Genre.ACTION, "MyMovie", 18, 6.70, 4, false);

        TestFunction.assertEqual(movie.toString(), "Genre: ACTION, Name: MyMovie, Rating: 18, Rental Price: $6.70, Players: 4, does not need console");
    }

    @TestCase(name = "Testing the default 6-arg constructor with a game that DOES need a console.")
    @Tip(description = "What args should the constructor receive?")
    public void sixArgConstructorTrue() throws TestFailedException {

        VideoGame movie = new VideoGame(Genre.ACTION, "MyMovie", 18, 6.70, 4, true);

        TestFunction.assertEqual(movie.toString(), "Genre: ACTION, Name: MyMovie, Rating: 18, Rental Price: $6.70, Players: 4, does need console");
    }

    @TestCase(name = "Testing the default 3-arg constructor")
    @Tip(description = "What args should the constructor receive? What should rentalPrice, runtime, and needsConsole default to?")
    public void threeArgConstructor() throws TestFailedException {

        VideoGame movie = new VideoGame(Genre.ACTION, "My Movie 2", 18);

        TestFunction.assertEqual(movie.toString(), "Genre: ACTION, Name: My Movie 2, Rating: 18, Rental Price: $5.00, Players: 2, does not need console");
    }

    @TestCase(name = ".equals(): All arguments are equal")
    @Tip(description = "What fields must be equal for VideoGames to be equal?")
    public void equalsEqual() throws TestFailedException {

        VideoGame game1 = new VideoGame(Genre.ACTION, "My Movie 2", 18, 6.70, 2, false);
        VideoGame game2 = new VideoGame(Genre.ACTION, "My Movie 2", 18, 6.70, 2, false);

        TestFunction.assertEqual(game1.equals(game2), true);
    }

    @TestCase(name = ".equals(): Genres are not equal")
    @Tip(description = "What fields must be equal for VideoGames to be equal?")
    public void equalsGenresNotEqual() throws TestFailedException {

        VideoGame game1 = new VideoGame(Genre.ACTION, "My Movie 2", 18, 6.70, 2, false);
        VideoGame game2 = new VideoGame(Genre.COMEDY, "My Movie 2", 19, 6.70, 2, false);

        TestFunction.assertEqual(game1.equals(game2), false);
    }

    @TestCase(name = ".equals(): Titles are not equal")
    @Tip(description = "What fields must be equal for VideoGames to be equal?")
    public void equalsTitlesNotEqual() throws TestFailedException {

        VideoGame game1 = new VideoGame(Genre.ACTION, "My Movie 1", 18, 6.70, 2, false);
        VideoGame game2 = new VideoGame(Genre.ACTION, "My Movie 2", 18, 6.70, 2, false);

        TestFunction.assertEqual(game1.equals(game2), false);
    }

    @TestCase(name = ".equals(): ratings are not equal")
    @Tip(description = "What fields must be equal for VideoGames to be equal?")
    public void equalsRatingsNotEqual() throws TestFailedException {

        VideoGame game1 = new VideoGame(Genre.ACTION, "My Movie 2", 18, 6.70, 2, false);
        VideoGame game2 = new VideoGame(Genre.ACTION, "My Movie 2", 19, 6.70, 2, false);

        TestFunction.assertEqual(game1.equals(game2), false);
    }

    @TestCase(name = ".equals(): Rental prices are not equal")
    @Tip(description = "What fields must be equal for VideoGames to be equal?")
    public void equalsRentalPricesNotEqual() throws TestFailedException {

        VideoGame game1 = new VideoGame(Genre.ACTION, "My Movie 2", 18, 6.71, 2, false);
        VideoGame game2 = new VideoGame(Genre.ACTION, "My Movie 2", 18, 6.70, 2, false);

        TestFunction.assertEqual(game1.equals(game2), false);
    }

    @TestCase(name = ".equals(): players are not equal")
    @Tip(description = "What fields must be equal for VideoGames to be equal?")
    public void equalsPlayersNotEqual() throws TestFailedException {

        VideoGame game1 = new VideoGame(Genre.ACTION, "My Movie 2", 18, 6.70, 3, false);
        VideoGame game2 = new VideoGame(Genre.ACTION, "My Movie 2", 18, 6.70, 2, false);

        TestFunction.assertEqual(game1.equals(game2), false);
    }

    @TestCase(name = ".compareTo(): Tests many different possible VideoGames")
    @Tip(description = "What fields should compareTo() compare? Which fields should compareTo() NOT compare?")
    public void compareToTest() throws TestFailedException {

        VideoGame[] gamePossibilities = getPossibleGamesForCompareTo();
        int[] correctAnswers = new int[] {
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            0, 0, 0, 0, 0, 0, 0, 0, 0,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        VideoGame media1 = new VideoGame(Genre.COMEDY, "Lord of the Rings 2", 8, 9.72, 2, true);
        for (int i = 0; i < gamePossibilities.length; i++) {
            VideoGame media2 = gamePossibilities[i];
            int comparison = media1.compareTo(media2);
            if (comparison != correctAnswers[i]) {
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                        AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " COMPARETO() TEST FAILED: \u00BB ") + "\nWhen the implicit VideoGame is \n\""
                        + media1.toString() + "\", and the other VideoGame is \n\""
                        + media2.toString() + "\"");

                TestFunction.assertEqual(TestUtils.signOf(media1.compareTo(media2)), correctAnswers[i]);
            }
        }
    }

    /**
     * Returns 81 possible media. This is generalizeable, but it's only for the compareTo() check, so I'm OK with hard-coding some values,
     * in exchange for improved readability.
     * @return
     */
    private VideoGame[] getPossibleGamesForCompareTo() {

        VideoGame[] possibilities = new VideoGame[81];
        
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                for (int k = 0; k < 3; k++) {
                    for (int l = 0; l < 3; l++) {
                        possibilities[i * 27 + j * 9 + k * 3 + l] = new VideoGame(Genre.COMEDY, NAMES[i], RATINGS[j], PRICES[k], PLAYERS[l], i % 2 == 0);
                    }
                }
            }
        }

        return possibilities;
    }



    /**
     * Media subclass, just for testing.
     */
    class MediaSubclass extends Media {
        public MediaSubclass(Genre genre, String name, int rating, double rentalPrice) {
            super(genre, name, rating, rentalPrice);
        }

        public MediaSubclass(Genre genre, String name, int rating) {
            super(genre, name, rating);
        }
    }
}
//AUTOGENERATED FROM ../src/AsciiColorCode.java
final class AsciiColorCode {

    public static final String RESET_COLOR = "\033[0m";

    public static final String BLACK_FOREGROUND = "\033[30m";
    public static final String BLACK_BACKGROUND = "\033[40m";

    public static final String RED_FOREGROUND = "\033[31m";
    public static final String RED_BACKGROUND = "\033[41m";

    public static final String GREEN_FOREGROUND = "\033[32m";
    public static final String GREEN_BACKGROUND = "\033[42m";

    public static final String YELLOW_FOREGROUND = "\033[33m";
    public static final String YELLOW_BACKGROUND = "\033[43m";

    public static final String BLUE_FOREGROUND = "\033[34m";
    public static final String BLUE_BACKGROUND = "\033[44m";

    public static final String MAGENTA_FOREGROUND = "\033[35m";
    public static final String MAGENTA_BACKGROUND = "\033[45m";

    public static final String CYAN_FOREGROUND = "\033[36m";
    public static final String CYAN_BACKGROUND = "\033[46m";

    public static final String WHITE_FOREGROUND = "\033[37m";
    public static final String WHITE_BACKGROUND = "\033[47m";

    public static final String BRIHGT_BLACK_FOREGROUND = "\033[90m";
    public static final String BRIGHT_BLACK_BACKGROUND = "\033[100m";

    public static final String BRIGHT_RED_FOREGROUND = "\033[91m";
    public static final String BRIGHT_RED_BACKGROUND = "\033[101m";

    public static final String BRIGHT_GREEN_FOREGROUND = "\033[92m";
    public static final String BRIGHT_GREEN_BACKGROUND = "\033[102m";

    public static final String BRIGHT_YELLOW_FOREGROUND = "\033[93m";
    public static final String BRIGHT_YELLOW_BACKGROUND = "\033[103m";

    public static final String BRIGHT_BLUE_FOREGROUND = "\033[94m";
    public static final String BRIGHT_BLUE_BACKGROUND = "\033[104m";

    public static final String BRIGHT_MAGENTA_FOREGROUND = "\033[95m";
    public static final String BRIGHT_MAGENTA_BACKGROUND = "\033[105m";

    public static final String BRIGHT_CYAN_FOREGROUND = "\033[96m";
    public static final String BRIGHT_CYAN_BACKGROUND = "\033[106m";

    public static final String BRIGHT_WHITE_FOREGROUND = "\033[97m";
    public static final String BRIGHT_WHITE_BACKGROUND = "\033[107m";
}

//AUTOGENERATED FROM ../src/GenreTests.java
class GenreTests {
    @TestCase(name = "Testing that all 7 genres exist in the correct order...")
    @Tip(description = "\nHow many genres should there be? What order should they be in?")
    public void genresExistInCorrectOrder() throws TestFailedException {
        String[] correctGenres = new String[] {"ACTION", "COMEDY", "FANTASY", "HORROR", "MYSTERY", "ROMANCE", "SCI_FI"};
        Genre[] genres = Genre.values();
        for (int i = 0; i < 7; i++) {
            TestFunction.assertEqual(genres[i].toString(), correctGenres[i]);
        }
    }
}

//AUTOGENERATED FROM ../src/HW05Driver.java
class Driver {
    public static void main(String[] args) {        // Add classes to test here
        TestManager.runTestsOn(GenreTests.class, MediaTests.class, MovieTests.class, VideoGameTests.class, BlockbusterTests.class, OliviaTests.class, EqualsTests.class);
    }
}

//AUTOGENERATED FROM ../src/Arraylist.java

class Arraylist<T> {

}

//AUTOGENERATED FROM ../src/OliviaTests.java

class OliviaTests {
    @TestCase(name = ".addToCart(): Correct movie is found")
    @Tip(description = "What should be in the cart after the specified Media is found?")
    public void addToCartAddedToCart() throws TestFailedException {

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(BlockbusterTests.MOVIE_LIST);
        store.sortMedia();
        Olivia olivia = fakeConstructorOlivia();
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120);
        olivia.addToCart(movie, store);

        TestFunction.assertEqual(BlockbusterTests.arrayToString(getCart(olivia)), "Genre: ACTION, Name: Fast and Furious 1, Rating: 54, Rental Price: $6.70, Runtime: 120");
    }



    @TestCase(name = ".addToCart(): Correct movie is removed from the store")
    @Tip(description = "Make sure that the correct Media is removed from the store!")
    public void addToCartRemovedFromStore() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 2", 37, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 3", 38, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 4", 28, 6.70, 120));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        store.sortMedia();
        Olivia olivia = fakeConstructorOlivia();
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120);
        olivia.addToCart(movie, store);

        TestFunction.assertEqual(BlockbusterTests.arrayToString(BlockbusterTests.getInventory(store)), "Genre: ACTION, Name: Fast and Furious 2, Rating: 37, Rental Price: $6.70, Runtime: 120\nGenre: ACTION, Name: Fast and Furious 3, Rating: 38, Rental Price: $6.70, Runtime: 120\nGenre: ACTION, Name: Fast and Furious 4, Rating: 28, Rental Price: $6.70, Runtime: 120");
    }



    @TestCase(name = ".addToCart(): Correct movie is added to the cart")
    @Tip(description = "If the test \".addToCart(): Correct movie is removed from the store\" is passing, make sure that you're adding the object from the store, not the one passed into addToCart()!")
    public void addToCartCopyIsAdded() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 2", 37, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 3", 38, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 4", 28, 6.70, 120));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        store.sortMedia();
        Olivia olivia = fakeConstructorOlivia();
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120);
        olivia.addToCart(movie, store);

        TestFunction.assertEqual(movie == getCart(olivia).get(0) && getCart(olivia).get(0) != null, false);
    }



    @TestCase(name = ".addToCart(): Returns true when movie is added to the cart")
    @Tip(description = "What should addToCart() return?")
    public void addToCartReturnsTrue() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 2", 37, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 3", 38, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 4", 28, 6.70, 120));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        store.sortMedia();
        Olivia olivia = fakeConstructorOlivia();
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120);
        boolean returned = olivia.addToCart(movie, store);

        TestFunction.assertEqual(returned, true);
    }



    @TestCase(name = ".addToCart(): Updates budget when movie is added to the cart")
    @Tip(description = "What should get deducted from Olivia's budget?")
    public void addToCartBudgetUpdates() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 2", 37, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 3", 38, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 4", 28, 6.70, 120));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        store.sortMedia();
        Olivia olivia = fakeConstructorOlivia();
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120);
        olivia.addToCart(movie, store);
        double budget = getBudget(olivia);

        TestFunction.assertEqual(budget, 13.30);
    }



    @TestCase(name = ".addToCart(): Returns false when Media is not found")
    @Tip(description = "What should addToCart() return?")
    public void addToCartReturnsFalse() throws TestFailedException {

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(BlockbusterTests.MOVIE_LIST);
        store.sortMedia();
        Olivia olivia = fakeConstructorOlivia();
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 11", 54, 6.70, 120);
        boolean returned = olivia.addToCart(movie, store);

        TestFunction.assertEqual(returned, false);
    }



    @TestCase(name = ".addToCart(): Returns false when Olivia has an insufficient budget")
    @Tip(description = "What should addToCart() return when Olivia has insufficient budget?")
    public void addToCartReturnsFalseWhenBudget() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new Movie(Genre.ACTION, "Fast and Furious 1", 54, 21.0, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 2", 37, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 3", 38, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 4", 28, 6.70, 120));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        Olivia olivia = fakeConstructorOlivia();
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 21.0, 120);
        boolean returned = olivia.addToCart(movie, store);

        TestFunction.assertEqual(returned, false);
    }



    @TestCase(name = ".addToCart(): Cart is still empty if budget is insufficient")
    @Tip(description = "What should addToCart() return when Olivia has insufficient budget?")
    public void addToCartHasEmptyCartWhenBudget() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new Movie(Genre.ACTION, "Fast and Furious 1", 54, 21.0, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 2", 37, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 3", 38, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 4", 28, 6.70, 120));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        store.sortMedia();
        Olivia olivia = fakeConstructorOlivia();
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 21.0, 120);
        olivia.addToCart(movie, store);
        ArrayList<Media> cart = getCart(olivia);

        TestFunction.assertEqual(BlockbusterTests.arrayToString(cart), "");
    }



    @TestCase(name = ".addToCart(): Cart is still empty if game requires console and Olivia cannot use console")
    @Tip(description = "What should Olivia's cart contain if she couldn't add the Media?")
    public void addToCartCartEmptyWhenConsoleRequired() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new VideoGame(Genre.ACTION, "Uncharted 1", 54, 6.70, 2, true));
                add(new VideoGame(Genre.ACTION, "Uncharted 2", 37, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 3", 38, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 4", 28, 6.70, 2, false));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        store.sortMedia();
        Olivia olivia = fakeConstructorOlivia();
        VideoGame game = new VideoGame(Genre.ACTION, "Uncharted 1", 54, 6.70, 2, true);
        olivia.addToCart(game, store);
        ArrayList<Media> cart = getCart(olivia);

        TestFunction.assertEqual(BlockbusterTests.arrayToString(cart), "");
    }



    @TestCase(name = ".addToCart(): Returns false when Olivia cannot use console and the VideoGame requires one")
    @Tip(description = "What should addToCart() return when Olivia requires a console?")
    public void addToCartReturnsFalseWhenConsole() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new VideoGame(Genre.ACTION, "Uncharted 1", 54, 6.70, 2, true));
                add(new VideoGame(Genre.ACTION, "Uncharted 2", 37, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 3", 38, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 4", 28, 6.70, 2, false));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        Olivia olivia = fakeConstructorOlivia();
        VideoGame game = new VideoGame(Genre.ACTION, "Uncharted 1", 54, 6.70, 2, true);
        boolean returned = olivia.addToCart(game, store);

        TestFunction.assertEqual(returned, false);
    }

    @TestCase(name = ".addToCart(): Returns true when Olivia can use console and the VideoGame requires one")
    @Tip(description = "What should addToCart() return when Olivia requires a console?")
    public void addToCartReturnsTrueWhenConsole() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new VideoGame(Genre.ACTION, "Uncharted 1", 54, 6.70, 2, true));
                add(new VideoGame(Genre.ACTION, "Uncharted 2", 37, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 3", 38, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 4", 28, 6.70, 2, false));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        Olivia olivia = fakeConstructorOlivia(20.0, new ArrayList<Media>(), true);
        VideoGame game = new VideoGame(Genre.ACTION, "Uncharted 1", 54, 6.70, 2, true);
        boolean returned = olivia.addToCart(game, store);

        TestFunction.assertEqual(returned, true);
    }

    @TestCase(name = ".changeMind(): Removes the given media from the cart")
    @Tip(description = "What method should changeMind() use to determine if the Media is in the cart?")
    public void changeMindRemovesFromCart() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new VideoGame(Genre.ACTION, "Uncharted 2", 37, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 3", 38, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 4", 28, 6.70, 2, false));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        VideoGame game = new VideoGame(Genre.ACTION, "Uncharted 1", 54, 6.70, 2, true);
        Olivia olivia = fakeConstructorOlivia(20.0, new ArrayList<Media>() {{add(game);}}, true);
        olivia.changeMind(game, store);
        ArrayList<Media> cart = getCart(olivia);

        TestFunction.assertEqual(BlockbusterTests.arrayToString(cart), "");
    }



    @TestCase(name = ".changeMind(): Adds the removed media to the store")
    @Tip(description = "Make sure that you're adding the media back from the cart to the store!")
    public void changeMindAddsToStore() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new VideoGame(Genre.ACTION, "Uncharted 2", 37, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 3", 38, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 4", 28, 6.70, 2, false));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        VideoGame game = new VideoGame(Genre.ACTION, "Uncharted 1", 54, 6.70, 2, false);
        Olivia olivia = fakeConstructorOlivia(20.0, new ArrayList<Media>() {{add(game);}}, true);
        olivia.changeMind(game, store);
        store.sortMedia();
        ArrayList<Media> inventory = BlockbusterTests.getInventory(store);

        TestFunction.assertEqual(BlockbusterTests.arrayToString(inventory), "Genre: ACTION, Name: Uncharted 1, Rating: 54, "
                                 + "Rental Price: $6.70, Players: 2, does not need console\n"
                                 + "Genre: ACTION, Name: Uncharted 2, Rating: 37, Rental Price: "
                                 + "$6.70, Players: 2, does not need console\n"
                                 + "Genre: ACTION, Name: Uncharted 3, Rating: 38, "
                                 + "Rental Price: $6.70, Players: 2, does not need console\n"
                                 + "Genre: ACTION, Name: Uncharted 4, Rating: 28, "
                                 + "Rental Price: $6.70, Players: 2, does not need console");
    }



    @TestCase(name = ".changeMind(): Updates budget accordingly")
    @Tip(description = "Make sure that the budget is updated properly!")
    public void changeMindUpdatesBudget() throws TestFailedException {
        ArrayList<Media> modifiedList = new ArrayList<Media>() {
            {
                add(new VideoGame(Genre.ACTION, "Uncharted 2", 37, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 3", 38, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 4", 28, 6.70, 2, false));
            }
        };

        Blockbuster store = BlockbusterTests.fakeConstructorBlockbuster(modifiedList);
        VideoGame game = new VideoGame(Genre.ACTION, "Uncharted 1", 54, 6.70, 2, false);
        Olivia olivia = fakeConstructorOlivia(20.0, new ArrayList<Media>() {{add(game);}}, true);
        olivia.changeMind(game, store);
        double budget = getBudget(olivia);

        TestFunction.assertEqual(budget, 26.70);
    }



    private static Olivia fakeConstructorOlivia() throws TestFailedException {
        return fakeConstructorOlivia(20.0, new ArrayList<Media>(), false);
    }



    private static Olivia fakeConstructorOlivia(double budget, ArrayList<Media> cart, boolean canUseConsole) throws TestFailedException {

        Olivia olivia = new Olivia();

        Field[] fields = Olivia.class.getDeclaredFields();
        Field budgetField = null;
        Field cartField = null;
        Field canUseConsoleField = null;

        for (int i = 0; i < fields.length; i++) {

            if (fields[i].getName() == "budget") {
                budgetField = fields[i];
            }

            if (fields[i].getName() == "cart") {
                cartField = fields[i];
            }

            if (fields[i].getName() == "canUseConsole") {
                canUseConsoleField = fields[i];
            }
        }

        try {
            budgetField.setAccessible(true);
            budgetField.set(olivia, budget);
            cartField.setAccessible(true);
            cartField.set(olivia, cart);
            canUseConsoleField.setAccessible(true);
            canUseConsoleField.set(olivia, canUseConsole);
        } catch (Exception e) {
            TestFunction.failTest("An error occurred. " + e.getMessage());
        }

        return olivia;
    }



    private static ArrayList<Media> getCart(Olivia olivia) {
        Field[] fields = Olivia.class.getDeclaredFields();
        Field cart = null;

        for (int i = 0; i < fields.length; i++) {
            if (fields[i].getName() == "cart") {
                cart = fields[i];
                break;
            }
        }

        if (cart != null) {
            try {

                cart.setAccessible(true);
                return (ArrayList<Media>) cart.get(olivia);

            } catch (IllegalArgumentException e) {

                System.out.println("Test could not be run.");
                e.printStackTrace();

            } catch (IllegalAccessException e) {

                System.out.println("Test could not be run.");
                e.printStackTrace();

            }
        }
        return null;
    }

    private static double getBudget(Olivia olivia) {

        Field[] fields = Olivia.class.getDeclaredFields();
        Field budget = null;

        for (int i = 0; i < fields.length; i++) {
            if (fields[i].getName() == "budget") {
                budget = fields[i];
                break;
            }
        }

        if (budget != null) {
            try {
                budget.setAccessible(true);
                return (double) budget.get(olivia);
            } catch (IllegalArgumentException e) {
                System.out.println("Test could not be run.");
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                System.out.println("Test could not be run.");
                e.printStackTrace();
            }
        }

        return -1.0;
    }
}

//AUTOGENERATED FROM ../src/TestFailedException.java
/**
 * A custom exception used for detecting tests failed.
 */
class TestFailedException extends Exception {
    public TestFailedException() {
    }

    public TestFailedException(String message) {
        super(message);
    }
}

//AUTOGENERATED FROM ../src/MovieTests.java
class MovieTests {

    private static final String[] NAMES = new String[] {"Lord of the Rings 1", "Lord of the Rings 2", "Lord of the Rings 3"};
    private static final int[] RATINGS = new int[] {7, 8, 9};
    private static final double[] PRICES = new double[] {9.71, 9.72, 9.73};
    private static final int[] RUNTIMES = new int[] {119, 120, 121};


    @TestCase(name = "Testing the default 5-arg constructor")
    @Tip(description = "What args should the constructor receive?")
    public void fiveArgConstructor() throws TestFailedException {

        Movie movie = new Movie(Genre.ACTION, "MyMovie", 18, 6.70, 120);

        TestFunction.assertEqual(movie.toString(), "Genre: ACTION, Name: MyMovie, Rating: 18, Rental Price: $6.70, Runtime: 120");
    }

    @TestCase(name = "Testing the default 3-arg constructor")
    @Tip(description = "What args should the constructor receive? What should rentalPrice and runtime default to?")
    public void threeArgConstructor() throws TestFailedException {

        Movie movie = new Movie(Genre.ACTION, "My Movie 2", 18);

        TestFunction.assertEqual(movie.toString(), "Genre: ACTION, Name: My Movie 2, Rating: 18, Rental Price: $5.00, Runtime: 111");
    }

    @TestCase(name = ".equals(): Parameters are equal")
    @Tip(description = "What fields must be equal for Movies to be equal?")
    public void equalsEquals() throws TestFailedException {

        Movie movie1 = new Movie(Genre.ACTION, "My Movie 2", 18, 6.70, 120);
        Movie movie2 = new Movie(Genre.ACTION, "My Movie 2", 18, 6.70, 120);

        TestFunction.assertEqual(movie1.equals(movie2), true);
    }

    @TestCase(name = ".equals(): Genres are not equal")
    @Tip(description = "What fields must be equal for Movies to be equal?")
    public void equalsGenreNotEqual() throws TestFailedException {

        Movie movie1 = new Movie(Genre.ACTION, "My Movie 2", 18, 6.70, 120);
        Movie movie2 = new Movie(Genre.COMEDY, "My Movie 2", 18, 6.70, 120);

        TestFunction.assertEqual(movie1.equals(movie2), false);
    }

    @TestCase(name = ".equals(): Titles are not equal")
    @Tip(description = "What fields must be equal for Movies to be equal?")
    public void equalsTitlesNotEqual() throws TestFailedException {

        Movie movie1 = new Movie(Genre.ACTION, "My Movie 1", 18, 6.70, 120);
        Movie movie2 = new Movie(Genre.ACTION, "My Movie 2", 18, 6.70, 120);

        TestFunction.assertEqual(movie1.equals(movie2), false);
    }

    @TestCase(name = ".equals(): Ratings are not equal")
    @Tip(description = "What fields must be equal for Movies to be equal?")
    public void equalsRatingsNotEqual() throws TestFailedException {

        Movie movie1 = new Movie(Genre.ACTION, "My Movie 2", 19, 6.70, 120);
        Movie movie2 = new Movie(Genre.ACTION, "My Movie 2", 18, 6.70, 120);

        TestFunction.assertEqual(movie1.equals(movie2), false);
    }

    @TestCase(name = ".equals(): RentalPrices are not equal")
    @Tip(description = "What fields must be equal for Movies to be equal?")
    public void equalsRentalPriceNotEqual() throws TestFailedException {

        Movie movie1 = new Movie(Genre.ACTION, "My Movie 2", 18, 6.71, 120);
        Movie movie2 = new Movie(Genre.ACTION, "My Movie 2", 18, 6.70, 120);

        TestFunction.assertEqual(movie1.equals(movie2), false);
    }

    @TestCase(name = ".equals(): runtimes are not equal")
    @Tip(description = "What fields must be equal for Movies to be equal?")
    public void equalsRuntimesNotEqual() throws TestFailedException {

        Movie movie1 = new Movie(Genre.ACTION, "My Movie 2", 18, 6.70, 121);
        Movie movie2 = new Movie(Genre.ACTION, "My Movie 2", 18, 6.70, 120);

        TestFunction.assertEqual(movie1.equals(movie2), false);
    }

    @TestCase(name = ".compareTo(): Tests many different possible Movies")
    @Tip(description = "What fields should compareTo() compare? Which fields should compareTo() NOT compare?")
    public void compareToTest() throws TestFailedException {

        Movie[] moviePossibilities = getPossibleMoviesForEquals();
        int[] correctAnswers = new int[] {
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            0, 0, 0, 0, 0, 0, 0, 0, 0,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        Movie media1 = new Movie(Genre.COMEDY, "Lord of the Rings 2", 8, 9.72, 120);
        for (int i = 0; i < moviePossibilities.length; i++) {
            Movie media2 = moviePossibilities[i];
            int comparison = media1.compareTo(media2);
            if (comparison != correctAnswers[i]) {
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                        AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " COMPARETO() TEST FAILED: \u00BB ") + "\nWhen the implicit Movie is \n\""
                        + media1.toString() + "\" and the other Movie is\n\""
                        + media2.toString() + "\"");

                TestFunction.assertEqual(TestUtils.signOf(media1.compareTo(media2)), correctAnswers[i]);
            }
        }
    }

    /**
     * Returns 81 possible media. This is generalizeable, but it's only for the compareTo() check, so I'm OK with hard-coding some values,
     * in exchange for improved readability.
     * @return
     */
    private Movie[] getPossibleMoviesForEquals() {

        Movie[] possibilities = new Movie[81];
        
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                for (int k = 0; k < 3; k++) {
                    for (int l = 0; l < 3; l++) {
                        possibilities[i * 27 + j * 9 + k * 3 + l] = new Movie(Genre.COMEDY, NAMES[i], RATINGS[j], PRICES[k], RUNTIMES[l]);
                    }
                }
            }
        }

        return possibilities;
    }



    /**
     * Media subclass, just for testing.
     */
    class MediaSubclass extends Media {
        public MediaSubclass(Genre genre, String name, int rating, double rentalPrice) {
            super(genre, name, rating, rentalPrice);
        }

        public MediaSubclass(Genre genre, String name, int rating) {
            super(genre, name, rating);
        }
    }
}
//AUTOGENERATED FROM ../src/TestContainer.java

class TestContainer implements Runnable {
        private Class<?> clazz;

        /**
         * Initializes a new TestContainer. A TestContainer is used to prevent certain edge cases such as infinite loops.
         * 
         * If an infinite loop occurs, the test will timeout and notify the user accordingly.
         * @param clazz The class containing the tests
         */
        public TestContainer(Class<?> clazz) {
            this.clazz = clazz;
        }

        @Override
        public void run() {
            try {
                TestManager.printTestCategory(clazz.getName());

                Object instance = clazz.getDeclaredConstructor().newInstance();

                int classTests = 0;
                int classTestsFailed = 0;

                for (Method m : clazz.getMethods()) {
                    TestCase testCase = m.getAnnotation(TestCase.class);
                    Tip tip = m.getAnnotation(Tip.class);

                    if (testCase != null) {
                        try {

                            m.invoke(instance);

                            System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_GREEN_BACKGROUND,
                                    AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " PASSED: \u00BB ") + " "
                                    + testCase.name());

                            TestManager.submitTest(0);
                        } catch (InvocationTargetException e) {
                            System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                                    AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " FAILED: \u00BB ") + " "
                                    + testCase.name());

                            classTestsFailed++;

                            if (e.getCause() instanceof TestFailedException) {
                                TestFailedException tfe = (TestFailedException) e.getCause();

                                System.out.println("\t" + tfe.getMessage());

                                if (tip != null)
                                    System.out.printf("\tHINT: %s\n", tip.description());
                            } else {
                                System.out.println(ColorUtils.formatColorString(AsciiColorCode.WHITE_BACKGROUND, AsciiColorCode.RED_FOREGROUND, "\tThe executed code caused the following exception. This is NOT the fault of the driver."));

                                e.getCause().printStackTrace();
                            }
                        } catch (IllegalAccessException e) {
                            e.printStackTrace();
                        } catch (IllegalArgumentException e) {
                            e.printStackTrace();
                        }

                        classTests++;


                    }
                }

                TestManager.classTests.set(TestManager.classTests.get() + classTests);
                TestManager.classTestsFailed.set(TestManager.classTestsFailed.get() + classTestsFailed);

                System.out.println();
                StringUtils.printTextCentered(
                        String.format("TESTS PASSED: %d/%d", classTests - classTestsFailed, classTests));

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
//AUTOGENERATED FROM ../src/MediaTests.java
class MediaTests {

    private static final Genre[] GENRES = new Genre[] {Genre.ACTION, Genre.COMEDY, Genre.FANTASY};
    private static final String[] NAMES = new String[] {"Lord of the Rings 1", "Lord of the Rings 2", "Lord of the Rings 3"};
    private static final int[] RATINGS = new int[] {7, 8, 9};
    private static final double[] PRICES = new double[] {9.71, 9.72, 9.73};


    @TestCase(name = "Testing the default 4-arg constructor")
    @Tip(description = "What args should the constructor receive?")
    public void fourArgConstructor() throws TestFailedException {

        Media media = new MediaSubclass(Genre.ACTION, "MyMovie", 18, 6.70);

        TestFunction.assertEqual(media.toString(), "Genre: ACTION, Name: MyMovie, Rating: 18, Rental Price: $6.70");
    }

    @TestCase(name = "Testing the default 3-arg constructor")
    @Tip(description = "What args should the constructor receive? What should rentalPrice default to?")
    public void threeArgConstructor() throws TestFailedException {

        Media media = new MediaSubclass(Genre.ACTION, "My Movie 2", 18);

        TestFunction.assertEqual(media.toString(), "Genre: ACTION, Name: My Movie 2, Rating: 18, Rental Price: $7.00");
    }

    @TestCase(name = ".equals(): Parameters are equal")
    @Tip(description = "What fields must be equal for Media to be equal?")
    public void equalsEquals() throws TestFailedException {

        Media media1 = new MediaSubclass(Genre.ACTION, "My Movie 2", 18, 6.70);
        Media media2 = new MediaSubclass(Genre.ACTION, "My Movie 2", 18, 6.70);

        TestFunction.assertEqual(media1.equals(media2), true);
    }

    @TestCase(name = ".equals(): Genres are not equal")
    @Tip(description = "What fields must be equal for Media to be equal?")
    public void equalsGenreNotEqual() throws TestFailedException {

        Media media1 = new MediaSubclass(Genre.ACTION, "My Movie 2", 18, 6.70);
        Media media2 = new MediaSubclass(Genre.COMEDY, "My Movie 2", 18, 6.70);

        TestFunction.assertEqual(media1.equals(media2), false);
    }

    @TestCase(name = ".equals(): Titles are not equal")
    @Tip(description = "What fields must be equal for Media to be equal?")
    public void equalsTitlesNotEqual() throws TestFailedException {

        Media media1 = new MediaSubclass(Genre.ACTION, "My Movie 1", 18, 6.70);
        Media media2 = new MediaSubclass(Genre.ACTION, "My Movie 2", 18, 6.70);

        TestFunction.assertEqual(media1.equals(media2), false);
    }

    @TestCase(name = ".equals(): Ratings are not equal")
    @Tip(description = "What fields must be equal for Media to be equal?")
    public void equalsRatingsNotEqual() throws TestFailedException {

        Media media1 = new MediaSubclass(Genre.ACTION, "My Movie 1", 19, 6.70);
        Media media2 = new MediaSubclass(Genre.ACTION, "My Movie 2", 18, 6.70);

        TestFunction.assertEqual(media1.equals(media2), false);
    }

    @TestCase(name = ".equals(): RentalPrices are not equal")
    @Tip(description = "What fields must be equal for Media to be equal?")
    public void equalsRentalPriceNotEqual() throws TestFailedException {

        Media media1 = new MediaSubclass(Genre.ACTION, "My Movie 1", 19, 9.71);
        Media media2 = new MediaSubclass(Genre.ACTION, "My Movie 2", 18, 6.70);

        TestFunction.assertEqual(media1.equals(media2), false);
    }

    @TestCase(name = ".compareTo(): Tests many different possible Media")
    @Tip(description = "What fields should compareTo() compare? Which fields should compareTo() NOT compare?")
    public void compareToTest() throws TestFailedException {

        Media[] mediaPossibilities = getPossibleMediaForEquals();
        int[] correctAnswers = new int[] {
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 0, 0, 0, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        Media media1 = new MediaSubclass(Genre.COMEDY, "Lord of the Rings 2", 8, 9.72);
        for (int i = 0; i < mediaPossibilities.length; i++) {
            Media media2 = mediaPossibilities[i];
            int comparison = media1.compareTo(media2);
            if (comparison != correctAnswers[i]) {
                System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                        AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " COMPARETO() TEST FAILED: \u00BB ") + "\nWhen the implicit Media is\n\""
                        + media1.toString() + "\" and the other Media is\n\""
                        + media2.toString() + "\"");

                TestFunction.assertEqual(TestUtils.signOf(media1.compareTo(media2)), correctAnswers[i]);
            }
        }
    }

    @TestCase(name = ".compareTo(): Tests for transitivity (not correctness)")
    @Tip(description = "Read the Java 11 compareTo() documentation for info on transitivity.\n"
               + "\t      If x.compareTo(y) > 0 and y.compareTo(z) > 0, then x.compareTo(z) MUST be > 0.\n"
               + "\t      This method checks MANY combinations of ages and numCandys for transitivity.\n")
    public void compareToTransitivityTest() throws TestFailedException {

        Media[] mediaPossibilities = getPossibleMediaForEquals();

        for (int i = 0; i < mediaPossibilities.length; i++) {
            for (int j = 0; j < mediaPossibilities.length; j++) {
                for (int k = 0; k < mediaPossibilities.length; k++) {
                    Media media1 = mediaPossibilities[i];
                    Media media2 = mediaPossibilities[j];
                    Media media3 = mediaPossibilities[k];
                    String string1 = media1.toString();
                    String string2 = media2.toString();
                    String string3 = media3.toString();

                    if (media1.compareTo(media2) > 0 && media2.compareTo(media3) > 0 && media1.compareTo(media3) <= 0) { // This comes directly from the compareTo docs
                        System.out.println(ColorUtils.formatColorString(AsciiColorCode.BRIGHT_RED_BACKGROUND,
                                AsciiColorCode.BRIGHT_WHITE_FOREGROUND, " TRANSITIVITY TEST FAILED: \u00BB ") + "\nWhen "
                                + "x = \"" + string1 + "\", y = \"" + string2 + "\", z = \"" + string3 + "\"");
                        TestFunction.assertEqual(TestUtils.signOf(media1.compareTo(media3)), 1);
                    }
                }
            }
        }
    }

    /**
     * Returns 81 possible media. This is generalizeable, but it's only for the compareTo() check, so I'm OK with hard-coding some values,
     * in exchange for improved readability.
     * @return
     */
    private Media[] getPossibleMediaForEquals() {

        Media[] possibilities = new Media[81];
        
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                for (int k = 0; k < 3; k++) {
                    for (int l = 0; l < 3; l++) {
                        possibilities[i * 27 + j * 9 + k * 3 + l] = new MediaSubclass(GENRES[i], NAMES[j], RATINGS[k], PRICES[l]);
                    }
                }
            }
        }

        return possibilities;
    }



    /**
     * Media subclass, just for testing.
     */
    static class MediaSubclass extends Media {
        public MediaSubclass(Genre genre, String name, int rating, double rentalPrice) {
            super(genre, name, rating, rentalPrice);
        }

        public MediaSubclass(Genre genre, String name, int rating) {
            super(genre, name, rating);
        }
    }
}
//AUTOGENERATED FROM ../src/IOHijacker.java

/**
 * A helper class used for redirecting System.out to check against
 */
class IOHijacker {
    private static IOHijacker INSTANCE;

    private String log = "";
    private PrintStream originalStream;
    private PrintStream redirectedStream;
    private boolean recording = false;

    private IOHijacker() {
        this.originalStream = System.out;
    }

    /**
     * Starts recording all System.out messages to the console and stores them in
     * IOHijacker.log.
     * 
     * Until stopRecording is called, no System.out messages will appear.
     */
    public void startRecording() {
        log = "";

        if (redirectedStream == null)
            redirectedStream = getRedirectedStream();

        System.setOut(redirectedStream);

        recording = true;
    }

    /**
     * Stops the current recording, resetting System.out to its default behavior.
     * 
     * @return A list of all messages sent during the recording
     */
    public String stopRecording() {
        recording = false;

        System.setOut(originalStream);

        return log;
    }

    /**
     * Retrieves the current log of messages in a recording
     * 
     * @return The current log of messages
     */
    public String getCurrentLog() {
        return log;
    }

    /**
     * Retrieves a custom PrintStream that redirects print to instead logMessage
     * 
     * @return The custom PrintStream
     */
    private PrintStream getRedirectedStream() {
        return new PrintStream(System.out, true) {
            @Override
            public void print(String s) {
                IOHijacker.appendMessage(s);
            }

            @Override
            public PrintStream printf(String message, Object... args) {
                IOHijacker.appendMessage(String.format(message, args));
                return this;
            }

            @Override
            public void println(String s) {
                IOHijacker.appendMessage(s + "\n");
            }

        };
    }

    /**
     * Returns the Singleton's instance, creating one if it doesn't exist.
     * 
     * @return The IOHijacker instance
     */
    public static IOHijacker getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new IOHijacker();
        }

        return INSTANCE;
    }

    /**
     * Appends a string message to the log ONLY if recording.
     * 
     * @param message The message to be recorded
     */
    private static void appendMessage(String message) {
        IOHijacker instance = getInstance();

        if (!instance.recording)
            return;

        instance.log += message.replaceAll("\r","");
    }
}

//AUTOGENERATED FROM ../src/BlockbusterTests.java

class BlockbusterTests {

    static final ArrayList<Media> MOVIE_LIST = new ArrayList<Media>() {
        {
            add(new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120));
            add(new Movie(Genre.ACTION, "Fast and Furious 2", 37, 6.70, 120));
            add(new Movie(Genre.ACTION, "Fast and Furious 3", 38, 6.70, 120));
            add(new Movie(Genre.ACTION, "Fast and Furious 4", 28, 6.70, 120));
            add(new Movie(Genre.ACTION, "Fast and Furious 5", 78, 6.70, 120));
            add(new Movie(Genre.ACTION, "Fast and Furious 6", 71, 6.70, 120));
            add(new Movie(Genre.ACTION, "Fast and Furious 7", 81, 6.70, 120));
            add(new Movie(Genre.ACTION, "Fast and Furious 8", 67, 6.70, 120));
            add(new Movie(Genre.ACTION, "Fast and Furious 9", 59, 6.70, 120));
            add(new Movie(Genre.ACTION, "Fast and Furious 10", 56, 6.70, 120));
        }
    };

    static final ArrayList<Media> GAME_LIST = new ArrayList<Media>() {
        {
            add(new VideoGame(Genre.ACTION, "Uncharted 1", 54, 6.70, 2, false));
            add(new VideoGame(Genre.ACTION, "Uncharted 2", 37, 6.70, 2, false));
            add(new VideoGame(Genre.ACTION, "Uncharted 3", 38, 6.70, 2, false));
            add(new VideoGame(Genre.ACTION, "Uncharted 4", 28, 6.70, 2, false));
            add(new VideoGame(Genre.ACTION, "Uncharted 5", 78, 6.70, 2, false));
            add(new VideoGame(Genre.ACTION, "Uncharted 6", 71, 6.70, 2, false));
            add(new VideoGame(Genre.ACTION, "Uncharted 7", 81, 6.70, 2, false));
            add(new VideoGame(Genre.ACTION, "Uncharted 8", 67, 6.70, 2, false));
            add(new VideoGame(Genre.ACTION, "Uncharted 9", 59, 6.70, 2, false));
            add(new VideoGame(Genre.ACTION, "Uncharted 10", 56, 6.70, 2, true));
        }
    };

    @TestCase(name = "Testing the addMedia() method")
    @Tip(description = "What order should media be added?")
    public void addMediaInOrder() throws TestFailedException {

        Blockbuster store = new Blockbuster();
        for (int i = 0; i < MOVIE_LIST.size(); i++) {
            store.addMedia(MOVIE_LIST.get(i));
        }

        String expectedString = ""
            + "Genre: ACTION, Name: Fast and Furious 1, Rating: 54, Rental Price: $6.70, Runtime: 120\n"
            + "Genre: ACTION, Name: Fast and Furious 2, Rating: 37, Rental Price: $6.70, Runtime: 120\n"
            + "Genre: ACTION, Name: Fast and Furious 3, Rating: 38, Rental Price: $6.70, Runtime: 120\n"
            + "Genre: ACTION, Name: Fast and Furious 4, Rating: 28, Rental Price: $6.70, Runtime: 120\n"
            + "Genre: ACTION, Name: Fast and Furious 5, Rating: 78, Rental Price: $6.70, Runtime: 120\n"
            + "Genre: ACTION, Name: Fast and Furious 6, Rating: 71, Rental Price: $6.70, Runtime: 120\n"
            + "Genre: ACTION, Name: Fast and Furious 7, Rating: 81, Rental Price: $6.70, Runtime: 120\n"
            + "Genre: ACTION, Name: Fast and Furious 8, Rating: 67, Rental Price: $6.70, Runtime: 120\n"
            + "Genre: ACTION, Name: Fast and Furious 9, Rating: 59, Rental Price: $6.70, Runtime: 120\n"
            + "Genre: ACTION, Name: Fast and Furious 10, Rating: 56, Rental Price: $6.70, Runtime: 120";

        TestFunction.assertEqual(arrayToString(getInventory(store)), expectedString);
    }

    @TestCase(name = ".removeMedia(): Media not found")
    @Tip(description = "If the Media isn't found, what should removeMedia() return?")
    public void removeMediaMediaNotFound() throws TestFailedException {
        Blockbuster store = fakeConstructorBlockbuster(GAME_LIST);
        VideoGame game = new VideoGame(Genre.FANTASY, "Harry Potter", 0);

        Media removed = store.removeMedia(game);

        if (removed == null) {
            TestFunction.assertEqual("null", "null");
        } else {
            TestFunction.assertEqual(removed.toString(), "null");
        }
    }

    @TestCase(name = ".removeMedia(): Does NOT return the original media")
    @Tip(description = "Even though the two are .equals(), make sure you return the one that is removed, not the original!")
    public void removeMediaMediaFoundDifferentReturn() throws TestFailedException {
        Blockbuster store = fakeConstructorBlockbuster(GAME_LIST);
        Movie game = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120);

        Media removed = store.removeMedia(game);

        TestFunction.assertEqual(game == removed, false);
    }

    @TestCase(name = ".removeMedia(): Returns the found Media")
    @Tip(description = "Which fields should be compared? (all of them should be!)")
    public void removeMediaMediaFound() throws TestFailedException {
        Blockbuster store = fakeConstructorBlockbuster(MOVIE_LIST);
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120);

        Media removed = store.removeMedia(movie);

        if (removed == null) {
            TestFunction.assertEqual(null, "Genre: ACTION, Name: Fast and Furious 1, Rating: 54, Rental Price: $6.70, Runtime: 120");
        } else {
            TestFunction.assertEqual(removed.toString(), "Genre: ACTION, Name: Fast and Furious 1, Rating: 54, Rental Price: $6.70, Runtime: 120");
        }
    }

    @TestCase(name = ".removeMedia(): Runtime differs, should return null")
    @Tip(description = "Which fields should be compared? (all of them should be!)")
    public void removeMediaNotFound() throws TestFailedException {
        Blockbuster store = fakeConstructorBlockbuster(MOVIE_LIST);
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 130);

        Media removed = store.removeMedia(movie);

        if (removed == null) {
            TestFunction.assertEqual(null, (String) null);
        } else {
            TestFunction.assertEqual(removed.toString(), null);
        }
    }

    @TestCase(name = ".sort(): Sorts by title")
    @Tip(description = "What order should Media be compared by? Which fields should be compared? Which fields shouldn't be compared?")
    public void sortMediaByTitle() throws TestFailedException {
        ArrayList<Media> GAME_LIST = new ArrayList<Media>() {
            {
                add(new VideoGame(Genre.ACTION, "Uncharted 5", 10, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 2", 10, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 4", 10, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 8", 10, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 1", 10, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 6", 10, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 3", 10, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 9", 10, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 7", 10, 6.70, 2, false));
            }
        };

        Blockbuster store = fakeConstructorBlockbuster(GAME_LIST);
        store.sortMedia();
        ArrayList<Media> inventory = getInventory(store);
        String expectedString = ""
            + "Genre: ACTION, Name: Uncharted 1, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted 2, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted 3, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted 4, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted 5, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted 6, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted 7, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted 8, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted 9, Rating: 10, Rental Price: $6.70, Players: 2, does not need console";

        TestFunction.assertEqual(arrayToString(inventory), expectedString);
    }

    @TestCase(name = ".sort(): Sorts by genre")
    @Tip(description = "What order should Media be compared by? Which fields should be compared? Which fields shouldn't be compared?")
    public void sortMediaByGenre() throws TestFailedException {
        ArrayList<Media> GAME_LIST = new ArrayList<Media>() {
            {
                add(new VideoGame(Genre.SCI_FI, "Uncharted 5", 10, 6.70, 2, false));
                add(new VideoGame(Genre.HORROR, "Uncharted 2", 10, 6.70, 2, false));
                add(new VideoGame(Genre.ROMANCE, "Uncharted 4", 10, 6.70, 2, false));
                add(new VideoGame(Genre.FANTASY, "Uncharted 1", 10, 6.70, 2, false));
                add(new VideoGame(Genre.COMEDY, "Uncharted 6", 10, 6.70, 2, false));
                add(new VideoGame(Genre.MYSTERY, "Uncharted 3", 10, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted 7", 10, 6.70, 2, false));
            }
        };

        Blockbuster store = fakeConstructorBlockbuster(GAME_LIST);
        store.sortMedia();
        ArrayList<Media> inventory = getInventory(store);
        String expectedString = ""
            + "Genre: ACTION, Name: Uncharted 7, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: COMEDY, Name: Uncharted 6, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: FANTASY, Name: Uncharted 1, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: HORROR, Name: Uncharted 2, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: MYSTERY, Name: Uncharted 3, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ROMANCE, Name: Uncharted 4, Rating: 10, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: SCI_FI, Name: Uncharted 5, Rating: 10, Rental Price: $6.70, Players: 2, does not need console";

        TestFunction.assertEqual(arrayToString(inventory), expectedString);
    }

    @TestCase(name = ".sort(): Sorts by rating")
    @Tip(description = "What order should Media be compared by? Which fields should be compared? Which fields shouldn't be compared?")
    public void sortMediaByRating() throws TestFailedException {
        ArrayList<Media> GAME_LIST = new ArrayList<Media>() {
            {
                add(new VideoGame(Genre.ACTION, "Uncharted", 5, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted", 2, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted", 6, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted", 3, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted", 4, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted", 7, 6.70, 2, false));
                add(new VideoGame(Genre.ACTION, "Uncharted", 1, 6.70, 2, false));
            }
        };

        Blockbuster store = fakeConstructorBlockbuster(GAME_LIST);
        store.sortMedia();
        ArrayList<Media> inventory = getInventory(store);
        String expectedString = ""
            + "Genre: ACTION, Name: Uncharted, Rating: 1, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted, Rating: 2, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted, Rating: 3, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted, Rating: 4, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted, Rating: 5, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted, Rating: 6, Rental Price: $6.70, Players: 2, does not need console\n"
            + "Genre: ACTION, Name: Uncharted, Rating: 7, Rental Price: $6.70, Players: 2, does not need console";

        TestFunction.assertEqual(arrayToString(inventory), expectedString);
    }

    @TestCase(name = ".findMedia(): Media to find is equal")
    @Tip(description = "What fields should be compared? What fields SHOULDN'T be compared?\nNOTE: This test only works if .sort() works correctly!")
    public void findMediaMediaEqual() throws TestFailedException {
        Blockbuster store = fakeConstructorBlockbuster(MOVIE_LIST);
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120);
        store.sortMedia();
        Media found = store.findMedia(movie);

        TestFunction.assertEqual(found == null ? null : found.toString(), "Genre: ACTION, Name: Fast and Furious 1, Rating: 54, Rental Price: $6.70, Runtime: 120");
    }

    @TestCase(name = ".findMedia(): Media should be found, but rentalPrice and runtime differ")
    @Tip(description = "What fields should be compared? What fields SHOULDN'T be compared?\nFor more rationale on why this test is included, see https://edstem.org/us/courses/42939/discussion/3721454?comment=8697564\nNOTE: This test only works if .sort() works correctly!")
    public void findMediaMediaCompareToIsZero() throws TestFailedException {
        Blockbuster store = fakeConstructorBlockbuster(MOVIE_LIST);
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.79, 130);

        store.sortMedia();
        Media found = store.findMedia(movie);

        TestFunction.assertEqual(found == null ? null : found.toString(), "Genre: ACTION, Name: Fast and Furious 1, Rating: 54, Rental Price: $6.70, Runtime: 120");
    }

    @TestCase(name = ".findMedia(): Media should not be found")
    @Tip(description = "What fields should be compared? What fields SHOULDN'T be compared?\nNOTE: This test only works if .sort() works correctly!")
    public void findMediaNotFound() throws TestFailedException {
        Blockbuster store = fakeConstructorBlockbuster(MOVIE_LIST);
        Movie movie = new Movie(Genre.ACTION, "Fast and Furious 11", 54, 6.79, 130);
        store.sortMedia();
        Media found = store.findMedia(movie);
        TestFunction.assertEqual(found == null ? null : found.toString(), null);
    }

    @TestCase(name = ".getMostPopularMovie(): No movie exists in the inventory")
    @Tip(description = "What should getMostPopularMovie() return when there are no movies?")
    public void getMostPopularMovieNotFound() throws TestFailedException {
        Blockbuster store = fakeConstructorBlockbuster(GAME_LIST);
        Media found = store.getMostPopularMovie();
        TestFunction.assertEqual(found == null ? (String) null : found.toString(), (String) null);
    }

    @TestCase(name = ".getMostPopularMovie(): Highest rating")
    @Tip(description = "What criteria should getMostPopularMovie() use?")
    public void getMostPopularMovieRatingDiffers() throws TestFailedException {
        Blockbuster store = fakeConstructorBlockbuster(MOVIE_LIST);
        Media found = store.getMostPopularMovie();
        String highestMovie = "Genre: ACTION, Name: Fast and Furious 7, Rating: 81, Rental Price: $6.70, Runtime: 120";

        TestFunction.assertEqual(found == null ? (String) null : found.toString(), highestMovie);
    }

    @TestCase(name = ".getMostPopularMovie(): Name differs")
    @Tip(description = "What criteria should getMostPopularMovie() use?")
    public void getMostPopularMovieNameDiffers() throws TestFailedException {
        ArrayList<Media> modifiedMovieList = new ArrayList<Media>() {
            {
                add(new Movie(Genre.ACTION, "Fast and Furious 1", 54, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 2", 37, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 3", 38, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 4", 81, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 5", 78, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 6", 71, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 7", 81, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 8", 67, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 9", 59, 6.70, 120));
                add(new Movie(Genre.ACTION, "Fast and Furious 10", 56, 6.70, 120));
            }
        };
        Blockbuster store = fakeConstructorBlockbuster(modifiedMovieList);
        Media found = store.getMostPopularMovie();
        String highestMovie = "Genre: ACTION, Name: Fast and Furious 4, Rating: 81, Rental Price: $6.70, Runtime: 120";
        TestFunction.assertEqual(found == null ? (String) null : found.toString(), highestMovie);
    }



    static Blockbuster fakeConstructorBlockbuster(ArrayList<Media> media) throws TestFailedException {
        Blockbuster store = new Blockbuster();

        Field[] fields = Blockbuster.class.getDeclaredFields();
        Field inventory = null;
        for (int i = 0; i < fields.length; i++) {
            if (fields[i].getName() == "inventory") {
                inventory = fields[i];
                break;
            }
        }
        try {
            inventory.setAccessible(true);
            inventory.set(store, copyArray(media));
        } catch (Exception e) {
            TestFunction.failTest("An error occurred. " + e.getMessage());
        }
        return store;
    }

    private static ArrayList<Media> copyArray(ArrayList<Media> toCopy) {
        ArrayList<Media> newArray = new ArrayList<Media>();
        for (int i = 0; i < toCopy.size(); i++) {
            newArray.add(toCopy.get(i));
        }
        return newArray;
    }

    static String arrayToString(ArrayList<Media> inputs) {
        StringBuilder builder = new StringBuilder();
        if (inputs.size() == 0) {
            return "";
        } else {
            builder.append(inputs.get(0));
        }
        for (int i = 1; i < inputs.size(); i++) {
            builder.append("\n" + inputs.get(i));
        }
        return builder.toString();
    }

    static ArrayList<Media> getInventory(Blockbuster store) {
        Field[] fields = Blockbuster.class.getDeclaredFields();
        Field inventory = null;
        for (int i = 0; i < fields.length; i++) {
            if (fields[i].getName() == "inventory") {
                inventory = fields[i];
                break;
            }
        }
        if (inventory != null) {
            try {
                inventory.setAccessible(true);
                return (ArrayList<Media>) inventory.get(store);
            } catch (IllegalArgumentException e) {
                System.out.println("Test could not be run.");
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                System.out.println("Test could not be run.");
                e.printStackTrace();
            }
        }
        return null;
    }
}

//AUTOGENERATED FROM ../src/TestCase.java

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
@interface TestCase {
    /**
     * The name of the TestCase, used for describing what a test might be doing
     * 
     * @return The name of the TestCase
     */
    public String name() default "UNNAMED_TEST";
}